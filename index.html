<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"angryboo.github.io","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="I can do this all day">
<meta property="og:type" content="website">
<meta property="og:title" content="angryboo">
<meta property="og:url" content="https://angryboo.github.io/index.html">
<meta property="og:site_name" content="angryboo">
<meta property="og:description" content="I can do this all day">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="angryboo">
<meta property="article:tag" content="vs">
<meta property="article:tag" content=" html">
<meta property="article:tag" content=" css">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://angryboo.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>angryboo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">angryboo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">angryboo blog</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>홈</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>카테고리</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>아카이브</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/16/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-16%20%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/16/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-16%20%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/" class="post-title-link" itemprop="url">실행컨텍스트</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-03-16 18:59:53" itemprop="dateCreated datePublished" datetime="2020-03-16T18:59:53+09:00">2020-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-17 01:58:42" itemprop="dateModified" datetime="2020-03-17T01:58:42+09:00">2020-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="실행-컨텍스트"><a href="#실행-컨텍스트" class="headerlink" title="실행 컨텍스트"></a>실행 컨텍스트</h1><h2 id="1-소스코드의-타입"><a href="#1-소스코드의-타입" class="headerlink" title="1. 소스코드의 타입"></a>1. 소스코드의 타입</h2><ol>
<li><p><strong>전역코드</strong> : 전역에 존재하는 코드. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함하지 않음</p>
<ul>
<li>전역 코드는 전역변수를 관리하기 위해 최상위 스코프인 전역스코프를 생성해야 함.</li>
<li>그리고 var키워드로 선언된 전역변수와 함수 선언문으로 정의된 전역함수를 전역객체의 프로퍼티와 메소드로 바인딩하고 참조하기 위해 전역객체와 연결되어야 한다</li>
<li>이를 위해 전역코드가 평가되면 전역실행 컨텍스트가 생성된다.</li>
</ul>
</li>
<li><p><strong>함수코드</strong> : 함수 내부에 존재하는 코드를 말함, 함수 내부에 중첩된 함수, 클래스 등의 내부커드는 포함하지 않음</p>
<ul>
<li>함수코드는 지역 스코프를 생성하고 지역변수와 매개변수를 관리해야 한다.</li>
<li>그리고 생성한 지역 스코프에서 시작하는 스코프체인의 일원으로 연결해야 한다.</li>
<li>이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.</li>
</ul>
</li>
<li><p><strong>eval</strong> 코드 : 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드</p>
<ul>
<li>eval 코드는 엄격 모드에서 자신만의 독자적인 스코프를 생성한다.</li>
<li>이를위해 eval코드가 평가되면 eval실행 컨텍스트가 생성된다.</li>
</ul>
</li>
<li><p><strong>모듈코드</strong> : 모듈 내부에 존재하는 소스코드를 말한다. 모듈 내부의 함수 클래스 내부 코드는 포함되지 않는다.  </p>
<ul>
<li>모듈코드는 모듈별로 독립적인 스코프를 생성한다.</li>
<li>이를위해 모듈코드가 평가되면 모듈 실행 컨텍스트가 생성된다.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-소스코드-평가와-실행"><a href="#2-소스코드-평가와-실행" class="headerlink" title="2. 소스코드 평가와 실행"></a>2. 소스코드 평가와 실행</h2><ul>
<li>자바스크립트는 소스코드를 소스코드의 평가 과정과 소스코드의 실행과정 2개의 과정으로 나누어 실행함</li>
</ul>
<p><strong>소스코드의 평가(선언문) 과정</strong></p>
<ol>
<li>실행컨텍스트 생성</li>
<li>변수, 함수 선언문 만을 먼저 실행</li>
<li>생성된 변수나 함수의 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환결 레코드)에 등록</li>
</ol>
<p><strong>소스코드의 실행 과정(선언문 이외의 문)</strong></p>
<ol>
<li>소스코드 실행에 필요한 정보, 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 취득</li>
<li>변수값 변경과 같은 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록</li>
</ol>
<hr>
<h2 id="3-실행-컨텍스트의-역할"><a href="#3-실행-컨텍스트의-역할" class="headerlink" title="3. 실행 컨텍스트의 역할"></a>3. 실행 컨텍스트의 역할</h2><ol>
<li><p>전역코드의 평가</p>
<ul>
<li>전역코드의 평가 과정을 거치며 전역코드 실행을 위한 준비를 함</li>
<li>소스코드 평가 과정에서는 선언문 만을 먼저 실행(변수 선언문, 함수 선언문)</li>
<li>생성된 전역변수와 전역함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록됨</li>
<li>또한 var키워드로 선언된 전역변수와 함수 선언문으로 정의된 전역함수는 전역 객체의 프로퍼티와 메소드가 됨</li>
</ul>
</li>
<li><p>전역 코드 실행</p>
<ul>
<li>전역코드의 평가가 끝나면 전역코드가 순차적 실행</li>
<li>전역변수에 값이 할당되고 함수가 회풀됨</li>
<li>함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시 중단하고 코드 실행순서를 변경하여 함수 내부로 진입 함</li>
</ul>
</li>
<li><p>함수 코드의 평가</p>
<ul>
<li>코드 실행 순서가 변경되어 함수 내부로 진입하면 함수 코드의 평가 과정을 거침</li>
<li>매개변수와 지역변수 선언분이 먼저 실행되고 그 결과 생성된 매개변수와 지역변수가 실행컨텍스트가 관리하는 지역 스코프에 등록됨</li>
<li>함수 내부에서 지역변수처럼 사용할 수 있는 arguments객체도 생성되어 지역 스코프에 등록됨</li>
</ul>
</li>
<li><p>함수 코드의 실행</p>
<ul>
<li>함수 평가가 끝나면 함수 코드가 순차적으로 실행 됨</li>
<li>이때 매개변수와 지역변수에 값이 할당됨</li>
<li>함수의 코드의 실행이 종료되고 함수 호출 이전으로 되돌아가 전역코드 실행을 계속 함</li>
</ul>
</li>
</ol>
<p><strong>이처럼 코드가 실행되려면 아래와 같이 스코프, 식별자, 코드 실행 순서등의 관리가 필요하다</strong></p>
<ol>
<li>선언에 의해 생성된 모든 식별자를 스코프를 구분하여 등록하고 상태 변화(식별자에 바인딩 된 값)를 지속적으로 관리 할 수 있어야 함</li>
<li>스코프는 중첩 관계에 의해 스코프 체인을 형성 해야 함, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 함</li>
<li>현재 실행중인 코드의 실행 순서를 변경 할 수 있여하 하며 다시 되돌아 갈 수도 있어야 함</li>
</ol>
<p><strong>실행 컨텍스트는 소스코드를 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역임</strong><br><strong>실행 컨첵스트는 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.</strong></p>
<p>식별자와 스코프는 실행 컨텍스트의 <strong>렉시컬 환경</strong> 으로 관리하고 코드 실행 순서는 <strong>실행 컨텍스트 스택</strong> 으로 관리한다</p>
<hr>
<h2 id="4-실행-컨텍스트-스택"><a href="#4-실행-컨텍스트-스택" class="headerlink" title="4. 실행 컨텍스트 스택"></a>4. 실행 컨텍스트 스택</h2><ul>
<li>코드의 실행 순서를 관리하며 콜스택(Call stack)이라고 부르기도 함</li>
<li>소스코드가 평가되면 실행 컨텍스트가 생성되고 실행 컨택스트 스택의 최상위에 쌓임</li>
<li>실행 컨텍스트 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행중인 코드의 실행 컨텍스트 이며 실행 중인 실행 컨텍스트 라고 함</li>
<li>코드의 제어권은 최상위 실행 컨텍스트에 있음</li>
</ul>
<hr>
<h2 id="5-동기식-처리-모델과-비동기식-처리-모델"><a href="#5-동기식-처리-모델과-비동기식-처리-모델" class="headerlink" title="5. 동기식 처리 모델과 비동기식 처리 모델"></a>5. 동기식 처리 모델과 비동기식 처리 모델</h2><ul>
<li><p>자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖음</p>
</li>
<li><p>자바스크립트 애플리케이션은 여러개의 실행 컨텍스트 스택에서 실행할 수 없고 최상위 스택만 실행 가능</p>
</li>
<li><p>이는 자바스크립트가 싱글 스레드로 동작하는 것을 의미함</p>
</li>
<li><p>자바스크립트의 실행 컨텍스트는 상위의 스택이 팝되어 제거될때까지 실행을 대기 함</p>
</li>
<li><p>이처럼 하나의 처리가 종료 되어야 다음 처리를 실행할 수 있는 것을 동기식 처리 모델 이라고 함</p>
</li>
<li><p>동기식 처리 모델을 직렬적으로 태스크를 수행 함. 즉 태스크는 순차적으로 실행되며 어떤 작업이 수행중이면 다음 작업은 대기함</p>
</li>
<li><p>자바 스크립트는 비동기식 처리 모델을 지원 함</p>
</li>
<li><p>비동기식 처리 모델은 병렬적으로 태스크를 수행 함.</p>
</li>
<li><p>태스크가 종료되지 않은 상태라 하더라도 대기하지 않고 다음 태스크를 실행 함</p>
</li>
</ul>
<hr>
<h2 id="6-렉시컬-환경"><a href="#6-렉시컬-환경" class="headerlink" title="6. 렉시컬 환경"></a>6. 렉시컬 환경</h2><ul>
<li><p>렉시컬 환경은 식별자와 식별자에 바인딩 된 값, 상위 스코프에 대한 참조를 기록하는 환경</p>
</li>
<li><p>렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체임</p>
</li>
<li><p>렉시컬 환경은 두개의 컴포넌트로 구성 됨</p>
<ol>
<li>환경 레코드 : 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩 된 값을 관리하는 저장소, 소스코드 타입에 따라 내용에 차이가 있음</li>
<li>외부 렉시컬 환경에 대한 참조 : 외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킴(해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위코드의 렉시컬 환경)</li>
</ol>
</li>
</ul>
<p>–  </p>
<h2 id="7-실행-컨텍스트의-생성과-식별자-검색-과정"><a href="#7-실행-컨텍스트의-생성과-식별자-검색-과정" class="headerlink" title="7. 실행 컨텍스트의 생성과 식별자 검색 과정"></a>7. 실행 컨텍스트의 생성과 식별자 검색 과정</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> z = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b + x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p><img src="../image/111.jpeg" alt="예제 코드 실행 과정"><br>위 코드는 다음과 같은 순으로 실행 됨</p>
<p>전역 코드 평가 &gt; 전역 코드 실행 &gt; foo 함수 코드 평가 &gt; foo 함수 코드 실행 &gt; bar 함수 코드 평가 &gt; bar 함수 코드 실행 &gt; bar 함수 실행 종료 &gt; foo 함수 실행 종료 &gt; 전역 코드 실행 종료</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/15/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-15%20this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-15%20this/" class="post-title-link" itemprop="url">this</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-15 17:24:06 / Updated at: 19:20:43" itemprop="dateCreated datePublished" datetime="2020-03-15T17:24:06+09:00">2020-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><h2 id="1-this-키워드"><a href="#1-this-키워드" class="headerlink" title="1. this 키워드"></a>1. this 키워드</h2><ul>
<li>객체는 상태를 나타내는 프로퍼티와 동작을 나타내는 메소드를 하나의 논리적인 단위로 묶은 복합적인 자료구조임</li>
<li>동작을 나타내는 메소드는 자신이 속한 객체의 상태, 즉 프로퍼티를 참조하고 변경 할 수 있어야 함</li>
<li>이때 메소드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 함<ul>
<li>메소드 내부에서 자신이 속한 객체의 프로퍼티를 참조하려면 메소드가 호출되는 시점에(참조 표현식이 평가되는 시점) 자신이 속한 객체가 생성되고 생성된 객체가 식별자에 할당이 되어야 함</li>
</ul>
</li>
</ul>
<p><strong>this는 자신이 속한 객체 또는 자신이 생성한 인스턴스를 가리키는 자기 참조 변수임</strong><br><strong>this를 통해 자신이 속산 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메소드를 참조할 수 있음</strong></p>
<hr>
<h2 id="2-함수-호출-방식과-this-바인딩"><a href="#2-함수-호출-방식과-this-바인딩" class="headerlink" title="2. 함수 호출 방식과 this 바인딩"></a>2. 함수 호출 방식과 this 바인딩</h2><p><strong>this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다</strong></p>
<ul>
<li>렉시컬 스코프는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정하고, this에 바인딩 될 객체는 함수 호출 시점에 결정 됨</li>
</ul>
<hr>
<h3 id="2-1-일반함수-호출"><a href="#2-1-일반함수-호출" class="headerlink" title="2-1 일반함수 호출"></a>2-1 일반함수 호출</h3><ul>
<li><p>기본적으로 this에 전역객체가 바인딩 됨</p>
</li>
<li><p>함수 중첩 사용 시에도 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩 됨</p>
</li>
<li><p>this는 객체의 프로퍼티나 메소드를 참조하기 위한 자기참조 변수이므로 객체를 생성하지 않는 일반함수에서 사용은 의미가 없음</p>
</li>
<li><p>메소드 내에서 정의한 중첩함수 내에서 일반함수로 호출 시에도 전역 객체가 바인딩 됨</p>
</li>
<li><p><em>일반 함수로 호출된 모든 함수 내부의 this에는 전역 객체가 바인딩 됨</em></p>
</li>
<li><p>메소드 내에서 정의한 중첩 함수 또는 메소드에게 전달한 콜백 함수의 this가 전역객체를 바인딩 하는 것은 문제가 있음</p>
</li>
<li><p>중첩 함수 또는 콜백 함수는 외부 함수를 돕는 헬퍼 함수로써 역할을 하는데 외부 함수 로직을 대신하는 경우가 대부분이나 외부 함수인 메소드와 중첩 함수의 this가 일치하지 않는다는것은 중첩함수나 콜백함수를 헬퍼함수로 동작하기 어렵게 된다.</p>
</li>
<li><p>메소드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 메소드의 this 바인딩과 일치시키기 위한 방법은 아래와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>; <span class="comment">// 메소드 내부의 this바인딩을 변수에 할당</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(that.value) <span class="comment">// 메소드 내부에서 this가 할당된 변수 that을 참조</span></span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>
<p>위 방법 이외에도 자바스크립트는 this를 명시적으로 바인딩 할 수 있는 Function.prototype.apply, Function.prototype.call, Function.prototype.bind 메소드를 제공한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>), <span class="number">100</span>) <span class="comment">// bind 메소드로 명시적으로 this를 바인딩</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-2-메소드-호출"><a href="#2-2-메소드-호출" class="headerlink" title="2-2 메소드 호출"></a>2-2 메소드 호출</h3><ul>
<li>메소드 내부의 this는 메소드를 호출한 객체에 바인딩 된다</li>
<li>메소드를 소유한 객체가 아닌 메소드를 호출한 객체에 바인딩 되는것에 주의한다.</li>
<li>프로토타입 메소드 내부에서 사용된 this도 일반 메소드와 마찬가지로 해당 메소드를 호출한 객체에 바인딩 된다</li>
</ul>
<h3 id="2-3-생성자-함수-호출"><a href="#2-3-생성자-함수-호출" class="headerlink" title="2-3 생성자 함수 호출"></a>2-3 생성자 함수 호출</h3><ul>
<li>생성자 함수 내부의 this에는 생성자 함수가 생성할 인스턴스가 바인딩 된다</li>
<li>생성자 함수를 new연산자와 함께 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다.</li>
</ul>
<h3 id="2-4-Function-prototype-apply-call-bind-메소드에-의한-간접-호출"><a href="#2-4-Function-prototype-apply-call-bind-메소드에-의한-간접-호출" class="headerlink" title="2-4 Function.prototype.apply/call/bind 메소드에 의한 간접 호출"></a>2-4 Function.prototype.apply/call/bind 메소드에 의한 간접 호출</h3><ul>
<li>apply, call 메소드는 인수로 this와 인수 리스트를 전달받아 함수를 호출한다.</li>
<li>apply와 call메소드는 Function.prototype의 메소드이다.</li>
<li>apply와 call 메소드는 Function 생성자 함수를 constructor 프로퍼티로 가리키는 모든 함수가 상속받아 사용할 수 있다.</li>
<li>apply와 call 메소드는 호출할 함수에 인수를 전달할 방식만 다를 뿐 동일하게 동작한다</li>
</ul>
<p><strong>apply와 call 메소드의 본질적인 기능은 함수를 호출하는 것이다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThisBinding</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thisArg = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125; <span class="comment">// this로 사용할 객체</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getThisBinding()); <span class="comment">// window</span></span><br><span class="line"><span class="built_in">console</span>.log(getThisBinding.apply(thisArg)); <span class="comment">// Object &#123; a: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(getThisBinding.call(thisArg)); <span class="comment">// Object &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(getThisBinding.apply(thisArg, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><br><span class="line"><span class="comment">// apply 메소드는 함수에 전달할 인수를 배열에 묶어 전달</span></span><br><span class="line"><span class="built_in">console</span>.log(getThisBinding.call(thisArg, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// call 메소드는 함수에 전달할 인수를 쉼표로 구분한 리스트로 전달</span></span><br></pre></td></tr></table></figure>

<ul>
<li>apply와 call 메소드의 대표적인 용도는 argument 객체와 같은 유사배셜 객체에 배열 메소드를 사용하는 경우다.</li>
<li>argument객체는 배열이 아니기 때문에 Array.prototype.slice와 같은 배열 메소드를 사용할 수 없으나 apply와 call 메소드를 이용하면 가능하다</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/15/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-15%20%EB%B9%8C%ED%8A%B8%EC%9D%B8%20%EA%B0%9D%EC%B2%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-15%20%EB%B9%8C%ED%8A%B8%EC%9D%B8%20%EA%B0%9D%EC%B2%B4/" class="post-title-link" itemprop="url">빌트인 객체</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-15 12:57:11 / Updated at: 17:23:20" itemprop="dateCreated datePublished" datetime="2020-03-15T12:57:11+09:00">2020-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="빌트인-객체"><a href="#빌트인-객체" class="headerlink" title="빌트인 객체"></a>빌트인 객체</h1><h2 id="1-자바스크립트-객체의-분류"><a href="#1-자바스크립트-객체의-분류" class="headerlink" title="1. 자바스크립트 객체의 분류"></a>1. 자바스크립트 객체의 분류</h2><ol>
<li>표준 빌트인 객체<ul>
<li>ECMAScript 사양에 정의 된 객체를 말하며 애플리케이션 전역의 공통 기능을 제공함.</li>
<li>자바스크립트 실행환경과 관게없이 언제나 사용 가능 함</li>
<li>전역 객체의 프로퍼티 처럼 제공됨으로 별도의 선언 없이 전역변수처럼 언제나 참조 가능</li>
</ul>
</li>
<li>호스트 객체<ul>
<li>ECMAScript 사양에는 정의되어 있지는 않지만 자바스크립트 실행환경에서 추가적으로 제공함</li>
</ul>
</li>
<li>사용자 정의 객체<ul>
<li>사용자가 직접 정의한 객체를 의미함</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-표준-빌트인-객체"><a href="#2-표준-빌트인-객체" class="headerlink" title="2. 표준 빌트인 객체"></a>2. 표준 빌트인 객체</h2><ul>
<li>자바스크립트는 Object, String, Number, Boolean, Symbol, Date, Mathm RegExp, Array, Map/Set 등 40여개의 표준 빌트인 객체를 제공함</li>
<li>Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체이다.</li>
<li>생성자 함수 객체는 표준 빌트인 객체는 프로토타입 메소드와 정적 메소드를 제공하고 생성자함수 객체가 아닌 표준 빌트인 객체는 정적 메소드만을 제공한다.</li>
<li>생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩 된 객체다.</li>
<li>표준 빌트인 객체의 prototype 프로퍼티에 바인딩 된 객ㅊ체는 다양한 기능의 메소드를 제공한다.</li>
<li>또한 인스턴스 없이도 호출 가능한 정적 메소드도 제공한다.</li>
</ul>
<hr>
<h2 id="3-원시값과-래퍼객체"><a href="#3-원시값과-래퍼객체" class="headerlink" title="3. 원시값과 래퍼객체"></a>3. 원시값과 래퍼객체</h2><ul>
<li>원시값인 문자열, 숫자, 불리언 값의 경우, 마치 객체처럼 이들 원시값에 마침표 표기법으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해 줌</li>
<li>문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라고 함</li>
</ul>
<hr>
<h2 id="4-전역객체"><a href="#4-전역객체" class="headerlink" title="4. 전역객체"></a>4. 전역객체</h2><ul>
<li><p>전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체</p>
</li>
<li><p>어떤 객체에도 속하지 않은 최상위 객체</p>
</li>
<li><p>환경에 따라 브라우저에서는 window, node.js 에서는 global이 전역 객체를 가르킴</p>
</li>
<li><p>전역 객체는 표준 빌트인 객체와 환경에 따른 호스트객체, 그리고 var키워드로 선언한 전역 변수와 전역함수를 프로퍼티로 갖는다.</p>
</li>
<li><p>전역 객체의 특징</p>
<ul>
<li>전역 객체는 개발자가 의도적으로 생성할 수 없음.(전역 객체 생성자 함수도 없음)</li>
<li>전역 객체를 참조할 때 window를 생략할 수 있다.</li>
<li>전역 객체는 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.</li>
<li>자바스크립트 실행 환경에 따라 추가적인 프로퍼티와 메소드를 갖는다.</li>
<li>var 키워드로 선언한 전역변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.</li>
<li>let, const로 선언한 전역변수는 전역 객체의 프로퍼티가 아니다.</li>
<li>브라우저 환경의 모든 자바스크립트 코드는 하나의 전역객체 window를 공유한다. (파일이 분리되어 있어도 하나의 전역객체를 공유)</li>
</ul>
</li>
</ul>
<h3 id="4-1-빌트인-전역-프로퍼티"><a href="#4-1-빌트인-전역-프로퍼티" class="headerlink" title="4-1 빌트인 전역 프로퍼티"></a>4-1 빌트인 전역 프로퍼티</h3><ul>
<li>빌트인 전역 프로퍼티는 전역객체의 프로퍼티를 의미한다.</li>
<li>주로 애플리케이션 전역에서 사용하는 값을 의미한다.</li>
</ul>
<ol>
<li>Infinity : Infinity 프로퍼티는 양/음의 무한대를 나타내는 숫자값 Infinity를 갖는다.</li>
<li>NaN : 숫자가 아님을 나타내는 숫자값 NaN을 갖는다.</li>
<li>undefined : undefined 프로퍼티는 원시타입 undefined를 값으로 갖는다.</li>
</ol>
<h3 id="4-2-빌트인-전역함수"><a href="#4-2-빌트인-전역함수" class="headerlink" title="4-2 빌트인 전역함수"></a>4-2 빌트인 전역함수</h3><ul>
<li>빌트인 전력함수는 애플리케이션 전역에서 호출할 수 있는 전역객체의 메소드임</li>
</ul>
<ol>
<li>eval : 문자열 형태로 매개변수에 전달된 코드를 헌타임에 동적으로 평가하고 실행하여 결과값을 반환</li>
<li>isFinite : 매개변수에 전달된 값이 정상적인 유한수인지 검사하여 불리언 타입으로 반환.</li>
<li>isNaN : 매개변수에 전달된 값이 NaN 인지 검사하여 그 결과를 불리언 타입으로 반환</li>
<li>parseFloat : 매개변수에 전달된 문자열을 부동소수점 숫자로 변환하여 반환(공백이 있으면 첫번째 문자열만 반환</li>
<li>parselnt : 매개변수에 전달된 문자열을 정수형 숫자로 해석해서 반환(반환은 언제나 10진수임)</li>
<li>encodeURI : / decodeURI<ul>
<li>encodeURI는 매개변수로 전달 된 URI를 인코딩한다.</li>
<li>인코딩 이란 URI 문자들을 이스케이프 처리 하는것</li>
<li>이스케이프 처리는 문자를 아스키 문자 set으로 변환하는것</li>
<li>decodeURI는 인코딩 된 문자를 매개변수로 받아 인코딩 이전으로 디코딩 한다.</li>
</ul>
</li>
<li>encodeURIComponent / decodeURIComponent<ul>
<li>encodeURIComponent는 매개변수로 전달 된 URI 구성요소를 인코딩 한다.</li>
<li>쿼리 파라미터의 구분자도 인코딩 한다</li>
</ul>
</li>
</ol>
<h3 id="4-3-암묵적-전역"><a href="#4-3-암묵적-전역" class="headerlink" title="4-3 암묵적 전역"></a>4-3 암묵적 전역</h3><ul>
<li>선언되지 않은 식별자(변수)에 값을 할당하면 자바스크립트 엔진이 암묵적으로 전역 객체의 프로퍼티를 동적 생성하여 값을 할당함</li>
<li>전역 객체의 프로퍼티로 등록 되었을 뿐 변수는 아님</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/15/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-15%20%EC%97%84%EA%B2%A9%EB%AA%A8%EB%93%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-15%20%EC%97%84%EA%B2%A9%EB%AA%A8%EB%93%9C/" class="post-title-link" itemprop="url">엄격 모드</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-15 11:22:00 / Updated at: 12:56:43" itemprop="dateCreated datePublished" datetime="2020-03-15T11:22:00+09:00">2020-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="엄격모드"><a href="#엄격모드" class="headerlink" title="엄격모드"></a>엄격모드</h1><h2 id="1-strit-mode란"><a href="#1-strit-mode란" class="headerlink" title="1. strit mode란?"></a>1. strit mode란?</h2><ul>
<li>오타나 문접 지식의 미비 등으로 인한 실수를 예방하기 위하여 ES5 부터 적용됨</li>
<li>자바 스크립트 언어를 보다 엄격히 적용하여 기존에 무시되던 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 면시적인 에러를 발생시킴</li>
</ul>
<hr>
<h2 id="2-strit-mode의-적용"><a href="#2-strit-mode의-적용" class="headerlink" title="2. strit mode의 적용"></a>2. strit mode의 적용</h2><ul>
<li>strict mode를 적용하려면 전역의 선두 또는 함수 몸체의 선두에 <code>&#39;use strict&#39;;</code> 을 추가시킨다</li>
<li>전역의 선두에 추가하면 스크립트 전체에 strict mode가 적용된다.</li>
<li>함수 몸체 선두에 추가하면 해당 함수와 중첩된 함수에 stric mode가 적용된다</li>
<li>코드의 선두에 stric mode를 위치시키지 않으면 제대로 동작하지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="3-전역에-strict-mode를-적용하는것은-피하자"><a href="#3-전역에-strict-mode를-적용하는것은-피하자" class="headerlink" title="3. 전역에 strict mode를 적용하는것은 피하자"></a>3. 전역에 strict mode를 적용하는것은 피하자</h2><ul>
<li>외부 서드파티 라이브러리를 사용하는 경우, 라이브러리가 non-strict mode일 경우도 있기 때문에 strict mode를 적용하는것은 바람직하지 않다.</li>
</ul>
<hr>
<h2 id="4-함수단위로-strict-mode를-적용하는것도-피하자"><a href="#4-함수단위로-strict-mode를-적용하는것도-피하자" class="headerlink" title="4. 함수단위로 strict mode를 적용하는것도 피하자"></a>4. 함수단위로 strict mode를 적용하는것도 피하자</h2><ul>
<li>어떤함수는 적용하고 어떤함수는 적용하지 않는 것은 바람직하지 않음</li>
<li>함수에 일일히 strict mode를 적용하는 것은 번거로움</li>
<li>stric mode가 적용된 함수가 참조할 함수 외부의 컨텍스트에 strict mode를 적용하지 않는다면 문제가 발생할 가능성이 있음</li>
</ul>
<hr>
<h2 id="5-strict-mode가-발생시키는-에러"><a href="#5-strict-mode가-발생시키는-에러" class="headerlink" title="5. strict mode가 발생시키는 에러"></a>5. strict mode가 발생시키는 에러</h2><ol>
<li>암묵적 전역<ul>
<li>선언하지 않는 변수 참조 시 ReferenceError 발생</li>
</ul>
</li>
<li>변수, 함수, 매개변수의 삭제<ul>
<li>delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생한다.</li>
</ul>
</li>
<li>매개변수 이름의 중복<ul>
<li>중복된 함수 매개변수 이름을 사용하면 SyntaxError 가 발생한다.</li>
</ul>
</li>
<li>with 문의 사용<ul>
<li>whit 문을 사용하면 SyntaxError가 발생한다.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-Strict-mode-적용에-의한-변화"><a href="#6-Strict-mode-적용에-의한-변화" class="headerlink" title="6. Strict mode 적용에 의한 변화"></a>6. Strict mode 적용에 의한 변화</h2><ol>
<li><p>일반 함수의 this</p>
<ul>
<li>strict mode에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩 된다</li>
<li>생성자 함수가 아닌 일반 함수 내부에서는 this를 사용할 필요가 없기 때문이다.</li>
</ul>
</li>
<li><p>argument 객체</p>
<ul>
<li>strict mode 에서는 매개변수에 전달된 인수를 재할당하여 변경하여도 arguments 객체에 반영되지 않는다  </li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/14/%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%97%B0%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%97%B0%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/" class="post-title-link" itemprop="url">문제 풀이/알고리즘 연습 문제</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-14 21:17:32 / Updated at: 21:19:58" itemprop="dateCreated datePublished" datetime="2020-03-14T21:17:32+09:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/" itemprop="url" rel="index">
                    <span itemprop="name">문제풀이</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="알고리즘-연습문제-과제-제출"><a href="#알고리즘-연습문제-과제-제출" class="headerlink" title="알고리즘 연습문제 과제 제출"></a>알고리즘 연습문제 과제 제출</h1><ol>
<li>선형검색<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linearSearch</span>(<span class="params">array, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] === target) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">1</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">3</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">5</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">6</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">-1</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<ol start="2">
<li>이진 검색<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">array, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (array[mid] &lt; target) start = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; target) end = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] === target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">1</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">5</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">8</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">70</span>], <span class="number">15</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">7</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], <span class="number">-5</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<ol start="3">
<li>버블 정렬<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sort = array;</span><br><span class="line">  <span class="keyword">let</span> range = array.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; range; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sort[j] &gt; sort[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">const</span> now = sort[j];</span><br><span class="line">        <span class="keyword">const</span> next = sort[j + <span class="number">1</span>];</span><br><span class="line">        sort[j] = next;</span><br><span class="line">        sort[j + <span class="number">1</span>] = now;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    range -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sort;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>])); <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort([<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>])); <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort([<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>])); <span class="comment">// [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/11/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-12%20%EC%98%88%EC%8A%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/11/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-12%20%EC%98%88%EC%8A%B5/" class="post-title-link" itemprop="url">프로토타입</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-03-11 19:11:41" itemprop="dateCreated datePublished" datetime="2020-03-11T19:11:41+09:00">2020-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-12 20:26:11" itemprop="dateModified" datetime="2020-03-12T20:26:11+09:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h1><hr>
<h2 id="1-객체지향-프로그래밍"><a href="#1-객체지향-프로그래밍" class="headerlink" title="1. 객체지향 프로그래밍"></a>1. 객체지향 프로그래밍</h2><p>객체 지향 프로그래밍은 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적의 관점에서 벗어나 객체들의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임</p>
<ul>
<li>객체는 속성을 통해 여려개의 값을 하나의 단위로 구성한 복합적인 자료구조 임</li>
</ul>
<hr>
<h2 id="2-상속과-프로토타입"><a href="#2-상속과-프로토타입" class="headerlink" title="2. 상속과 프로토타입"></a>2. 상속과 프로토타입</h2><ul>
<li>상속은 어떤 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용 할 수 있는것을 말함.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea());</span><br><span class="line"><span class="built_in">console</span>.log(circle2.getArea());</span><br></pre></td></tr></table></figure></li>
<li>위 예제의 코드를 보면 getArea 메소드는 언제나 변하지 않지만 생성자 함수로 인스턴스가 만들어 질 때마다 중복 생성된다.(getArea가 this로 바인딩 되어 인스턴스의 프로퍼티로 들어감)</li>
<li>생성자 함수로 생성된 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 메모리를 불필요하게 낭비함</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea());</span><br><span class="line"><span class="built_in">console</span>.log(circle2.getArea());</span><br></pre></td></tr></table></figure>
<ul>
<li>위외 같이 Circle 생성자 함수의 프로토타입에 메소드를 동적 할당하여 인스턴스의 메소드 중복을 해결할 수 있다.</li>
<li>생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입의 모든 프로퍼티와 메소드를 상속 받는다.</li>
</ul>
<hr>
<h2 id="3-프로토타입-객체"><a href="#3-프로토타입-객체" class="headerlink" title="3. 프로토타입 객체"></a>3. 프로토타입 객체</h2><ul>
<li>프로토타입 객체란 객체간 상속을 구현하기 위해 사용된다.</li>
<li>프로토타입은 어떤 객체의 상위 역할을 하는 객체로써 다른 객체에 공유 프로퍼티를 제공한다.</li>
<li>프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티 처럼 자유롭게 사용할 수 있다.</li>
</ul>
<h3 id="3-1-proto-접근자-프로퍼티"><a href="#3-1-proto-접근자-프로퍼티" class="headerlink" title="3-1 proto 접근자 프로퍼티"></a>3-1 <strong>proto</strong> 접근자 프로퍼티</h3><ul>
<li>모든 객체는 <strong>proto</strong>접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 접근할 수 있음.</li>
<li><em><strong>proto</strong>는 접근자 프로퍼티이다</em></li>
<li>[[Prototype]] 내부슬롯은 프로퍼티가 아니기 때문에 직접 접근할 수 없으며 <strong>proto</strong>접근자 프로퍼티를 통해 간접적으로 접근할 수 있다.</li>
<li>Object.getOwnPropertyDescriptor 로 <strong>proto</strong>에 접근하면 접근자 프로퍼티의 어트피뷰트가 출력 됨</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> parent = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">// null : obj객체의 프로토타입은 null</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.y, obj.x); <span class="comment">// 2 undefined : obj 객체에는 현재 y프로퍼티만 존재</span></span><br><span class="line"></span><br><span class="line">obj.__proto__ = parent; <span class="comment">// obj객체의 __proto__ setter함수에 parent객체를 할당</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">// Object &#123;x: 1&#125; : obj 객체의 프로토타입에 obj객체가 할당 됨</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.y, obj.x); <span class="comment">// 2 1 : obj 객체가 parent객체의 x 프로퍼티를 상속받아 출력</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><em><strong>proto</strong>접근자 프로퍼티는 상속을 통해 사용된다.</em></p>
</li>
<li><p><strong>proto</strong>접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티 이다.</p>
</li>
<li><p>모든 객체는 상속을 통해 Object.prototype.<strong>proto</strong>접근자 프로퍼티를 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">'song'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">'__proto__'</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="comment">// person 객체는 __proto__프로퍼티를 소유하지 않는다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype, <span class="string">'__proto__'</span>))</span><br><span class="line"><span class="comment">// Object &#123;get: function get __proto__(), set: function set __proto__(), enumerable: false, configurable: true&#125;</span></span><br><span class="line"><span class="comment">// __proto__ 프포퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티 이다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.__proto__ === <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="comment">// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>프로토타입 체인</p>
<ul>
<li>모든 객체는 프로토타입 계층 구조인 프로토타입 체인에 묶여있다. </li>
<li>자바스크립트 엔진은 객체의 프로퍼티에 접근하려고 할때 해당 객체에 접근하려는 프로퍼티가 없다면 <strong>proto</strong>접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다.</li>
<li>프로토타입 체인의 최상위 객체는 Object.prototype 이며 이 객체의 프로퍼티와 메소드는 모든 객체에게 상속된다.</li>
</ul>
</li>
<li><p><strong>proto</strong>접근자 프로퍼티를 통해 프로토타입에 접근하는 이유</p>
<ul>
<li>[[Prototype]] 내부 슬롯의 값, 즉 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함임 </li>
</ul>
</li>
<li><p>프로토타입 체인은 단방향 링크드 리스트로 구현되어야 함.</p>
</li>
<li><p><em><strong>proto</strong>접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 비추천</em></p>
</li>
<li><p>프로토타입의 참조를 취득할 경우는 <strong>Object.getPrototypeOf</strong> 메소드를 사용하는 것이 좋다</p>
</li>
<li><p>프로토타입을 교체하는 경우는 <strong>Object.setProtypeOf</strong> 메소드를 사용하는 것이 좋다.</p>
</li>
</ul>
<h3 id="3-2-함수-객체의-prototype-프로퍼티"><a href="#3-2-함수-객체의-prototype-프로퍼티" class="headerlink" title="3-2 함수 객체의 prototype 프로퍼티"></a>3-2 함수 객체의 prototype 프로퍼티</h3><ul>
<li>함수 객체는 <strong>proto</strong>접근자 프로퍼티 이오에 protype 프로퍼티도 소유한다. </li>
<li>함수 객체의 protopype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가르킨다.</li>
<li>prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다.</li>
<li>모든 객체가 가지고 있는 <strong>proto</strong>접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 객체를 가리키자만 이들 프로퍼티를 사용하는 주체가 다르다<table>
<thead>
<tr>
<th>구분</th>
<th>소유</th>
<th>값</th>
<th>사용주체</th>
<th>사용목적</th>
</tr>
</thead>
<tbody><tr>
<td><strong>proto</strong>접근자 프로퍼티</td>
<td>모든객체</td>
<td>프로토타입의 참조</td>
<td>모든 객체</td>
<td>모든 객체가 상속을 위해 자신의 프로토타입에 접근하기 위해 사용</td>
</tr>
<tr>
<td>prototype 프로퍼티</td>
<td>함수객체</td>
<td>프로토타입의 참조</td>
<td>생성자 함수</td>
<td>생성자 함수가 자신이 생성할 인스턴스의 프포토타입을 할당하기 위해 사용</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="3-3-프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#3-3-프로토타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="3-3 프로토타입의 constructor 프로퍼티와 생성자 함수"></a>3-3 프로토타입의 constructor 프로퍼티와 생성자 함수</h3><ul>
<li>모든 프로토타입은 constructor 프로퍼티를 갖는다.</li>
<li>이 constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.</li>
<li>이 연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이루어진다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Song'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me.__proto__ === Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 인스턴스의 __proto__ 접근자 프로퍼티는 생성자 함수의 prototype을 가르킴</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 프로토타입에서 상속받은 constructor 프로퍼티는 생성자 함수를 가르킴</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// prototype의 constructor 프로퍼티는 생성자 함수를 가르킴</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.hasOwnProperty(<span class="string">'constructor'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 생성자 함수는 constructor 프로퍼티를 갖지 않음</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.hasOwnProperty(<span class="string">'constructor'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 프로토타입은 constructor 프로퍼티를 갖음</span></span><br><span class="line"><span class="built_in">console</span>.log(me.hasOwnProperty(<span class="string">'constructor'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 인스턴스는 constructor 프로퍼티를 직접 갖지 않고 프로토타입에서 상속받음</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입"><a href="#4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입" class="headerlink" title="4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입"></a>4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</h2><ul>
<li><p>생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결되는데 이때 생성자 함수는 인스턴스를 생성한 생성자 함수이다.</p>
</li>
<li><p>리터럴 표기법에 의한 객체 생성 방식과 같이 명시적으로 new연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하지 않는 객체 생성방식도 존재함</p>
</li>
<li><p>리터럴 표기법에 의해 생성된 객체도 물론 프로토타입이 존재함</p>
</li>
<li><p>하지만 리터럴 표기법에 의해 생성된 객체의 경우, 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 할 수 없음</p>
</li>
<li><p><strong>Object 생성자 함수와 객체 리터럴로 생성된 객체는 추상연산 Object.Create를 호출하여 빈 객체를 생성하는것은 동일하나 세부 내용은 다름으로 객체 리터럴에 의해 생성된 객체는 Object생성자 함수가 생성한 객체가 아니다</strong></p>
</li>
<li><p>리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요하다.</p>
</li>
<li><p>따라서 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 갖는다.</p>
</li>
<li><p>프로토타입은 생성자 함수와 더불어 생성되며 prototype, constructor 프로퍼티에 의해 연경되어 있다.</p>
</li>
<li><p>프로토타입과 생성자함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다.</p>
</li>
</ul>
<hr>
<h2 id="5-프로토타입의-생성-시점"><a href="#5-프로토타입의-생성-시점" class="headerlink" title="5. 프로토타입의 생성 시점"></a>5. 프로토타입의 생성 시점</h2><ul>
<li>생성자 함수는 사용자가 직접 정의한 사용자 정의 생성자 함수와 자바스크립트가 기본 제공하는 빌트인 생성자 함수로 구분할 수 있다.</li>
<li>프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.</li>
</ul>
<h3 id="5-1-사용자-정의-생성자-함구와-프로토타입-생성-시점"><a href="#5-1-사용자-정의-생성자-함구와-프로토타입-생성-시점" class="headerlink" title="5-1 사용자 정의 생성자 함구와 프로토타입 생성 시점"></a>5-1 사용자 정의 생성자 함구와 프로토타입 생성 시점</h3><ul>
<li>생성자 함수로서 호출할 수 있는 함수, 즉 constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더물어 생성된다.</li>
<li>빌트인 생성자 함수가 아닌 사용자 정의 생성자 함수는 자신이 평가되어 함수 객체로 생성되는 시점에 프로토타입도 더불어 생성되며 생성된 프로토타입은 언제나 Object.prototype이다.</li>
</ul>
<h3 id="5-2-빌트인-생성자-함수와-프로토타입-생성-시점"><a href="#5-2-빌트인-생성자-함수와-프로토타입-생성-시점" class="headerlink" title="5-2 빌트인 생성자 함수와 프로토타입 생성 시점"></a>5-2 빌트인 생성자 함수와 프로토타입 생성 시점</h3><ul>
<li>빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성 됨</li>
<li>모든 빌트인 생성자 함는 전역객체가 생성되는 시점에 생성된다.</li>
</ul>
<hr>
<h2 id="6-객체-생성-방식과-프로토타입의-결정"><a href="#6-객체-생성-방식과-프로토타입의-결정" class="headerlink" title="6. 객체 생성 방식과 프로토타입의 결정"></a>6. 객체 생성 방식과 프로토타입의 결정</h2><ul>
<li>객체는 아래와 같이 다양한 생성 방법이 있다<ul>
<li>객체 리터럴</li>
<li>Object 생성자 함수</li>
<li>생성자 함수</li>
<li>Object.create 메소드</li>
<li>클래스 (ES6)</li>
</ul>
</li>
<li>이와 같이 다양한 방식으로 생성된 모든 객체는 각각의 방식마다 세부적인 객체 생성 방식의 차이는 있으나 추상 연산 ObjectCreate에 의해 생성된다는 공통점을 갖는다.</li>
</ul>
<h3 id="6-1-객체-리터럴에-의해-생성된-객체의-프로토타입"><a href="#6-1-객체-리터럴에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-1 객체 리터럴에 의해 생성된 객체의 프로토타입"></a>6-1 객체 리터럴에 의해 생성된 객체의 프로토타입</h3><ul>
<li>자바스크립트 엔진은 객체 리터럴을 평가하여 생성할 때, 추상연산 ObjectCreate를 호출한다.</li>
<li>이때 추상연산 ObjectCreate에 전달되는 프로토타입은 Object.protype이다. </li>
<li>즉, 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype이다.</li>
</ul>
<h3 id="6-2-Object-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#6-2-Object-생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-2 Object 생성자 함수에 의해 생성된 객체의 프로토타입"></a>6-2 Object 생성자 함수에 의해 생성된 객체의 프로토타입</h3><ul>
<li>명시적으로 Object생성자 함수를 호출하여 객체를 생성하면 빈 객체가 생성된다.</li>
<li>Object 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 추상 연산 ObjectCreate를 호출한다.</li>
<li>Object 생성자 함수가 빈객체를 만든다는 것을 제외하면 객체 리터럴 방식과 동일한 구조이다.</li>
</ul>
<h3 id="6-3-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#6-3-생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-3 생성자 함수에 의해 생성된 객체의 프로토타입"></a>6-3 생성자 함수에 의해 생성된 객체의 프로토타입</h3><ul>
<li>new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 방식과 마찬가지로 추상 연산 ObjectCreate를 호출한다.</li>
<li>이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩 되어있는 객체이다.</li>
<li>즉 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 protype 프로퍼티에 바인딩 되어있는 객체이다.</li>
<li>생성자 함수를 통해 생성된 모든 객체는 프로토타입에 추가된 메소드를 프로퍼티를 상속받아 자신의 프로퍼티 처럼 사용할 수 있다.</li>
</ul>
<hr>
<h2 id="7-프로토타입-체인"><a href="#7-프로토타입-체인" class="headerlink" title="7. 프로토타입 체인"></a>7. 프로토타입 체인</h2><ul>
<li>자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <strong>proto</strong>접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색하고 이것을 프로토타입 체인이라고 한다.</li>
<li>프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘이다.</li>
<li>프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype이다. 따라서 모든 객체는 Object.prototype을 상속받는다.</li>
<li>프로토타입 에인의 종점인 Object.prototype에서도 프로퍼티를 검색할 수 없는 경우 undefined를 반환한다.</li>
</ul>
<p><strong>프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘, 스코프체인은 식별자 검색을 위한 메커니즘</strong></p>
<hr>
<h2 id="8-캡슐화"><a href="#8-캡슐화" class="headerlink" title="8. 캡슐화"></a>8. 캡슐화</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'song'</span>);</span><br><span class="line"></span><br><span class="line">me.sayHello() <span class="comment">// Hi my name is song</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>위 코드와 같이 즉시실행 함수를 사용하여 생성자 함수와 프로토타입을 확장하는 코드를 하나의 함수 내에 깔끔하게 모을 수 있다.</p>
</li>
<li><p>위 패턴을 사용하면 캡슐화를 쉽게 구현할 수 있다.</p>
</li>
<li><p>켭슐화는 정보의 일부를 외부에 노출되지 않도록 감추어 적절하지 못한 접근으로부터 정보를 보호하고 객체간의 상호 의존성, 즉 결합도를 낮추는 효과가 있다.</p>
</li>
<li><p>현재 위 코드의 name 프로퍼티는 현재 외부로 노출되어 있어서 자유롭게 변경할 수 있다.</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _name = <span class="string">''</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi my name is <span class="subst">$&#123;_name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'song'</span>);</span><br><span class="line"></span><br><span class="line">me.sayHello() <span class="comment">// Hi my name is song </span></span><br><span class="line"></span><br><span class="line">me._name = <span class="string">'Kim'</span>;</span><br><span class="line">me.sayHello() <span class="comment">// Hi my name is song </span></span><br><span class="line"><span class="comment">// _name은 지역변수 이기 때문에 외부에서 함부로 변경 할 수 없다</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-오버라이딩과-프로퍼티-쉐도잉"><a href="#9-오버라이딩과-프로퍼티-쉐도잉" class="headerlink" title="9. 오버라이딩과 프로퍼티 쉐도잉"></a>9. 오버라이딩과 프로퍼티 쉐도잉</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'song'</span>);</span><br><span class="line"></span><br><span class="line">me.sayHello(); <span class="comment">// Hi my name is song </span></span><br><span class="line"></span><br><span class="line">me.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hey my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">me.sayHello(); <span class="comment">// Hey my name is song </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> you = <span class="keyword">new</span> Person(<span class="string">'Kim'</span>);</span><br><span class="line">you.sayHello(); <span class="comment">// Hi my name is Kim</span></span><br></pre></td></tr></table></figure>
<ul>
<li>프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색하여 프로토타입 프로퍼티를 덮어쓰는것이 아닌 인스턴스 프로퍼티로 추가한다.</li>
<li>이때 인스턴스 메소드는 프로토타입 메소드를 오버라이딩 하였고 프로토타입 메소드는 가려진다(프로퍼티 쉐도잉)</li>
<li>프로토타입을 삭제하는 경우도 마찬가지로 인스턴스 프로퍼티가 삭제된다</li>
</ul>
<hr>
<h2 id="10-프로토타입-교체"><a href="#10-프로토타입-교체" class="headerlink" title="10. 프로토타입 교체"></a>10. 프로토타입 교체</h2><ul>
<li>프로토타입은 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있당는것을 의미한다.</li>
<li>프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있다.</li>
</ul>
<h3 id="10-1-생성자-함수에-의한-프로토타입의-교체"><a href="#10-1-생성자-함수에-의한-프로토타입의-교체" class="headerlink" title="10-1 생성자 함수에 의한 프로토타입의 교체"></a>10-1 생성자 함수에 의한 프로토타입의 교체</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생성자 함수를 통한 prototype을 객체리터럴로 교체</span></span><br><span class="line">  Person.prototype = &#123; </span><br><span class="line">    <span class="keyword">constructor</span>: Person, // prototype 교체 시 <span class="keyword">constructor</span> 연결이 해제됨으로 생성자 함수간 링크를 설정해 준다</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hi my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'song'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위 코드의 객체 리터럴은 constructor 프로퍼티가 없음으로 생성자 함수와 프로토타입간의 링크가 파괴됨</li>
<li>교체한 객체 리터럴 내부에 constructor 프로퍼티를 추가하여 프로토타입의 constructor 프로퍼티를 되살림</li>
</ul>
<h3 id="10-3-인스턴스에-의한-프로토타입의-교체"><a href="#10-3-인스턴스에-의한-프로토타입의-교체" class="headerlink" title="10-3 인스턴스에 의한 프로토타입의 교체"></a>10-3 인스턴스에 의한 프로토타입의 교체</h3><ul>
<li>프로토타입은 생성자 함수의 prototype 프로퍼티 뿐만 아니라 인스턴스의 <strong>proto</strong>접근자 프로퍼티로 접근할 수 있다.</li>
<li>생성자 함수의 prototype 프로퍼티에 다른 임의의 객체를 바인딩 하는것은 미래에 생성할 인스턴스의 프로토타입을 교체하는 것이다.</li>
<li><strong>proto</strong>접근자 프로퍼티를 통해 프로토타입을 교체하는것은 이미 생성된 프로토타입을 교체하는 것이다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Song'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person, // prototype 교체 시 <span class="keyword">constructor</span> 연결이 해제됨으로 생성자 함수간 링크를 설정해 준다</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = parent;</span><br><span class="line"><span class="comment">// 인스턴스에 의한 프로토타입 교체 시 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가르키지 않음으로 명시적으로 지정</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(me, parent);</span><br><span class="line"></span><br><span class="line">me.sayHello();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === <span class="built_in">Object</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype === <span class="built_in">Object</span>.getPrototypeOf(me)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="11-instanseof-연산자"><a href="#11-instanseof-연산자" class="headerlink" title="11. instanseof 연산자"></a>11. instanseof 연산자</h2><ul>
<li>instanceof 연산자는 이항 연산자로써 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 피연산자로 받는다</li>
<li>우변의 피연산자가 함수가 아닌 경우 TypeError가 발생한다.<br><code>객체 instanceof 생성자함수</code></li>
<li>좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스라면 true로 평가되고 그렇지 않은 경우에는 false로 평가된다.</li>
<li>instanseof 연산자는 상속관계를 고려한다.</li>
</ul>
<hr>
<h2 id="12-직접상속"><a href="#12-직접상속" class="headerlink" title="12. 직접상속"></a>12. 직접상속</h2><h3 id="12-1-Object-create에-의한-직접-상속"><a href="#12-1-Object-create에-의한-직접-상속" class="headerlink" title="12-1 Object.create에 의한 직접 상속"></a>12-1 Object.create에 의한 직접 상속</h3><ul>
<li><p>Object.create 메소드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.</p>
</li>
<li><p>Object.create 메소드도 다른 객체 생성 방식과 마찬가지로 추상연산 ObjectCreate를 호출한다.</p>
</li>
<li><p>Object.create 메소드의 첫번째 매개변수에는 생성할 객체의 프로토타입으로 지정할 객체를 전달한다.</p>
</li>
<li><p>두번째 매개변수에는 생성할 객체의 프로퍼티를 갖는 객체를 전달한다.</p>
</li>
<li><p>이 메소드의 형식은 Object.define.Propertyies 메소드의 두번째 인수와 동일하다.</p>
</li>
<li><p>두번째 인수는 옵션이므로 생략 가능하다.</p>
</li>
<li><p>Object.create 메소드의 장점</p>
<ul>
<li>new 연산자가 없이도 객체를 생성할 수 있다</li>
<li>프로토타입을 지정하면서 객체를 생성할 수 있다. 이때 생성자 함수와 프로토타입 간의 링크가 파괴되지 않는다.</li>
<li>객체 리터럴에 의해 생성된 객체도 특정 객체를 상속받을 수 있다.</li>
</ul>
</li>
<li><p>Object.create 메소드의 단점</p>
<ul>
<li>프로토타입 종점에 위치하는 객체를 생성할수 있음</li>
</ul>
</li>
</ul>
<h3 id="12-2-객체-리터럴-내부에서-proto-에-의한-직접-상속"><a href="#12-2-객체-리터럴-내부에서-proto-에-의한-직접-상속" class="headerlink" title="12-2 객체 리터럴 내부에서 __proto_에 의한 직접 상속"></a>12-2 객체 리터럴 내부에서 __proto_에 의한 직접 상속</h3><ul>
<li>Object.create 메소드 사용의 경우 두번째 인자로 프로퍼티를 정의하는것이 번거롭다</li>
<li>ES6 에서는 객체 리터럴 내부에서 __proto_접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myProto = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  y: <span class="number">20</span>,</span><br><span class="line">  __proto__: myProto</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.x, obj.y); <span class="comment">// 10 20</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj) === myProto); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<ol start="13">
<li>정적 프로퍼티 / 메소드</li>
</ol>
<ul>
<li>정적 프로퍼티/메소드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드를 말한다.</li>
<li>생성자 함수가 생성한 인스턴스는 자신의 프로토타입 체인에 속한 프로퍼티/메소드에 접근할 수 있다</li>
<li>정적 프로퍼티/메소드는 인스턴스의 프로토타입 체인에 속한 객체의 프로퍼티/메소드가 아니므로 인스턴스로 접근할 수 없다.</li>
</ul>
<hr>
<h2 id="14-프로퍼티-존재-확인"><a href="#14-프로퍼티-존재-확인" class="headerlink" title="14. 프로퍼티 존재 확인"></a>14. 프로퍼티 존재 확인</h2><ul>
<li>in 연산자는 객체 내에 프로퍼티가 존재하는지 여부를 확인한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Song'</span>,</span><br><span class="line">  address: <span class="string">'Paju'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'address'</span> <span class="keyword">in</span> person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'age'</span> <span class="keyword">in</span> person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>in 연산자는 확인 대상 객체의 프로퍼티 뿐만 아니라 확인 대상 객체가 상속받은 모든 프로토타입 프로퍼티를 확인하므로 주의해야한다.</li>
</ul>
<hr>
<h2 id="15-프로퍼티-열거"><a href="#15-프로퍼티-열거" class="headerlink" title="15. 프로퍼티 열거"></a>15. 프로퍼티 열거</h2><h3 id="15-1-for…in문"><a href="#15-1-for…in문" class="headerlink" title="15.1 for…in문"></a>15.1 for…in문</h3><ul>
<li>객체의 모든 프로퍼티를 순회하며 열거하려면 for…in문을 사용한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Song'</span>,</span><br><span class="line">  address: <span class="string">'Paju'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">': '</span> + person[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-2-Object-keys-values-entries"><a href="#15-2-Object-keys-values-entries" class="headerlink" title="15.2 Object.keys/values/entries"></a>15.2 Object.keys/values/entries</h3><ul>
<li><p>for…in문은 객체 자신의 프로퍼티 뿐만 아니라 상속받은 프로퍼티도 열거하기 때문에 Object.prototype.hasOwnProperty 메소드를 사용하여 객체 자신의 프로퍼티 인지 확인하는 추가 처리가 필요하다</p>
</li>
<li><p>객체 자신의 프로퍼티 만을 열거하기 위해서는 for…in문을 사용하는것 보다 Object.key/values/entries 메소드를 사용하는것을 권장한다.</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Song'</span>,</span><br><span class="line">  address: <span class="string">'Paju'</span>,</span><br><span class="line">  __proto__: &#123; <span class="attr">age</span>: <span class="number">32</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!person.hasOwnProperty(key)) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">': '</span> + person[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person)); <span class="comment">// ["name", "address"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(person)); <span class="comment">// ["Song", "Paju"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(person)); <span class="comment">// [Array[2], Array[2]]</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/10/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-10%20%EC%98%88%EC%8A%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/10/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-10%20%EC%98%88%EC%8A%B5/" class="post-title-link" itemprop="url">JS 수업 예습/2020-03-10 예습</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-10 17:34:45 / Updated at: 17:38:26" itemprop="dateCreated datePublished" datetime="2020-03-10T17:34:45+09:00">2020-03-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="생성자-함수에-의한-객체-생성"><a href="#생성자-함수에-의한-객체-생성" class="headerlink" title="생성자 함수에 의한 객체 생성"></a>생성자 함수에 의한 객체 생성</h1><h2 id="1-Object-생성자-함수"><a href="#1-Object-생성자-함수" class="headerlink" title="1. Object 생성자 함수"></a>1. Object 생성자 함수</h2><ul>
<li>new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다.</li>
<li>빈객체를 생성한 이후 프로퍼티 또는 메소드를 추가하여 객체를 완성할 수 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//빈객채의 생성</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> ObjectW();</span><br><span class="line"></span><br><span class="line"><span class="comment">//프로퍼티 추가</span></span><br><span class="line">person.name = <span class="string">'Song'</span>;</span><br><span class="line">person.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi! My Name is '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// Object &#123;name: "Song", sayHello: function ()&#125;</span></span><br><span class="line">person.sayHello(); <span class="comment">// Hi! My Name is Song</span></span><br></pre></td></tr></table></figure>
<ul>
<li>생성자 함수란 new 연산자와 함께 호출하여 격체(인스턴스)를 생성하는 함수를 말한다.</li>
<li>생성자 함수에 의해 생성된 객채를 인스턴스라 한다.</li>
</ul>
<h2 id="2-생성자-함수"><a href="#2-생성자-함수" class="headerlink" title="2. 생성자 함수"></a>2. 생성자 함수</h2><h3 id="2-1-객체-리터럴에-의한-객체-생성-방식의-문제점"><a href="#2-1-객체-리터럴에-의한-객체-생성-방식의-문제점" class="headerlink" title="2-1 객체 리터럴에 의한 객체 생성 방식의 문제점"></a>2-1 객체 리터럴에 의한 객체 생성 방식의 문제점</h3><ul>
<li>객체 리터럴에 의한 객체 생성 방식은 간편하지만 단 하나의 객채만을 생성하기 때문에 동일한 프로퍼티를 갖는 객채를 여러개 생성하는 경우 비효율적임</li>
</ul>
<h3 id="2-2-생성자-함수에-의한-객체-생성-방식의-장점"><a href="#2-2-생성자-함수에-의한-객체-생성-방식의-장점" class="headerlink" title="2-2 생성자 함수에 의한 객체 생성 방식의 장점"></a>2-2 생성자 함수에 의한 객체 생성 방식의 장점</h3><ul>
<li>생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스) 처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러개를 간편하게 생성할 수 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//생성자함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>); <span class="comment">// 반지름이 5인 Circle객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">10</span>); <span class="comment">//  반지름이 10인 Circle 객체를 생성</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getDiameter()); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getDiameter()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p><strong>this : this 는 객체 자신의 프로퍼티나 메소드를 함조하기 위한 자기 함조변수이다. this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다</strong></p>
<table>
<thead>
<tr>
<th>함수 호출 방식</th>
<th>this가 가리키는 값</th>
</tr>
</thead>
<tbody><tr>
<td>일반 함수로서 호출</td>
<td>전역 객체</td>
</tr>
<tr>
<td>메소드로서 호출</td>
<td>메소드를 호출한 객체</td>
</tr>
<tr>
<td>생성자 함수로서 호출</td>
<td>생성자 함수가 생성할 인스턴스</td>
</tr>
</tbody></table>
<ul>
<li>생성자 함수는 말 그대로 객체(인스턴스)를 생성하는 함수이다</li>
<li>자바와 같은 클래스 기반 객체지향 언어의 생성자 와는 다르게 그 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 <strong>new연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.</strong></li>
</ul>
<h3 id="2-3-내부-메소드-Call-과-Construct"><a href="#2-3-내부-메소드-Call-과-Construct" class="headerlink" title="2-3 내부 메소드 [[Call]] 과 [[Construct]]"></a>2-3 내부 메소드 [[Call]] 과 [[Construct]]</h3><ul>
<li>함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로써 호출할 수 있는것을 물론 생성자 ㅎ마수로서 호출할 수 있다.</li>
<li>생성자 함수로써 호출된다는 것은 new연산자와 함께 호출하여 객체를 생성하는것을 의미한다.</li>
<li>함수는 객체이므로 일반 객체와 동일하게 동작할 수 있다.</li>
<li>함수 객체는 일반 객체의 내부 슬롯과 내부 메소드를 모두 가지고 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수는 객체이다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 객체이므로 프로퍼틸를 소유할 수 있다</span></span><br><span class="line">foo.prop = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 객체이므로 메소드를 소유할 수 있다.</span></span><br><span class="line">foo.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.prop);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.method();</span><br></pre></td></tr></table></figure>
<ul>
<li>내부 메소드 [[Call]]을 갖는 함수 객체를 callable이라 하며, 내부 메소드인 [[Construct]]를 갖는 함수 객체를 constructor, [[Construct]]를 갖지 않은 함수 객체를 non-constructor라고 부른다</li>
<li>callable은 호출할 수 있는 객체, 즉 함수를 말하며, constructor는 생성자 함수로서 호출할 수 있는 객체를 의미한다.</li>
<li>생성자 함수로서 호출될 수 있다는 것은 new연산자와 함께 호출되는 것을 의미한다.</li>
<li>함수가 일밙적인 함수로서 호출되면 함수 객체의 내부 메소드 [[Call]]가 먼저 호출되고 new연산자와 함께 생성자 함수로서 호출되면 내부 메소드 [[Construct]]가 호출된다</li>
<li>모든 함수 객체는 내부 메소드 [[Call]]을 갖고 있으므로 호출할 수 있다.</li>
<li>하지만 모든 함수 객체가 [[Construct]]를 갖지는 않는다.</li>
</ul>
<h3 id="2-4-constructor와-non-constructor의-구분"><a href="#2-4-constructor와-non-constructor의-구분" class="headerlink" title="2-4 constructor와 non-constructor의 구분"></a>2-4 constructor와 non-constructor의 구분</h3><ul>
<li>자바 스크립트 엔진은 함수를 생성 할 때 FunctionCrreate라는 추정 연산을 사용한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일반 함수 정의 : kind = 'Normal'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//  프로퍼티 x에 할당된 것은 일반 함수 정의이다. 메소드 정의로 인정하지 않는다.</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;</span><br><span class="line">  x: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반함수로 정의된 함수만이 constructor이다</span></span><br><span class="line"><span class="keyword">new</span> foo(); <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">new</span> bar(); <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">new</span> baz.x(); <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 화살표 함수 정의 : kind = 'Arrow'</span></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> arrow(); <span class="comment">// typeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드 정의 : kind = 'Method'</span></span><br><span class="line"><span class="comment">// ES6의 메소드 축약 표현만을 메소드 정의로 인정한다.</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> obj.x(); <span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-5-생성자-함수의-인스턴스-생성과정"><a href="#2-5-생성자-함수의-인스턴스-생성과정" class="headerlink" title="2-5 생성자 함수의 인스턴스 생성과정"></a>2-5 생성자 함수의 인스턴스 생성과정</h3><ul>
<li>생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿으로서 동작하여 인스턴스를 생성하는것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것이다</li>
<li>생성자 함수가 인스턴스를 생성하는것은 필수이고, 생성된 인스턴스를 초기화 하는것은 옵션이다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//생성자함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 인스턴스 초기화</span></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>); <span class="comment">// 반지름이 5인 Circle객체를 생성</span></span><br></pre></td></tr></table></figure>
<ul>
<li>함수 내부의 코드를 살펴보면 this에 프로퍼티를 추가하고 필요에 따라 인수로 전달된 초기값을 프로퍼티 값으로 할당한다.</li>
<li>자바 스크입트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다. new 연산자와 함께 생성자 함수가 호출되면 자바 스크립트 엔진은 아래와 같은 과정을 거쳐 인스턴스를 생성하고 초기화 한 후, 인스턴스를 반환한다.<ol>
<li>인스턴스 생성과 this 바인딩<ul>
<li>암묵적으로 빈 객체가 생선된다. 이 빈객체가 바로 생성자 함수가 생선한 인스턴스이다. 그리고 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩 된다.</li>
</ul>
</li>
<li>인스턴스 초기화<ul>
<li>생성자 함수에 기술되어 있는 코드가 실행되어 this에 바인딩 되어있는 인스턴스를 초기화 한다. 즉 this에 바인딩 되어 있는 인스턴스에 프로퍼티나 메소드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화 하거나 고정값을 할당한다.</li>
</ul>
</li>
<li>인스턴스 반환<ul>
<li>생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩 된 this가 암묵적으로 반환된다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="2-6-new연산자"><a href="#2-6-new연산자" class="headerlink" title="2-6 new연산자"></a>2-6 new연산자</h4><ul>
<li>new 연산자와 함께 생ㅅ어자 람수에 의해 생선된 객체(인스턴스)는 프로토 타입에의해 생성자 함수와 연결된다. 이를 이용해 new연산자와 함께 호출 되었는지를 확인할 수 있다.</li>
</ul>
<h1 id="함수와-일급객체"><a href="#함수와-일급객체" class="headerlink" title="함수와 일급객체"></a>함수와 일급객체</h1><h2 id="1-일급객체"><a href="#1-일급객체" class="headerlink" title="1. 일급객체"></a>1. 일급객체</h2><ol>
<li>무명의 리터럴로 생성할 수 있다. 즉 런타임에 생성이 가능하다.</li>
<li>변수나 자료구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개변수에게 전달 할 수 있다.</li>
<li>함수의 결과값으로 반환 할 수 있다.</li>
</ol>
<p><strong>함수형 프로그래밍</strong></p>
<ul>
<li><p>함수형 프로그래밍은 순수함수와 보조함수의 조합을 통해 외부상태를 변경하는 부수효과를 최소화하여 불변성을 지향하는 프로그래밍</p>
</li>
<li><p>함수는 객체이지만 일반 객체와는 차이가 있다. 일반 객체는 호출할 수 없지만 함수 객체는 호출할 수 있다. 그리고 함수 객체에는 일반 객체에 없는 함수 고유의 프로퍼티를 소유한다.</p>
</li>
</ul>
<h2 id="2-함수-객체의-프로퍼티"><a href="#2-함수-객체의-프로퍼티" class="headerlink" title="2. 함수 객체의 프로퍼티"></a>2. 함수 객체의 프로퍼티</h2><ol>
<li>argument 프로퍼티<ul>
<li>함수 호출 시 전달 된 인수들의 정보를 담고 있는 유사배열 객체</li>
<li>함수 내부에서 지역변수처럼 사용</li>
<li>함수 외부에서 사용할 수 없음</li>
<li>매개변수 개수를 확정할 수 없는 가변인자 함수를 구현할 때 유용하게 사용됨</li>
</ul>
</li>
<li>caller 프로퍼티</li>
<li>length 프로퍼티 함수 객체의 length 프로퍼티는 함수 정의 시 선언한 매개변수의 개수를 가리킴</li>
<li>name 프포퍼티 : 함수 객체의 name 프로퍼티는 함수 이름을 나타낸다.</li>
<li><em>_Proto</em> 접근자 프로퍼티</li>
<li>prototype 프로퍼티</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/02/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/03-02%20%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%20%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/03-02%20%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%20%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/" class="post-title-link" itemprop="url">JS 수업 예습/03-02 프로퍼티 어트리뷰트</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-03-02 16:26:02" itemprop="dateCreated datePublished" datetime="2020-03-02T16:26:02+09:00">2020-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-03 10:50:03" itemprop="dateModified" datetime="2020-03-03T10:50:03+09:00">2020-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="프로퍼티-어트리뷰트"><a href="#프로퍼티-어트리뷰트" class="headerlink" title="프로퍼티 어트리뷰트"></a>프로퍼티 어트리뷰트</h1><h2 id="1-내부-슬롯과-내부-메소드"><a href="#1-내부-슬롯과-내부-메소드" class="headerlink" title="1. 내부 슬롯과 내부 메소드"></a>1. 내부 슬롯과 내부 메소드</h2><ul>
<li>내부 슬롯(Internal slot)과 내부 메소드(Internal method)는 자바 스크립트 자바 스크립트 엔진의 알고리즘을 설명하지 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티(Pseudo)와 의사 메소드 이다 ECMAScript 사양에 등장하는 이중 대괄호 ([[…]])로 감싼 이름들이 내부 슬롯과 메소드이다.</li>
<li>내부 슬롯과 내부 메소드는 ECMAScript 사양에 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작하지만 외부로 공개된 객체의 프로퍼티는 아니다.</li>
<li>즉 내부 슬롯과 내부 메소드는 자바스크립트 엔진의 내부 로직이므로 원칙적으로 자바스크립트는 내부 슬록과 내부 메소드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않는다.</li>
<li>단, 일부 내부 슬롯과 내부 메소드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.</li>
</ul>
<h2 id="2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h2><ul>
<li>자바스크립트 엔진은 프로퍼티를 생성할 때, 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.</li>
<li>프로퍼티의 상태란 프로퍼티의 값(value), 값의 갱신 가능(writable) 여부, 열거 가능(enumerable) 여부, 재정의 가능(configurable) 여부를 말한다.</li>
<li>프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값(meta-property)인 내부슬롯 ([[Value]], [[Writable]], [[Enumerable]], [[configurable]]) 이다.</li>
<li>따라서 프로퍼티 어트리뷰트에 직접 접근 할 수 없지만, Object.getOwnPropertyDescriptor 메소드를 사용하여 간접적으로 확인할 수는 있다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "song", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Object.getOwnPropertyDescriptor 메소드를 호출할 때, 첫번째 매개변수에는 객체의 참조를 전달하고 두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다.</li>
<li>이때 Object.getOwnPropertyDescriptor 메소드는 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.</li>
<li>만약 존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 프로퍼티 디스크립터를 요구하면 undefined가 반환된다.</li>
</ul>
<ul>
<li>Object.getOwnPropertyDescriptor 메소드는 하나의 프로퍼티에 대해 디스크립터 객체를 반환한다</li>
<li>Object.getOwnPropertyDescriptors 메소드는 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크럽터 객체를 반환한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//프로퍼티 동적 생성</span></span><br><span class="line">person.age = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크럽터 객체들을 반환한다</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person));</span><br><span class="line"><span class="comment">// name: &#123;value: "song", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">// age: &#123;value: 32, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-데이터-프로퍼티와-접근자-프로퍼티"><a href="#3-데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="3. 데이터 프로퍼티와 접근자 프로퍼티"></a>3. 데이터 프로퍼티와 접근자 프로퍼티</h2><ul>
<li>프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 구분한다.<ul>
<li>데이터 프로퍼티(Data Property) : 키와 값으로 구성된 일반적 프로퍼티다.</li>
<li>접근자 프로퍼티(Assessor Property) : 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 잡근자 함수(Accessor)로 구성된 프로퍼티 이다.</li>
</ul>
</li>
</ul>
<h3 id="3-1-데이터-프로퍼티"><a href="#3-1-데이터-프로퍼티" class="headerlink" title="3-1 데이터 프로퍼티"></a>3-1 데이터 프로퍼티</h3><ul>
<li>데이터 프로퍼티는 아래와 같은 프로퍼티 어트리뷰트를 갖는다.</li>
<li>이 프로퍼티 어트리뷰트는 자바스크립트 엔진이 프로퍼티를 생성할 때, 기본값으로 자동 정의된다.<table>
<thead>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th>프로퍼티 디스크럽터 객체의 프로퍼티</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>[[Value]]</td>
<td>value</td>
<td>- 프로퍼티 키로 프로퍼티 값에 접근하면 반환되는 값이다. <br>- 프로퍼티 키로 프로퍼티 값을 저장하면 [[value]]에 값을 저장한다. 이때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다.</td>
</tr>
<tr>
<td>[[Writable]]</td>
<td>writable</td>
<td>- 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다. <br>-[[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기전용 프로퍼티가 된다.</td>
</tr>
<tr>
<td>[[Enumerable]]</td>
<td>enumerable</td>
<td>- 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다. <br>- [[Enumerable]]의 값이 false인 경우, 해당 프로퍼티는 for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td>configurable</td>
<td>- 프로퍼티 재정의 가능 여부를 나타내며 불리언 값을 갖는다. <br> [[Configurable]]의 값이 false인 경우, 해당 프로퍼티를 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 혀용된다.</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="3-2-접근자-프로퍼티"><a href="#3-2-접근자-프로퍼티" class="headerlink" title="3-2 접근자 프로퍼티"></a>3-2 접근자 프로퍼티</h3><ul>
<li>접근자 프로퍼티(Accessor property)는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(Accessor function)로 구성된 프로퍼티 이다.</li>
<li>접근자 프로퍼티는 아래와 같은 프로퍼티 어트리뷰트를 갖는다.<table>
<thead>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th>프로퍼티 디스크럽터 객체의 프로퍼티</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>[[Get]]</td>
<td>get</td>
<td>접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수이다. 즉 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[get]]의 값, 즉 getter함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다</td>
</tr>
<tr>
<td>[[Set]]</td>
<td>set</td>
<td>접근자 프로퍼티를 통해 프로퍼티 값을 저장할 때 호출되는 접근자 함수이다. 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 Setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</td>
</tr>
<tr>
<td>[[Enumerable]]</td>
<td>enumerable</td>
<td>데이터 타입의 [[Enumerable]]와 같다.</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td>configurable</td>
<td>데이터 타입의 [[Configurable]]와 같다.</td>
</tr>
</tbody></table>
</li>
<li>접근자 함수는 getter/setter함수라고도 부른다. 접근자 프로퍼티는 grtter와 setter 함수를 모두 정의할 수도 있고 하나만 정의할 수도 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">'Buyong'</span>,</span><br><span class="line">  lastName: <span class="string">'Song'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fullName은 접근자 함수로 구성된 접근자 프로퍼티이다.</span></span><br><span class="line">  <span class="comment">// getter 함수</span></span><br><span class="line">  <span class="keyword">get</span> fullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter 함수</span></span><br><span class="line">  <span class="keyword">set</span> fullName(name) &#123;</span><br><span class="line">    [<span class="keyword">this</span>.firstName, <span class="keyword">this</span>.lastName] = name.split(<span class="string">' '</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 접근하면 getter함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(person.fullName); <span class="comment">// Buyong Song</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 프로퍼티를 통한 값의 참조</span></span><br><span class="line"><span class="built_in">console</span>.log(person.firstName, person.lastName); <span class="comment">// Buyong Song</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 값의 저장</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.</span></span><br><span class="line">person.fullName = <span class="string">'angry boo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; firstName: 'angry', lastName: 'boo', fullName: [Getter/Setter] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 프로퍼티 값의 참조</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 접근하면 getter함수가 출력된다</span></span><br><span class="line"><span class="built_in">console</span>.log(person.fullName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// firstName은 데이터 프로퍼티이다.</span></span><br><span class="line"><span class="comment">// 데이터 프로퍼티는 value, writable, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.</span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'firstName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  value: 'angry',</span></span><br><span class="line"><span class="comment">  writable: true,</span></span><br><span class="line"><span class="comment">  enumerable: true,</span></span><br><span class="line"><span class="comment">  configurable: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fullName은 접근자 프로퍼티 이다.</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어프리뷰트를 갖는다.</span></span><br><span class="line">descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'fullName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  get: [Function: get fullName],</span></span><br><span class="line"><span class="comment">  set: [Function: set fullName],</span></span><br><span class="line"><span class="comment">  enumerable: true,</span></span><br><span class="line"><span class="comment">  configurable: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>접근자 프로퍼티 fullName으로 프로퍼티 값에 접근하면 내부적으로 [[Get]] 내부 메소드가 호출되어 아래와 같이 작동한다<ol>
<li>프로퍼티 키가 유효한지 확인한다. 프로퍼티 키는 몬자열 또는 심볼이어야 한다. 프로퍼티 키 “fullName”은 문자열 이므로 프로퍼티 키다.</li>
<li>프로토타입 체인에서 프로퍼티를 검색한다. person객체에 fullName 프로퍼티가 존재한다.</li>
<li>검색된 fullName 프로퍼티가 테이터 프로퍼티인지 접근자 프로퍼티인지 확인한다. fullName 프로퍼티는 접근자 프로퍼티다.</li>
<li>접근자 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 함수를 호출하여 그 결과를 반환한다. 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값은 Object.getOwnPropertyDesciptor 메소드가 반환하는 프로퍼티 디스크립터 객체의 get 프로퍼티 값과 같다.</li>
</ol>
</li>
</ul>
<h2 id="4-프로퍼티-정의"><a href="#4-프로퍼티-정의" class="headerlink" title="4. 프로퍼티 정의"></a>4. 프로퍼티 정의</h2><ul>
<li>프로퍼티 정의 : 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적의로 정의하거나, 기존 어트리뷰트를 재정의 하는것</li>
<li>Object.defineProperty 메소드를 사용하면 프로퍼티 어트리뷰트를 정의할 수 있음</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//데이터 프로퍼티 정의</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'firstName'</span>, &#123;</span><br><span class="line">  value: <span class="string">'Buyong'</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'lastName'</span>, &#123;</span><br><span class="line">  value: <span class="string">'Song'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'firstName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="comment">// Object &#123;value: "Buyong", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 디스크립터 객체의 프로퍼티를 누락 시키면 undefined, false가 기본값이다.</span></span><br><span class="line">descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'lastName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="comment">//Object &#123;value: "Song", writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 정의</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'fullName'</span>, &#123;</span><br><span class="line">  <span class="comment">//getter 함수</span></span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter 함수</span></span><br><span class="line">  <span class="keyword">set</span>(name) &#123;</span><br><span class="line">    [<span class="keyword">this</span>.firstName, <span class="keyword">this</span>.lastName] = name.split(<span class="string">' '</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="5-객체-변경-금지"><a href="#5-객체-변경-금지" class="headerlink" title="5. 객체 변경 금지"></a>5. 객체 변경 금지</h2><ul>
<li>자바스크립트는 객체의 변경을 방지할 수 있는 다양한 메소드를 제공한다. 객체 변경 방지 메소드 들은 객체의 변경을 금지하는 강도가 다르다.<table>
<thead>
<tr>
<th>구분</th>
<th></th>
<th align="center">메소드</th>
<th align="center">프로퍼티 추가</th>
<th align="center">프로퍼티 삭제</th>
<th align="center">프로퍼티 값 읽기</th>
<th align="center">프로퍼티 어트리뷰트 재정의</th>
</tr>
</thead>
<tbody><tr>
<td>객체 확장 금지</td>
<td>Object.preventExtensions</td>
<td align="center">X</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">O</td>
</tr>
<tr>
<td>객체 밀봉</td>
<td>Object.seal</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">X</td>
</tr>
<tr>
<td>객체 동결</td>
<td>Object.freeze</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">O</td>
<td align="center">X</td>
<td align="center">X</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="5-1-객체-확장-금지"><a href="#5-1-객체-확장-금지" class="headerlink" title="5-1 객체 확장 금지"></a>5-1 객체 확장 금지</h3><ul>
<li>Object.preventExtensions 메소드는 객체의 확장을 금지한다.</li>
<li>객체의 확장 금지란 프로퍼티 추가 금지를 의미한다.</li>
<li><strong>확장이 금지괸 객체는 프로퍼티 추가가 금지됨다</strong></li>
</ul>
<h3 id="5-2-객체-밀봉"><a href="#5-2-객체-밀봉" class="headerlink" title="5-2 객체 밀봉"></a>5-2 객체 밀봉</h3><ul>
<li>객체 밀봉이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지를 의미한다.</li>
<li><strong>밀봉된 객체는 읽기와 쓰기만 가능하게 된다</strong></li>
</ul>
<h3 id="5-3-객체-동결"><a href="#5-3-객체-동결" class="headerlink" title="5-3 객체 동결"></a>5-3 객체 동결</h3><ul>
<li>Object.freeze메소드는 객체를 동결한다.</li>
<li>객체 동결이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미한다.</li>
<li><strong>동결된 객체는 읽기만 가능하게 된다</strong></li>
</ul>
<h3 id="5-4-불변-객체"><a href="#5-4-불변-객체" class="headerlink" title="5-4 불변 객체"></a>5-4 불변 객체</h3><ul>
<li>객체 변경 방지 메소드 들은 얕은 변경 방기로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지는 못하다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/02/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/03-02%20let,%20const%EC%99%80%20%EB%B8%94%EB%A1%9D%EB%A0%88%EB%B2%A8%20%EC%8A%A4%EC%BD%94%ED%94%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/03-02%20let,%20const%EC%99%80%20%EB%B8%94%EB%A1%9D%EB%A0%88%EB%B2%A8%20%EC%8A%A4%EC%BD%94%ED%94%84/" class="post-title-link" itemprop="url">JS 수업 예습/03-02 let, const와 블록레벨 스코프</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-02 08:55:25 / Updated at: 23:01:33" itemprop="dateCreated datePublished" datetime="2020-03-02T08:55:25+09:00">2020-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="let-const와-블록레벨-스코프"><a href="#let-const와-블록레벨-스코프" class="headerlink" title="let, const와 블록레벨 스코프"></a>let, const와 블록레벨 스코프</h1><h2 id="1-var-키워드로-선언한-변수의-문제점"><a href="#1-var-키워드로-선언한-변수의-문제점" class="headerlink" title="1. var 키워드로 선언한 변수의 문제점"></a>1. var 키워드로 선언한 변수의 문제점</h2><h3 id="1-1-변수-중복-선언-허용"><a href="#1-1-변수-중복-선언-허용" class="headerlink" title="1-1 변수 중복 선언 허용"></a>1-1 변수 중복 선언 허용</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.</span></span><br><span class="line"><span class="comment">// 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<ul>
<li>var 키워드 사용 시 동일한 변수 이름이 선언되어 있는 것을 모르고 중복 선언을 하고 할당까지 하면 미리 선언된 변수의 값이 변경되는 부작용이 있다</li>
</ul>
<h3 id="1-2-함수-레벨-스코프"><a href="#1-2-함수-레벨-스코프" class="headerlink" title="1-2 함수 레벨 스코프"></a>1-2 함수 레벨 스코프</h3><ul>
<li>var 키워드로 선언한 변수는 오로지 함수의 블록 만은 지역 스코프로 인정한다</li>
<li>var 키워드로 선언한 변수는 코드 블록 내에서 선언하여도 모두 전역변수가 된다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// 0 1 2 3 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 의도치 않게 처음 선언한 변수 i가 for문에 의하여 변경되었다.</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-3-변수-호이스팅"><a href="#1-3-변수-호이스팅" class="headerlink" title="1-3 변수 호이스팅"></a>1-3 변수 호이스팅</h3><ul>
<li>var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.</li>
<li>var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다.</li>
<li>var 키워드로 선언한 변수는 언제나 undefined를 반환한다.</li>
<li>변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의헤 에러를 발생시키지는 않지만 프로그램의 흐름 상 맞지 않을 뿐더러 가독성을 떨어뜨리고 오류를 발생 시킬 여지를 남긴다</li>
</ul>
<h2 id="2-let-키워드"><a href="#2-let-키워드" class="headerlink" title="2. let 키워드"></a>2. let 키워드</h2><h3 id="2-1-변수-중복선언-금지"><a href="#2-1-변수-중복선언-금지" class="headerlink" title="2-1 변수 중복선언 금지"></a>2-1 변수 중복선언 금지</h3><ul>
<li>let 키워드로 동일한 이을 갖는 변수를 중복 선언하면 문법에러 (SyntaxError)가 발생한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">456</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 456</span></span><br><span class="line"><span class="comment">// var 키워드로 변수 선언 시 중복 선언을 하면 아래 변수 선언문은 자바 스크립트 엔진에 의해 var키워드가 없는 것으로 동작하고 할당문인 것처름 됨</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">456</span>; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="comment">// let이나 const키워드로 선언된 변수는 같은 스코프 내에서 중복선언 허용 안됨</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-2-블록레벨-스코프"><a href="#2-2-블록레벨-스코프" class="headerlink" title="2-2 블록레벨 스코프"></a>2-2 블록레벨 스코프</h3><ul>
<li>let 키워드로 선언한 변수는 모든 코드블록(함수, if문, while문, try/carch문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">456</span>;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="number">456</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// referenceError</span></span><br></pre></td></tr></table></figure></li>
<li>함수도 코드 블록이므로 스코프를 만든다. 이때 함수 내의 코드블록은 함수레벨 스코프에 중첩된다</li>
</ul>
<h3 id="2-3-변수-호이스팅"><a href="#2-3-변수-호이스팅" class="headerlink" title="2-3 변수 호이스팅"></a>2-3 변수 호이스팅</h3><ul>
<li>var 키워드로 선언한 변수롸는 달리 let키워드로 선언한 변수는 변수 호이스킹이 발생하지 않는 것처럼 동작한다.</li>
<li>var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 “선언단계”와 “초기화단계” 가 한번에 진행된다.</li>
<li>즉 선언 단계에서 스코프에 변수 식별자를 등록하여 자바스크립트 엔진에 변수의 존재를 알리고 그 즉시 초기화 단계에서 undefined로 변수를 초기화 한다.</li>
<li><strong>let 키워드로 선언한 변수는 “선언단계”와 “초기화단계”가 분리되어 진행된다</strong></li>
<li>즉, 런타임 이전에 자바 스크립트 엔진에 의해 암묵적으로 선언단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다.</li>
<li>만약 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조에러가 발생한다.</li>
<li>따라서 스코프의 시작 지점부터 초기화 단계 시작 저점 까지는 변수를 참조할 수 없다.</li>
<li>스코프의 시작지점 부터 초기화 단계 시작 시점(변수 선언문) 까지는 변수를 참조할 수 없다.</li>
<li>스코프의 시작 지점부터 초기화의 시작 지점까지의 구간을 <strong>일시적 사각지대(Temppral Dead Zone; TDZ)</strong> 라고 부른다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo; <span class="comment">// 변수 선언문에서 초기화 단계가 실행된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">1</span>; <span class="comment">// 할당문에서 할당 단계가 실행된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는것처럼 보이지만 그렇지 않다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>; <span class="comment">// 전역변수</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>; <span class="comment">// 지역변수</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>let 키워드로 선언한 변수의 경우, 변수 호이스팅이 발생 하지 않는다면 위 예제의 전역변수 값인 1을 출력해야 한다</li>
<li>하지만 let키워드로 선언한 변수도 여전히 호이스팅이 발생하기 때문에 참조에러가 발생한다.</li>
</ul>
<h3 id="2-4-전역-객채와-let"><a href="#2-4-전역-객채와-let" class="headerlink" title="2-4 전역 객채와 let"></a>2-4 전역 객채와 let</h3><ul>
<li><p>전역객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 측수한 객체이며 어떤 객체도 속하지 않는 최상위 객체이다.</p>
</li>
<li><p>전역 객체는 클라이언트 사이드 환경에서는 window, 서버 사이드 환경에서는 global 객체를 가리킨다.</p>
</li>
<li><p>var 키워드로 선언한 전역변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역 그리고 전역함수는 전역 객체의 프로퍼티가 된다.</p>
</li>
<li><p>전역객체의 프로퍼티를 참조할 때 window를 생ㄹ갸할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역변수</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 암묵적 전역</span></span><br><span class="line">y = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티이다</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.x); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 암묵적 전역은 전역 객체의 프로퍼티이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.y) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(y) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문으로 정의한 전역 함수는 전역 객체의 프로퍼티이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.foo); <span class="comment">// f f00() &#123;&#125;</span></span><br><span class="line"><span class="comment">// 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// f foo() &#123;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>let 키워드로 선언한 전역변수는 전역 객체 window의 프로퍼티가 아니다. 즉 window.foo와 같이 접근할 수 없다.</p>
</li>
<li><p>let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 된다</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let, const 키워드로 선언한 전역변수는 전역 객체의 프로퍼티가 아니다</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-const-키워드"><a href="#3-const-키워드" class="headerlink" title="3. const 키워드"></a>3. const 키워드</h2><ul>
<li>const 키워드는 상수를 선언하기 위해 사용한다. 하지만 반드시 상수만을 위해 사용하지는 않는다.</li>
</ul>
<h3 id="3-1-선언과-초기화"><a href="#3-1-선언과-초기화" class="headerlink" title="3-1 선언과 초기화"></a>3-1 선언과 초기화</h3><ul>
<li>const 키워드로 선언한 변수는ㄴ 반드시 선언과 동시에 할당이 이루어 져야한다.</li>
<li>const 키워드로 선언한 변수는 let 키워드로 선언한 변수와 마찬가지로 블록레벨 스코프를 가지며 호이스팅이 발생하지 않는 것처럼 동작한다.</li>
</ul>
<h3 id="3-2-재할당-금지"><a href="#3-2-재할당-금지" class="headerlink" title="3-2 재할당 금지"></a>3-2 재할당 금지</h3><ul>
<li>var 또는 let 키워드로 선언한 변수는 재할당이 자유로우나 const 키워드로 선언한 변수는 재할당이 금지된다.</li>
</ul>
<h3 id="3-3-상수"><a href="#3-3-상수" class="headerlink" title="3-3 상수"></a>3-3 상수</h3><ul>
<li>const 키워드로 선언한 변수에 원시값을 할당한 경우, 변수값을 변경 할 수 없다.</li>
<li>원시값은 변경 불가능한 값 이므로 재할당 없이 값을 변경할 수 있는 방법이 없기 때문이다.</li>
<li>일반적으로 상수의 이름은 대문자로 선언하여 상수임을 명확이 나타낸다.</li>
<li>여러 단어로 이루어진 경우에는 언더스코어(_)로 구분하여 스네이크 케이스로 표현하는것이 일반적이다.</li>
<li><strong>const 키워드로 선언된 변수에 원시값을 할당한 경우, 원시값은 변경할수 없는 값이고 const키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.</strong></li>
</ul>
<h3 id="3-4-const-키워드와-객체"><a href="#3-4-const-키워드와-객체" class="headerlink" title="3-4 const 키워드와 객체"></a>3-4 const 키워드와 객체</h3><ul>
<li>const 키워드로 선언된 변수에 원시값을 할당한 경우, 값을 변경할 수 없다.</li>
<li><strong>const 키워드로 선언된 변수에 객채를 할당할 경우 값을 변경 할 수 있다.</strong></li>
<li>const 키워드는 재할당을 금지할 뿐 불변을 의미하지는 않는다.</li>
</ul>
<h2 id="4-var-vs-let-vs-const"><a href="#4-var-vs-let-vs-const" class="headerlink" title="4. var vs let vs const"></a>4. var vs let vs const</h2><ul>
<li>변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 팔요한 경우에 한정해 사용하는 것이 좋다.</li>
<li>원시값인 경우, 가급적 상수를 사용하는 편이 좋다.</li>
<li>객체를 재할당 하는 경우는 생각보다 크지 않음으로 const 키워드를 사용하면 의도치 않은 재할당을 방지해 준다.</li>
<li>var와 let, cont 키워드는 다음처럼 사용한다.<ul>
<li>ES5를 사용한다면 var 키워드는 사용하지 않는다.</li>
<li>재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.</li>
<li>변경이 발생하지 않고 읽기 전용으로 사용하는 원시값과 객체에는 const 키워드를 사용한다.(const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전하다)</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/02/29/%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4/%EC%A0%9C%EC%96%B4%EB%AC%B8%20%EC%97%B0%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/29/%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4/%EC%A0%9C%EC%96%B4%EB%AC%B8%20%EC%97%B0%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/" class="post-title-link" itemprop="url">제어문 연습문제</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-29 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-29T00:00:00+09:00">2020-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-01 00:00:00" itemprop="dateModified" datetime="2020-03-01T00:00:00+09:00">2020-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/" itemprop="url" rel="index">
                    <span itemprop="name">문제풀이</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="제어문-연습-문제"><a href="#제어문-연습-문제" class="headerlink" title="제어문 연습 문제"></a>제어문 연습 문제</h1><ol>
<li><p>변수 X가 10보다 크고 20보다 작을 때 변수 X를 출력하는 조건식을 완성하라.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span> &amp;&amp; x &lt; <span class="number">20</span>) <span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 문을 사용하여 0부터 10미만 정수 중에서 짝수만을 작은 수부터 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for문을 사용하여 0부터 10 미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) str += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 문을 사용하여 0부터 10 미만의 정수 중에서 홀수만을 큰 수부터 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">  i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while문을 사용하여 0부터 10 미만의 정수 중에서 홀수만을 큰 수부터 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">  i -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
</li>
<li><p>1부터 20미만의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((i % <span class="number">2</span>) &amp;&amp; (i % <span class="number">3</span>)) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
</li>
<li><p>1부터 20 미만의 정수 중에서 2또는 3의 배수인 수의 총합을 구하시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(i % <span class="number">2</span>) || !(i % <span class="number">3</span>)) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
</li>
<li><p>두개의 주사위를 전졌을 떄, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dice = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> fst = <span class="number">1</span>; fst &lt; <span class="number">7</span>; fst++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> scd = <span class="number">1</span>; scd &lt; <span class="number">7</span>; scd++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fst + scd === <span class="number">6</span>) <span class="built_in">console</span>.log(dice = [fst, scd]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>삼각형 출력하기 - pattern 1 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt;= vtl; hzt++) &#123;</span><br><span class="line">    tree += <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>삼각형 출력하기 - pattern 2</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">5</span>; hzt++) &#123;</span><br><span class="line">    tree += vtl &gt; hzt ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>삼각형 출력하기 - pattern 3</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">5</span>; vtl &gt; <span class="number">0</span>; vtl--) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; vtl; hzt++) &#123;</span><br><span class="line">    tree += <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>삼각형 출력하기 - pattern 4</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">5</span>; hzt++) &#123;</span><br><span class="line">    tree += (vtl + hzt &gt; <span class="number">3</span>) ? <span class="string">'*'</span> : <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>정삼각형 출력하기</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">9</span>; hzt++) &#123;</span><br><span class="line">    tree += ((hzt &gt; (<span class="number">4</span> + vtl)) || (hzt &lt; (<span class="number">4</span> - vtl))) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>역정삼각형 출력하기</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">9</span>; hzt++) &#123;</span><br><span class="line">    tree += ((hzt &lt; (<span class="number">0</span> + vtl)) || (hzt &gt; (<span class="number">8</span> - vtl))) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="3-1-추가"><a href="#3-1-추가" class="headerlink" title="3/1 추가"></a>3/1 추가</h4><ul>
<li><p>콜백함수 응용 정삼각형, 정역삼각형 logic 동시 구현</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tree</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">9</span>; hzt++) &#123;</span><br><span class="line">      f(vtl, hzt);</span><br><span class="line">    &#125;</span><br><span class="line">    sum += <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fw</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += ((h &gt; (<span class="number">4</span> + v)) || (h &lt; (<span class="number">4</span> - v))) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bw</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += ((h &lt; (<span class="number">0</span> + v)) || (h &gt; (<span class="number">8</span> - v))) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree(fw);</span><br><span class="line"><span class="comment">// 인수로 fw 입력 시 정삼각형, 인수로 bw 입력 시 정역삼각형 반환</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>콜백함수 응용 삼각형찍기 pattern1 ~ 4끼지 동시 구현</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tree</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">5</span>; hzt++) &#123;</span><br><span class="line">      f(vtl, hzt);</span><br><span class="line">    &#125;</span><br><span class="line">    sum += <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ptn1</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += (v &lt; h) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ptn2</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += (v &gt; h) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ptn3</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += (v + h &gt;= <span class="number">5</span>) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ptn4</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += (v + h &lt; <span class="number">4</span>) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line">tree(ptn1);</span><br><span class="line"><span class="comment">// 인수로 ptn1 ~ ptn4 입력 시 삼각형은 패턴에 맞게 출력됨</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="다음 페이지"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          흝어보기
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">angryboo</p>
  <div class="site-description" itemprop="description">I can do this all day</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">카테고리</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">태그</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">angryboo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
