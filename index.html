<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"angryboo.github.io","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="I can do this all day">
<meta property="og:type" content="website">
<meta property="og:title" content="angryboo">
<meta property="og:url" content="https://angryboo.github.io/index.html">
<meta property="og:site_name" content="angryboo">
<meta property="og:description" content="I can do this all day">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="angryboo">
<meta property="article:tag" content="vs">
<meta property="article:tag" content=" html">
<meta property="article:tag" content=" css">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://angryboo.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>angryboo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">angryboo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">angryboo blog</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>홈</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>카테고리</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>아카이브</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/10/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-10%20%EC%98%88%EC%8A%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/10/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-10%20%EC%98%88%EC%8A%B5/" class="post-title-link" itemprop="url">JS 수업 예습/2020-03-10 예습</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-10 17:34:45 / Updated at: 17:38:26" itemprop="dateCreated datePublished" datetime="2020-03-10T17:34:45+09:00">2020-03-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="생성자-함수에-의한-객체-생성"><a href="#생성자-함수에-의한-객체-생성" class="headerlink" title="생성자 함수에 의한 객체 생성"></a>생성자 함수에 의한 객체 생성</h1><h2 id="1-Object-생성자-함수"><a href="#1-Object-생성자-함수" class="headerlink" title="1. Object 생성자 함수"></a>1. Object 생성자 함수</h2><ul>
<li>new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다.</li>
<li>빈객체를 생성한 이후 프로퍼티 또는 메소드를 추가하여 객체를 완성할 수 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//빈객채의 생성</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> ObjectW();</span><br><span class="line"></span><br><span class="line"><span class="comment">//프로퍼티 추가</span></span><br><span class="line">person.name = <span class="string">'Song'</span>;</span><br><span class="line">person.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi! My Name is '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// Object &#123;name: "Song", sayHello: function ()&#125;</span></span><br><span class="line">person.sayHello(); <span class="comment">// Hi! My Name is Song</span></span><br></pre></td></tr></table></figure>
<ul>
<li>생성자 함수란 new 연산자와 함께 호출하여 격체(인스턴스)를 생성하는 함수를 말한다.</li>
<li>생성자 함수에 의해 생성된 객채를 인스턴스라 한다.</li>
</ul>
<h2 id="2-생성자-함수"><a href="#2-생성자-함수" class="headerlink" title="2. 생성자 함수"></a>2. 생성자 함수</h2><h3 id="2-1-객체-리터럴에-의한-객체-생성-방식의-문제점"><a href="#2-1-객체-리터럴에-의한-객체-생성-방식의-문제점" class="headerlink" title="2-1 객체 리터럴에 의한 객체 생성 방식의 문제점"></a>2-1 객체 리터럴에 의한 객체 생성 방식의 문제점</h3><ul>
<li>객체 리터럴에 의한 객체 생성 방식은 간편하지만 단 하나의 객채만을 생성하기 때문에 동일한 프로퍼티를 갖는 객채를 여러개 생성하는 경우 비효율적임</li>
</ul>
<h3 id="2-2-생성자-함수에-의한-객체-생성-방식의-장점"><a href="#2-2-생성자-함수에-의한-객체-생성-방식의-장점" class="headerlink" title="2-2 생성자 함수에 의한 객체 생성 방식의 장점"></a>2-2 생성자 함수에 의한 객체 생성 방식의 장점</h3><ul>
<li>생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스) 처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러개를 간편하게 생성할 수 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//생성자함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>); <span class="comment">// 반지름이 5인 Circle객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">10</span>); <span class="comment">//  반지름이 10인 Circle 객체를 생성</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getDiameter()); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getDiameter()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p><strong>this : this 는 객체 자신의 프로퍼티나 메소드를 함조하기 위한 자기 함조변수이다. this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다</strong></p>
<table>
<thead>
<tr>
<th>함수 호출 방식</th>
<th>this가 가리키는 값</th>
</tr>
</thead>
<tbody><tr>
<td>일반 함수로서 호출</td>
<td>전역 객체</td>
</tr>
<tr>
<td>메소드로서 호출</td>
<td>메소드를 호출한 객체</td>
</tr>
<tr>
<td>생성자 함수로서 호출</td>
<td>생성자 함수가 생성할 인스턴스</td>
</tr>
</tbody></table>
<ul>
<li>생성자 함수는 말 그대로 객체(인스턴스)를 생성하는 함수이다</li>
<li>자바와 같은 클래스 기반 객체지향 언어의 생성자 와는 다르게 그 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 <strong>new연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.</strong></li>
</ul>
<h3 id="2-3-내부-메소드-Call-과-Construct"><a href="#2-3-내부-메소드-Call-과-Construct" class="headerlink" title="2-3 내부 메소드 [[Call]] 과 [[Construct]]"></a>2-3 내부 메소드 [[Call]] 과 [[Construct]]</h3><ul>
<li>함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로써 호출할 수 있는것을 물론 생성자 ㅎ마수로서 호출할 수 있다.</li>
<li>생성자 함수로써 호출된다는 것은 new연산자와 함께 호출하여 객체를 생성하는것을 의미한다.</li>
<li>함수는 객체이므로 일반 객체와 동일하게 동작할 수 있다.</li>
<li>함수 객체는 일반 객체의 내부 슬롯과 내부 메소드를 모두 가지고 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수는 객체이다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 객체이므로 프로퍼틸를 소유할 수 있다</span></span><br><span class="line">foo.prop = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 객체이므로 메소드를 소유할 수 있다.</span></span><br><span class="line">foo.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.prop);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.method();</span><br></pre></td></tr></table></figure>
<ul>
<li>내부 메소드 [[Call]]을 갖는 함수 객체를 callable이라 하며, 내부 메소드인 [[Construct]]를 갖는 함수 객체를 constructor, [[Construct]]를 갖지 않은 함수 객체를 non-constructor라고 부른다</li>
<li>callable은 호출할 수 있는 객체, 즉 함수를 말하며, constructor는 생성자 함수로서 호출할 수 있는 객체를 의미한다.</li>
<li>생성자 함수로서 호출될 수 있다는 것은 new연산자와 함께 호출되는 것을 의미한다.</li>
<li>함수가 일밙적인 함수로서 호출되면 함수 객체의 내부 메소드 [[Call]]가 먼저 호출되고 new연산자와 함께 생성자 함수로서 호출되면 내부 메소드 [[Construct]]가 호출된다</li>
<li>모든 함수 객체는 내부 메소드 [[Call]]을 갖고 있으므로 호출할 수 있다.</li>
<li>하지만 모든 함수 객체가 [[Construct]]를 갖지는 않는다.</li>
</ul>
<h3 id="2-4-constructor와-non-constructor의-구분"><a href="#2-4-constructor와-non-constructor의-구분" class="headerlink" title="2-4 constructor와 non-constructor의 구분"></a>2-4 constructor와 non-constructor의 구분</h3><ul>
<li>자바 스크립트 엔진은 함수를 생성 할 때 FunctionCrreate라는 추정 연산을 사용한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일반 함수 정의 : kind = 'Normal'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//  프로퍼티 x에 할당된 것은 일반 함수 정의이다. 메소드 정의로 인정하지 않는다.</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;</span><br><span class="line">  x: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반함수로 정의된 함수만이 constructor이다</span></span><br><span class="line"><span class="keyword">new</span> foo(); <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">new</span> bar(); <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">new</span> baz.x(); <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 화살표 함수 정의 : kind = 'Arrow'</span></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> arrow(); <span class="comment">// typeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드 정의 : kind = 'Method'</span></span><br><span class="line"><span class="comment">// ES6의 메소드 축약 표현만을 메소드 정의로 인정한다.</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> obj.x(); <span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-5-생성자-함수의-인스턴스-생성과정"><a href="#2-5-생성자-함수의-인스턴스-생성과정" class="headerlink" title="2-5 생성자 함수의 인스턴스 생성과정"></a>2-5 생성자 함수의 인스턴스 생성과정</h3><ul>
<li>생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿으로서 동작하여 인스턴스를 생성하는것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것이다</li>
<li>생성자 함수가 인스턴스를 생성하는것은 필수이고, 생성된 인스턴스를 초기화 하는것은 옵션이다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//생성자함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 인스턴스 초기화</span></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>); <span class="comment">// 반지름이 5인 Circle객체를 생성</span></span><br></pre></td></tr></table></figure>
<ul>
<li>함수 내부의 코드를 살펴보면 this에 프로퍼티를 추가하고 필요에 따라 인수로 전달된 초기값을 프로퍼티 값으로 할당한다.</li>
<li>자바 스크입트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다. new 연산자와 함께 생성자 함수가 호출되면 자바 스크립트 엔진은 아래와 같은 과정을 거쳐 인스턴스를 생성하고 초기화 한 후, 인스턴스를 반환한다.<ol>
<li>인스턴스 생성과 this 바인딩<ul>
<li>암묵적으로 빈 객체가 생선된다. 이 빈객체가 바로 생성자 함수가 생선한 인스턴스이다. 그리고 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩 된다.</li>
</ul>
</li>
<li>인스턴스 초기화<ul>
<li>생성자 함수에 기술되어 있는 코드가 실행되어 this에 바인딩 되어있는 인스턴스를 초기화 한다. 즉 this에 바인딩 되어 있는 인스턴스에 프로퍼티나 메소드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화 하거나 고정값을 할당한다.</li>
</ul>
</li>
<li>인스턴스 반환<ul>
<li>생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩 된 this가 암묵적으로 반환된다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="2-6-new연산자"><a href="#2-6-new연산자" class="headerlink" title="2-6 new연산자"></a>2-6 new연산자</h4><ul>
<li>new 연산자와 함께 생ㅅ어자 람수에 의해 생선된 객체(인스턴스)는 프로토 타입에의해 생성자 함수와 연결된다. 이를 이용해 new연산자와 함께 호출 되었는지를 확인할 수 있다.</li>
</ul>
<h1 id="함수와-일급객체"><a href="#함수와-일급객체" class="headerlink" title="함수와 일급객체"></a>함수와 일급객체</h1><h2 id="1-일급객체"><a href="#1-일급객체" class="headerlink" title="1. 일급객체"></a>1. 일급객체</h2><ol>
<li>무명의 리터럴로 생성할 수 있다. 즉 런타임에 생성이 가능하다.</li>
<li>변수나 자료구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개변수에게 전달 할 수 있다.</li>
<li>함수의 결과값으로 반환 할 수 있다.</li>
</ol>
<p><strong>함수형 프로그래밍</strong></p>
<ul>
<li><p>함수형 프로그래밍은 순수함수와 보조함수의 조합을 통해 외부상태를 변경하는 부수효과를 최소화하여 불변성을 지향하는 프로그래밍</p>
</li>
<li><p>함수는 객체이지만 일반 객체와는 차이가 있다. 일반 객체는 호출할 수 없지만 함수 객체는 호출할 수 있다. 그리고 함수 객체에는 일반 객체에 없는 함수 고유의 프로퍼티를 소유한다.</p>
</li>
</ul>
<h2 id="2-함수-객체의-프로퍼티"><a href="#2-함수-객체의-프로퍼티" class="headerlink" title="2. 함수 객체의 프로퍼티"></a>2. 함수 객체의 프로퍼티</h2><ol>
<li>argument 프로퍼티<ul>
<li>함수 호출 시 전달 된 인수들의 정보를 담고 있는 유사배열 객체</li>
<li>함수 내부에서 지역변수처럼 사용</li>
<li>함수 외부에서 사용할 수 없음</li>
<li>매개변수 개수를 확정할 수 없는 가변인자 함수를 구현할 때 유용하게 사용됨</li>
</ul>
</li>
<li>caller 프로퍼티</li>
<li>length 프로퍼티 함수 객체의 length 프로퍼티는 함수 정의 시 선언한 매개변수의 개수를 가리킴</li>
<li>name 프포퍼티 : 함수 객체의 name 프로퍼티는 함수 이름을 나타낸다.</li>
<li><em>_Proto</em> 접근자 프로퍼티</li>
<li>prototype 프로퍼티</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/02/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/03-02%20%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%20%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/03-02%20%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%20%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/" class="post-title-link" itemprop="url">JS 수업 예습/03-02 프로퍼티 어트리뷰트</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-03-02 16:26:02" itemprop="dateCreated datePublished" datetime="2020-03-02T16:26:02+09:00">2020-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-03 10:50:03" itemprop="dateModified" datetime="2020-03-03T10:50:03+09:00">2020-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="프로퍼티-어트리뷰트"><a href="#프로퍼티-어트리뷰트" class="headerlink" title="프로퍼티 어트리뷰트"></a>프로퍼티 어트리뷰트</h1><h2 id="1-내부-슬롯과-내부-메소드"><a href="#1-내부-슬롯과-내부-메소드" class="headerlink" title="1. 내부 슬롯과 내부 메소드"></a>1. 내부 슬롯과 내부 메소드</h2><ul>
<li>내부 슬롯(Internal slot)과 내부 메소드(Internal method)는 자바 스크립트 자바 스크립트 엔진의 알고리즘을 설명하지 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티(Pseudo)와 의사 메소드 이다 ECMAScript 사양에 등장하는 이중 대괄호 ([[…]])로 감싼 이름들이 내부 슬롯과 메소드이다.</li>
<li>내부 슬롯과 내부 메소드는 ECMAScript 사양에 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작하지만 외부로 공개된 객체의 프로퍼티는 아니다.</li>
<li>즉 내부 슬롯과 내부 메소드는 자바스크립트 엔진의 내부 로직이므로 원칙적으로 자바스크립트는 내부 슬록과 내부 메소드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않는다.</li>
<li>단, 일부 내부 슬롯과 내부 메소드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.</li>
</ul>
<h2 id="2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h2><ul>
<li>자바스크립트 엔진은 프로퍼티를 생성할 때, 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.</li>
<li>프로퍼티의 상태란 프로퍼티의 값(value), 값의 갱신 가능(writable) 여부, 열거 가능(enumerable) 여부, 재정의 가능(configurable) 여부를 말한다.</li>
<li>프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값(meta-property)인 내부슬롯 ([[Value]], [[Writable]], [[Enumerable]], [[configurable]]) 이다.</li>
<li>따라서 프로퍼티 어트리뷰트에 직접 접근 할 수 없지만, Object.getOwnPropertyDescriptor 메소드를 사용하여 간접적으로 확인할 수는 있다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "song", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Object.getOwnPropertyDescriptor 메소드를 호출할 때, 첫번째 매개변수에는 객체의 참조를 전달하고 두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다.</li>
<li>이때 Object.getOwnPropertyDescriptor 메소드는 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.</li>
<li>만약 존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 프로퍼티 디스크립터를 요구하면 undefined가 반환된다.</li>
</ul>
<ul>
<li>Object.getOwnPropertyDescriptor 메소드는 하나의 프로퍼티에 대해 디스크립터 객체를 반환한다</li>
<li>Object.getOwnPropertyDescriptors 메소드는 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크럽터 객체를 반환한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//프로퍼티 동적 생성</span></span><br><span class="line">person.age = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크럽터 객체들을 반환한다</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person));</span><br><span class="line"><span class="comment">// name: &#123;value: "song", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">// age: &#123;value: 32, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-데이터-프로퍼티와-접근자-프로퍼티"><a href="#3-데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="3. 데이터 프로퍼티와 접근자 프로퍼티"></a>3. 데이터 프로퍼티와 접근자 프로퍼티</h2><ul>
<li>프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 구분한다.<ul>
<li>데이터 프로퍼티(Data Property) : 키와 값으로 구성된 일반적 프로퍼티다.</li>
<li>접근자 프로퍼티(Assessor Property) : 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 잡근자 함수(Accessor)로 구성된 프로퍼티 이다.</li>
</ul>
</li>
</ul>
<h3 id="3-1-데이터-프로퍼티"><a href="#3-1-데이터-프로퍼티" class="headerlink" title="3-1 데이터 프로퍼티"></a>3-1 데이터 프로퍼티</h3><ul>
<li>데이터 프로퍼티는 아래와 같은 프로퍼티 어트리뷰트를 갖는다.</li>
<li>이 프로퍼티 어트리뷰트는 자바스크립트 엔진이 프로퍼티를 생성할 때, 기본값으로 자동 정의된다.<table>
<thead>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th>프로퍼티 디스크럽터 객체의 프로퍼티</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>[[Value]]</td>
<td>value</td>
<td>- 프로퍼티 키로 프로퍼티 값에 접근하면 반환되는 값이다. <br>- 프로퍼티 키로 프로퍼티 값을 저장하면 [[value]]에 값을 저장한다. 이때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다.</td>
</tr>
<tr>
<td>[[Writable]]</td>
<td>writable</td>
<td>- 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다. <br>-[[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기전용 프로퍼티가 된다.</td>
</tr>
<tr>
<td>[[Enumerable]]</td>
<td>enumerable</td>
<td>- 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다. <br>- [[Enumerable]]의 값이 false인 경우, 해당 프로퍼티는 for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td>configurable</td>
<td>- 프로퍼티 재정의 가능 여부를 나타내며 불리언 값을 갖는다. <br> [[Configurable]]의 값이 false인 경우, 해당 프로퍼티를 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 혀용된다.</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="3-2-접근자-프로퍼티"><a href="#3-2-접근자-프로퍼티" class="headerlink" title="3-2 접근자 프로퍼티"></a>3-2 접근자 프로퍼티</h3><ul>
<li>접근자 프로퍼티(Accessor property)는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(Accessor function)로 구성된 프로퍼티 이다.</li>
<li>접근자 프로퍼티는 아래와 같은 프로퍼티 어트리뷰트를 갖는다.<table>
<thead>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th>프로퍼티 디스크럽터 객체의 프로퍼티</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>[[Get]]</td>
<td>get</td>
<td>접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수이다. 즉 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[get]]의 값, 즉 getter함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다</td>
</tr>
<tr>
<td>[[Set]]</td>
<td>set</td>
<td>접근자 프로퍼티를 통해 프로퍼티 값을 저장할 때 호출되는 접근자 함수이다. 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 Setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</td>
</tr>
<tr>
<td>[[Enumerable]]</td>
<td>enumerable</td>
<td>데이터 타입의 [[Enumerable]]와 같다.</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td>configurable</td>
<td>데이터 타입의 [[Configurable]]와 같다.</td>
</tr>
</tbody></table>
</li>
<li>접근자 함수는 getter/setter함수라고도 부른다. 접근자 프로퍼티는 grtter와 setter 함수를 모두 정의할 수도 있고 하나만 정의할 수도 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">'Buyong'</span>,</span><br><span class="line">  lastName: <span class="string">'Song'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fullName은 접근자 함수로 구성된 접근자 프로퍼티이다.</span></span><br><span class="line">  <span class="comment">// getter 함수</span></span><br><span class="line">  <span class="keyword">get</span> fullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter 함수</span></span><br><span class="line">  <span class="keyword">set</span> fullName(name) &#123;</span><br><span class="line">    [<span class="keyword">this</span>.firstName, <span class="keyword">this</span>.lastName] = name.split(<span class="string">' '</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 접근하면 getter함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(person.fullName); <span class="comment">// Buyong Song</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 프로퍼티를 통한 값의 참조</span></span><br><span class="line"><span class="built_in">console</span>.log(person.firstName, person.lastName); <span class="comment">// Buyong Song</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 값의 저장</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.</span></span><br><span class="line">person.fullName = <span class="string">'angry boo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; firstName: 'angry', lastName: 'boo', fullName: [Getter/Setter] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 프로퍼티 값의 참조</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 접근하면 getter함수가 출력된다</span></span><br><span class="line"><span class="built_in">console</span>.log(person.fullName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// firstName은 데이터 프로퍼티이다.</span></span><br><span class="line"><span class="comment">// 데이터 프로퍼티는 value, writable, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.</span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'firstName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  value: 'angry',</span></span><br><span class="line"><span class="comment">  writable: true,</span></span><br><span class="line"><span class="comment">  enumerable: true,</span></span><br><span class="line"><span class="comment">  configurable: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fullName은 접근자 프로퍼티 이다.</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어프리뷰트를 갖는다.</span></span><br><span class="line">descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'fullName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  get: [Function: get fullName],</span></span><br><span class="line"><span class="comment">  set: [Function: set fullName],</span></span><br><span class="line"><span class="comment">  enumerable: true,</span></span><br><span class="line"><span class="comment">  configurable: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>접근자 프로퍼티 fullName으로 프로퍼티 값에 접근하면 내부적으로 [[Get]] 내부 메소드가 호출되어 아래와 같이 작동한다<ol>
<li>프로퍼티 키가 유효한지 확인한다. 프로퍼티 키는 몬자열 또는 심볼이어야 한다. 프로퍼티 키 “fullName”은 문자열 이므로 프로퍼티 키다.</li>
<li>프로토타입 체인에서 프로퍼티를 검색한다. person객체에 fullName 프로퍼티가 존재한다.</li>
<li>검색된 fullName 프로퍼티가 테이터 프로퍼티인지 접근자 프로퍼티인지 확인한다. fullName 프로퍼티는 접근자 프로퍼티다.</li>
<li>접근자 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 함수를 호출하여 그 결과를 반환한다. 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값은 Object.getOwnPropertyDesciptor 메소드가 반환하는 프로퍼티 디스크립터 객체의 get 프로퍼티 값과 같다.</li>
</ol>
</li>
</ul>
<h2 id="4-프로퍼티-정의"><a href="#4-프로퍼티-정의" class="headerlink" title="4. 프로퍼티 정의"></a>4. 프로퍼티 정의</h2><ul>
<li>프로퍼티 정의 : 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적의로 정의하거나, 기존 어트리뷰트를 재정의 하는것</li>
<li>Object.defineProperty 메소드를 사용하면 프로퍼티 어트리뷰트를 정의할 수 있음</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//데이터 프로퍼티 정의</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'firstName'</span>, &#123;</span><br><span class="line">  value: <span class="string">'Buyong'</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'lastName'</span>, &#123;</span><br><span class="line">  value: <span class="string">'Song'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'firstName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="comment">// Object &#123;value: "Buyong", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 디스크립터 객체의 프로퍼티를 누락 시키면 undefined, false가 기본값이다.</span></span><br><span class="line">descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'lastName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="comment">//Object &#123;value: "Song", writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 정의</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'fullName'</span>, &#123;</span><br><span class="line">  <span class="comment">//getter 함수</span></span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter 함수</span></span><br><span class="line">  <span class="keyword">set</span>(name) &#123;</span><br><span class="line">    [<span class="keyword">this</span>.firstName, <span class="keyword">this</span>.lastName] = name.split(<span class="string">' '</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="5-객체-변경-금지"><a href="#5-객체-변경-금지" class="headerlink" title="5. 객체 변경 금지"></a>5. 객체 변경 금지</h2><ul>
<li>자바스크립트는 객체의 변경을 방지할 수 있는 다양한 메소드를 제공한다. 객체 변경 방지 메소드 들은 객체의 변경을 금지하는 강도가 다르다.<table>
<thead>
<tr>
<th>구분</th>
<th></th>
<th align="center">메소드</th>
<th align="center">프로퍼티 추가</th>
<th align="center">프로퍼티 삭제</th>
<th align="center">프로퍼티 값 읽기</th>
<th align="center">프로퍼티 어트리뷰트 재정의</th>
</tr>
</thead>
<tbody><tr>
<td>객체 확장 금지</td>
<td>Object.preventExtensions</td>
<td align="center">X</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">O</td>
</tr>
<tr>
<td>객체 밀봉</td>
<td>Object.seal</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">X</td>
</tr>
<tr>
<td>객체 동결</td>
<td>Object.freeze</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">O</td>
<td align="center">X</td>
<td align="center">X</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="5-1-객체-확장-금지"><a href="#5-1-객체-확장-금지" class="headerlink" title="5-1 객체 확장 금지"></a>5-1 객체 확장 금지</h3><ul>
<li>Object.preventExtensions 메소드는 객체의 확장을 금지한다.</li>
<li>객체의 확장 금지란 프로퍼티 추가 금지를 의미한다.</li>
<li><strong>확장이 금지괸 객체는 프로퍼티 추가가 금지됨다</strong></li>
</ul>
<h3 id="5-2-객체-밀봉"><a href="#5-2-객체-밀봉" class="headerlink" title="5-2 객체 밀봉"></a>5-2 객체 밀봉</h3><ul>
<li>객체 밀봉이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지를 의미한다.</li>
<li><strong>밀봉된 객체는 읽기와 쓰기만 가능하게 된다</strong></li>
</ul>
<h3 id="5-3-객체-동결"><a href="#5-3-객체-동결" class="headerlink" title="5-3 객체 동결"></a>5-3 객체 동결</h3><ul>
<li>Object.freeze메소드는 객체를 동결한다.</li>
<li>객체 동결이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미한다.</li>
<li><strong>동결된 객체는 읽기만 가능하게 된다</strong></li>
</ul>
<h3 id="5-4-불변-객체"><a href="#5-4-불변-객체" class="headerlink" title="5-4 불변 객체"></a>5-4 불변 객체</h3><ul>
<li>객체 변경 방지 메소드 들은 얕은 변경 방기로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지는 못하다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/02/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/03-02%20let,%20const%EC%99%80%20%EB%B8%94%EB%A1%9D%EB%A0%88%EB%B2%A8%20%EC%8A%A4%EC%BD%94%ED%94%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/03-02%20let,%20const%EC%99%80%20%EB%B8%94%EB%A1%9D%EB%A0%88%EB%B2%A8%20%EC%8A%A4%EC%BD%94%ED%94%84/" class="post-title-link" itemprop="url">JS 수업 예습/03-02 let, const와 블록레벨 스코프</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-02 08:55:25 / Updated at: 23:01:33" itemprop="dateCreated datePublished" datetime="2020-03-02T08:55:25+09:00">2020-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="let-const와-블록레벨-스코프"><a href="#let-const와-블록레벨-스코프" class="headerlink" title="let, const와 블록레벨 스코프"></a>let, const와 블록레벨 스코프</h1><h2 id="1-var-키워드로-선언한-변수의-문제점"><a href="#1-var-키워드로-선언한-변수의-문제점" class="headerlink" title="1. var 키워드로 선언한 변수의 문제점"></a>1. var 키워드로 선언한 변수의 문제점</h2><h3 id="1-1-변수-중복-선언-허용"><a href="#1-1-변수-중복-선언-허용" class="headerlink" title="1-1 변수 중복 선언 허용"></a>1-1 변수 중복 선언 허용</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.</span></span><br><span class="line"><span class="comment">// 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<ul>
<li>var 키워드 사용 시 동일한 변수 이름이 선언되어 있는 것을 모르고 중복 선언을 하고 할당까지 하면 미리 선언된 변수의 값이 변경되는 부작용이 있다</li>
</ul>
<h3 id="1-2-함수-레벨-스코프"><a href="#1-2-함수-레벨-스코프" class="headerlink" title="1-2 함수 레벨 스코프"></a>1-2 함수 레벨 스코프</h3><ul>
<li>var 키워드로 선언한 변수는 오로지 함수의 블록 만은 지역 스코프로 인정한다</li>
<li>var 키워드로 선언한 변수는 코드 블록 내에서 선언하여도 모두 전역변수가 된다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// 0 1 2 3 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 의도치 않게 처음 선언한 변수 i가 for문에 의하여 변경되었다.</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-3-변수-호이스팅"><a href="#1-3-변수-호이스팅" class="headerlink" title="1-3 변수 호이스팅"></a>1-3 변수 호이스팅</h3><ul>
<li>var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.</li>
<li>var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다.</li>
<li>var 키워드로 선언한 변수는 언제나 undefined를 반환한다.</li>
<li>변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의헤 에러를 발생시키지는 않지만 프로그램의 흐름 상 맞지 않을 뿐더러 가독성을 떨어뜨리고 오류를 발생 시킬 여지를 남긴다</li>
</ul>
<h2 id="2-let-키워드"><a href="#2-let-키워드" class="headerlink" title="2. let 키워드"></a>2. let 키워드</h2><h3 id="2-1-변수-중복선언-금지"><a href="#2-1-변수-중복선언-금지" class="headerlink" title="2-1 변수 중복선언 금지"></a>2-1 변수 중복선언 금지</h3><ul>
<li>let 키워드로 동일한 이을 갖는 변수를 중복 선언하면 문법에러 (SyntaxError)가 발생한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">456</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 456</span></span><br><span class="line"><span class="comment">// var 키워드로 변수 선언 시 중복 선언을 하면 아래 변수 선언문은 자바 스크립트 엔진에 의해 var키워드가 없는 것으로 동작하고 할당문인 것처름 됨</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">456</span>; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="comment">// let이나 const키워드로 선언된 변수는 같은 스코프 내에서 중복선언 허용 안됨</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-2-블록레벨-스코프"><a href="#2-2-블록레벨-스코프" class="headerlink" title="2-2 블록레벨 스코프"></a>2-2 블록레벨 스코프</h3><ul>
<li>let 키워드로 선언한 변수는 모든 코드블록(함수, if문, while문, try/carch문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">456</span>;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="number">456</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// referenceError</span></span><br></pre></td></tr></table></figure></li>
<li>함수도 코드 블록이므로 스코프를 만든다. 이때 함수 내의 코드블록은 함수레벨 스코프에 중첩된다</li>
</ul>
<h3 id="2-3-변수-호이스팅"><a href="#2-3-변수-호이스팅" class="headerlink" title="2-3 변수 호이스팅"></a>2-3 변수 호이스팅</h3><ul>
<li>var 키워드로 선언한 변수롸는 달리 let키워드로 선언한 변수는 변수 호이스킹이 발생하지 않는 것처럼 동작한다.</li>
<li>var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 “선언단계”와 “초기화단계” 가 한번에 진행된다.</li>
<li>즉 선언 단계에서 스코프에 변수 식별자를 등록하여 자바스크립트 엔진에 변수의 존재를 알리고 그 즉시 초기화 단계에서 undefined로 변수를 초기화 한다.</li>
<li><strong>let 키워드로 선언한 변수는 “선언단계”와 “초기화단계”가 분리되어 진행된다</strong></li>
<li>즉, 런타임 이전에 자바 스크립트 엔진에 의해 암묵적으로 선언단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다.</li>
<li>만약 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조에러가 발생한다.</li>
<li>따라서 스코프의 시작 지점부터 초기화 단계 시작 저점 까지는 변수를 참조할 수 없다.</li>
<li>스코프의 시작지점 부터 초기화 단계 시작 시점(변수 선언문) 까지는 변수를 참조할 수 없다.</li>
<li>스코프의 시작 지점부터 초기화의 시작 지점까지의 구간을 <strong>일시적 사각지대(Temppral Dead Zone; TDZ)</strong> 라고 부른다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo; <span class="comment">// 변수 선언문에서 초기화 단계가 실행된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">1</span>; <span class="comment">// 할당문에서 할당 단계가 실행된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는것처럼 보이지만 그렇지 않다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>; <span class="comment">// 전역변수</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>; <span class="comment">// 지역변수</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>let 키워드로 선언한 변수의 경우, 변수 호이스팅이 발생 하지 않는다면 위 예제의 전역변수 값인 1을 출력해야 한다</li>
<li>하지만 let키워드로 선언한 변수도 여전히 호이스팅이 발생하기 때문에 참조에러가 발생한다.</li>
</ul>
<h3 id="2-4-전역-객채와-let"><a href="#2-4-전역-객채와-let" class="headerlink" title="2-4 전역 객채와 let"></a>2-4 전역 객채와 let</h3><ul>
<li><p>전역객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 측수한 객체이며 어떤 객체도 속하지 않는 최상위 객체이다.</p>
</li>
<li><p>전역 객체는 클라이언트 사이드 환경에서는 window, 서버 사이드 환경에서는 global 객체를 가리킨다.</p>
</li>
<li><p>var 키워드로 선언한 전역변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역 그리고 전역함수는 전역 객체의 프로퍼티가 된다.</p>
</li>
<li><p>전역객체의 프로퍼티를 참조할 때 window를 생ㄹ갸할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역변수</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 암묵적 전역</span></span><br><span class="line">y = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티이다</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.x); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 암묵적 전역은 전역 객체의 프로퍼티이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.y) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(y) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문으로 정의한 전역 함수는 전역 객체의 프로퍼티이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.foo); <span class="comment">// f f00() &#123;&#125;</span></span><br><span class="line"><span class="comment">// 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// f foo() &#123;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>let 키워드로 선언한 전역변수는 전역 객체 window의 프로퍼티가 아니다. 즉 window.foo와 같이 접근할 수 없다.</p>
</li>
<li><p>let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 된다</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let, const 키워드로 선언한 전역변수는 전역 객체의 프로퍼티가 아니다</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-const-키워드"><a href="#3-const-키워드" class="headerlink" title="3. const 키워드"></a>3. const 키워드</h2><ul>
<li>const 키워드는 상수를 선언하기 위해 사용한다. 하지만 반드시 상수만을 위해 사용하지는 않는다.</li>
</ul>
<h3 id="3-1-선언과-초기화"><a href="#3-1-선언과-초기화" class="headerlink" title="3-1 선언과 초기화"></a>3-1 선언과 초기화</h3><ul>
<li>const 키워드로 선언한 변수는ㄴ 반드시 선언과 동시에 할당이 이루어 져야한다.</li>
<li>const 키워드로 선언한 변수는 let 키워드로 선언한 변수와 마찬가지로 블록레벨 스코프를 가지며 호이스팅이 발생하지 않는 것처럼 동작한다.</li>
</ul>
<h3 id="3-2-재할당-금지"><a href="#3-2-재할당-금지" class="headerlink" title="3-2 재할당 금지"></a>3-2 재할당 금지</h3><ul>
<li>var 또는 let 키워드로 선언한 변수는 재할당이 자유로우나 const 키워드로 선언한 변수는 재할당이 금지된다.</li>
</ul>
<h3 id="3-3-상수"><a href="#3-3-상수" class="headerlink" title="3-3 상수"></a>3-3 상수</h3><ul>
<li>const 키워드로 선언한 변수에 원시값을 할당한 경우, 변수값을 변경 할 수 없다.</li>
<li>원시값은 변경 불가능한 값 이므로 재할당 없이 값을 변경할 수 있는 방법이 없기 때문이다.</li>
<li>일반적으로 상수의 이름은 대문자로 선언하여 상수임을 명확이 나타낸다.</li>
<li>여러 단어로 이루어진 경우에는 언더스코어(_)로 구분하여 스네이크 케이스로 표현하는것이 일반적이다.</li>
<li><strong>const 키워드로 선언된 변수에 원시값을 할당한 경우, 원시값은 변경할수 없는 값이고 const키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.</strong></li>
</ul>
<h3 id="3-4-const-키워드와-객체"><a href="#3-4-const-키워드와-객체" class="headerlink" title="3-4 const 키워드와 객체"></a>3-4 const 키워드와 객체</h3><ul>
<li>const 키워드로 선언된 변수에 원시값을 할당한 경우, 값을 변경할 수 없다.</li>
<li><strong>const 키워드로 선언된 변수에 객채를 할당할 경우 값을 변경 할 수 있다.</strong></li>
<li>const 키워드는 재할당을 금지할 뿐 불변을 의미하지는 않는다.</li>
</ul>
<h2 id="4-var-vs-let-vs-const"><a href="#4-var-vs-let-vs-const" class="headerlink" title="4. var vs let vs const"></a>4. var vs let vs const</h2><ul>
<li>변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 팔요한 경우에 한정해 사용하는 것이 좋다.</li>
<li>원시값인 경우, 가급적 상수를 사용하는 편이 좋다.</li>
<li>객체를 재할당 하는 경우는 생각보다 크지 않음으로 const 키워드를 사용하면 의도치 않은 재할당을 방지해 준다.</li>
<li>var와 let, cont 키워드는 다음처럼 사용한다.<ul>
<li>ES5를 사용한다면 var 키워드는 사용하지 않는다.</li>
<li>재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.</li>
<li>변경이 발생하지 않고 읽기 전용으로 사용하는 원시값과 객체에는 const 키워드를 사용한다.(const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전하다)</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/02/29/%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4/%EC%A0%9C%EC%96%B4%EB%AC%B8%20%EC%97%B0%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/29/%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4/%EC%A0%9C%EC%96%B4%EB%AC%B8%20%EC%97%B0%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/" class="post-title-link" itemprop="url">제어문 연습문제</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-29 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-29T00:00:00+09:00">2020-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-01 00:00:00" itemprop="dateModified" datetime="2020-03-01T00:00:00+09:00">2020-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/" itemprop="url" rel="index">
                    <span itemprop="name">문제풀이</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="제어문-연습-문제"><a href="#제어문-연습-문제" class="headerlink" title="제어문 연습 문제"></a>제어문 연습 문제</h1><ol>
<li><p>변수 X가 10보다 크고 20보다 작을 때 변수 X를 출력하는 조건식을 완성하라.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span> &amp;&amp; x &lt; <span class="number">20</span>) <span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 문을 사용하여 0부터 10미만 정수 중에서 짝수만을 작은 수부터 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for문을 사용하여 0부터 10 미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) str += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 문을 사용하여 0부터 10 미만의 정수 중에서 홀수만을 큰 수부터 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">  i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while문을 사용하여 0부터 10 미만의 정수 중에서 홀수만을 큰 수부터 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">  i -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
</li>
<li><p>1부터 20미만의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((i % <span class="number">2</span>) &amp;&amp; (i % <span class="number">3</span>)) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
</li>
<li><p>1부터 20 미만의 정수 중에서 2또는 3의 배수인 수의 총합을 구하시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(i % <span class="number">2</span>) || !(i % <span class="number">3</span>)) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
</li>
<li><p>두개의 주사위를 전졌을 떄, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dice = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> fst = <span class="number">1</span>; fst &lt; <span class="number">7</span>; fst++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> scd = <span class="number">1</span>; scd &lt; <span class="number">7</span>; scd++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fst + scd === <span class="number">6</span>) <span class="built_in">console</span>.log(dice = [fst, scd]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>삼각형 출력하기 - pattern 1 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt;= vtl; hzt++) &#123;</span><br><span class="line">    tree += <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>삼각형 출력하기 - pattern 2</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">5</span>; hzt++) &#123;</span><br><span class="line">    tree += vtl &gt; hzt ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>삼각형 출력하기 - pattern 3</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">5</span>; vtl &gt; <span class="number">0</span>; vtl--) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; vtl; hzt++) &#123;</span><br><span class="line">    tree += <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>삼각형 출력하기 - pattern 4</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">5</span>; hzt++) &#123;</span><br><span class="line">    tree += (vtl + hzt &gt; <span class="number">3</span>) ? <span class="string">'*'</span> : <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>정삼각형 출력하기</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">9</span>; hzt++) &#123;</span><br><span class="line">    tree += ((hzt &gt; (<span class="number">4</span> + vtl)) || (hzt &lt; (<span class="number">4</span> - vtl))) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>역정삼각형 출력하기</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">9</span>; hzt++) &#123;</span><br><span class="line">    tree += ((hzt &lt; (<span class="number">0</span> + vtl)) || (hzt &gt; (<span class="number">8</span> - vtl))) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="3-1-추가"><a href="#3-1-추가" class="headerlink" title="3/1 추가"></a>3/1 추가</h4><ul>
<li><p>콜백함수 응용 정삼각형, 정역삼각형 logic 동시 구현</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tree</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">9</span>; hzt++) &#123;</span><br><span class="line">      f(vtl, hzt);</span><br><span class="line">    &#125;</span><br><span class="line">    sum += <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fw</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += ((h &gt; (<span class="number">4</span> + v)) || (h &lt; (<span class="number">4</span> - v))) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bw</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += ((h &lt; (<span class="number">0</span> + v)) || (h &gt; (<span class="number">8</span> - v))) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree(fw);</span><br><span class="line"><span class="comment">// 인수로 fw 입력 시 정삼각형, 인수로 bw 입력 시 정역삼각형 반환</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>콜백함수 응용 삼각형찍기 pattern1 ~ 4끼지 동시 구현</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tree</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">5</span>; hzt++) &#123;</span><br><span class="line">      f(vtl, hzt);</span><br><span class="line">    &#125;</span><br><span class="line">    sum += <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ptn1</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += (v &lt; h) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ptn2</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += (v &gt; h) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ptn3</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += (v + h &gt;= <span class="number">5</span>) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ptn4</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += (v + h &lt; <span class="number">4</span>) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line">tree(ptn1);</span><br><span class="line"><span class="comment">// 인수로 ptn1 ~ ptn4 입력 시 삼각형은 패턴에 맞게 출력됨</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/02/27/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-27%20%EC%98%88%EC%8A%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-27%20%EC%98%88%EC%8A%B5/" class="post-title-link" itemprop="url">JS 수업 예습/2020-02-27 예습</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-27 19:29:20" itemprop="dateCreated datePublished" datetime="2020-02-27T19:29:20+09:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-02 23:01:33" itemprop="dateModified" datetime="2020-03-02T23:01:33+09:00">2020-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="전역변수의-문제점"><a href="#전역변수의-문제점" class="headerlink" title="전역변수의 문제점"></a>전역변수의 문제점</h1><h2 id="1-변수의-생명-주기"><a href="#1-변수의-생명-주기" class="headerlink" title="1. 변수의 생명 주기"></a>1. 변수의 생명 주기</h2><h3 id="1-1-지역변수의-생명-주기"><a href="#1-1-지역변수의-생명-주기" class="headerlink" title="1-1 지역변수의 생명 주기"></a>1-1 지역변수의 생명 주기</h3><ul>
<li>변수는 생물과 유사하게 생성되고 소멸되는 생명 주기가 있음</li>
<li>변수에 생명 주기가 없다면 한번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유한다.</li>
<li>변수는 자신이 선언된 위치에서 생성되고 소멸한다.</li>
<li>전역변수의 생명 주기는 애플리케이션의 생명 주기와 같다</li>
<li>함수 내부에서 선언된 지역변수는 함수가 호출되면 생성되고 함수가 종료되면 소멸한다.</li>
</ul>
<p><strong>함수 내부에서 선언한 변수는 함수가 호출 된 직후에 함수 몸체의 다른 코드가 실행되기 전 자바스크립트 엔진에 의해 먼저 실행된다.</strong><br><strong>지역변수의 생명 주기는 함수의 생명 주기와 일치한다</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 함수 몸체 실행 전 변수 x 생성</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'local'</span>; <span class="comment">// 변수 x에 'local 값 할당'</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); </span><br><span class="line">  <span class="keyword">return</span> x; <span class="comment">// 변수 x 소멸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>호이스팅은 스코프를 단위로 동작한다.</strong></p>
<ul>
<li>전역변수의 호이스팅은 전역 전체에서 유효하지만, 지역변수의 호이스팅은 함수 내에서만 유효함</li>
</ul>
<h3 id="1-2-전역변수의-생명-주기"><a href="#1-2-전역변수의-생명-주기" class="headerlink" title="1-2 전역변수의 생명 주기"></a>1-2 전역변수의 생명 주기</h3><ul>
<li>함수와는 달리 전역 코드는 병시적인 호출 없이 실행된다.</li>
<li>전역 코드는 함수 호출과 같이 전역 코드를 실행하는 진입점이 없고 코드가 로드 되자마자 곧바로 해석되고 실행한다.<ul>
<li>진입점 : C나 Java로 작성된 코드를 실행하면 가장 먼저 main함수가 호출된다. 이 main함수는 프로그램이 시작되는 지점이므로 이를 진입점 또는 시작점 이라고 한다.</li>
</ul>
</li>
<li>함수는 함수 몸체의 마지막 문 또는 return문이 실행되면 종료한다.</li>
<li>전역 코드에는 return문을 사용할 수 없으므로 마지막 문이 실행되어 더이상 실행할 문이 없을 때 종료한다.<ul>
<li>return 문의 위치 : return문은 함수 내부에서만 사용할 수 있다. 전역에서 return문을 사용하면 문법에러가 발생한다. </li>
</ul>
</li>
<li>var 키워드로 선언한 전역변수는 전역 객체의 프로퍼티가 된다.(전역 변수의 생명 주기가 전역 객채의 생명 주기와 일치)<ul>
<li>전역객채 : 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체이다. 전역객채는 클라이언트 사이드 환경에서는 window, 서버사이드 환경에서는 global 객체를 의미한다.</li>
</ul>
</li>
<li>브라우저 환경에서 전역객체는 window이므로 브라우저 환경에서 var키워드로 선언한 전역변수는 전역객체 window의 프로퍼티 이다</li>
<li>var 키워드로 선언한 전역변수는 웹 페이지를 종료할 때까지 유효하다.</li>
<li><strong>즉 전역변수는 전역객체의 생명 주기와 일치한다</strong></li>
</ul>
<h2 id="2-전역변수의-문제점"><a href="#2-전역변수의-문제점" class="headerlink" title="2. 전역변수의 문제점"></a>2. 전역변수의 문제점</h2><p><strong>암묵적 결합</strong></p>
<ul>
<li>전역변수를 선언한 의도는 코드 어디에서든지 전여ㅑㄱ변수를 사용하겠다는 것이다.</li>
<li>이는 모든 코드가 전역변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것으로 변수 유효범위가 크면 클수록 코드의 가독성은 나빠지고 변경될 수 있는 위험성도 높아진가</li>
</ul>
<p><strong>긴 생명주기</strong></p>
<ul>
<li><em>전역변수는 생명 주기가 길다.</em></li>
<li>따라서 메모리 리소스도 오랜시간 소비한다</li>
<li>var 키워드는 변수의 중복 선언을 허용하므로 생명 주기가 긴 전역 변수는 변수 이름이 중복 될 가틍성이 있다.</li>
<li>지역변수는 전역변수보다 생명 주기가 훨씬 짧은 만큼 메모리 리소스도 짧은 기간만 소비한다.</li>
</ul>
<p><strong>스코프 체인 상에서 종점에 존재</strong></p>
<ul>
<li>전역 변수의 또하나의 문제는 스코프 체인 상에서 종점에 존재한다는 것이다.</li>
<li>이는 변수는 검색할 때 전역변수가 가장 마지막에 검색되는 것을 말한다.</li>
<li><em>즉 전역변수의 검색 속도가 가장 느리다</em></li>
</ul>
<p><strong>네임 스페이스 오염</strong></p>
<ul>
<li>자바스크립트에서 가장 큰 문제점 중의 하나는 파일이 분리되어 있다 하더라도 전역 스코프를 공유한다는 것이다.</li>
<li>다른 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.</li>
</ul>
<h2 id="3-전역변수-사용-억제-방법"><a href="#3-전역변수-사용-억제-방법" class="headerlink" title="3. 전역변수 사용 억제 방법"></a>3. 전역변수 사용 억제 방법</h2><p><strong>전역변수를 반드시 사용하여야 할 이유를 찾지 못한다면 지역변수를 사용하여야 한다. 변수의 스코프는 좁을수록 좋다</strong></p>
<h3 id="3-1-즉시-실행-함수"><a href="#3-1-즉시-실행-함수" class="headerlink" title="3-1 즉시 실행 함수"></a>3-1 즉시 실행 함수</h3><ul>
<li>함수의 정의와 동시에 호출되는 즉시 실행 함수는 단 한번만 호출된다.</li>
<li><strong>모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시실행함수의 지역 변수가 된다</strong></li>
</ul>
<h3 id="3-2-네임스페이스-객체"><a href="#3-2-네임스페이스-객체" class="headerlink" title="3-2 네임스페이스 객체"></a>3-2 네임스페이스 객체</h3><ul>
<li>전역에 <em>네임스페이스(Namespace)</em> 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;; <span class="comment">// 전역 네임 스페이스 객체</span></span><br><span class="line">MYAPP.name = <span class="string">'song'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(MYAPP.name); <span class="comment">// song</span></span><br></pre></td></tr></table></figure></li>
<li>네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로퍼티로 추가하여 네임 스페이스를 계층적으로 구성할 수도 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;; <span class="comment">// 전역 네임 스페이스 객체</span></span><br><span class="line"></span><br><span class="line">MYAPP.person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span>,</span><br><span class="line">  address: <span class="string">'paju'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(MYAPP.person.name); <span class="comment">// song</span></span><br></pre></td></tr></table></figure></li>
<li>네임 스페이스를 분리하여 식별자 충동을 방지하는 효과는 있으나 네임 스페이스 객체 자체가 전역변수에 할당되므로 그다지 유용하지 않다.</li>
</ul>
<h3 id="3-3-모듈-패턴"><a href="#3-3-모듈-패턴" class="headerlink" title="3-3 모듈 패턴"></a>3-3 모듈 패턴</h3><ul>
<li>모듈 패턴은 클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다.</li>
<li>모듈 패턴은 자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다.</li>
<li>모듈 패턴의 특징은 전역 변수의 억제는 물론 캡슐화 까지 구현할 수 있다</li>
<li>캡슐화는 외부에 공개될 필요가 없는 정보를 외부에 노출시키지 않고 숨기는 것을 말하며 정보 은닉이라고도 한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//private 변수</span></span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 외부로 공개할 데이터나 메소드를 프로퍼티로 추가한 객체를 반환한다.</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increase() &#123;</span><br><span class="line">      <span class="keyword">return</span> ++num;</span><br><span class="line">    &#125;,</span><br><span class="line">    decrease() &#123;</span><br><span class="line">      <span class="keyword">return</span> --num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="comment">// private 변수는 외부로 노출되지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter.num); <span class="comment">// undifined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Counter.increase()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter.increase()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter.decrease()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter.decrease()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위 예제의 즉시 실행 함수는 객체를 반환한다.</li>
<li>이 객체에는 외부에 노출하고 싶은 변수나 함수를 담아 반환한다.</li>
<li>이때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭멤버이다.</li>
<li>외부로 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않으면 외부에서 접근할 수 없는 프라이빗 멤버가 된다.</li>
</ul>
<h3 id="3-4-ES6-모듈"><a href="#3-4-ES6-모듈" class="headerlink" title="3-4 ES6 모듈"></a>3-4 ES6 모듈</h3><ul>
<li>전역변수의 남발을 억제하기 위해 ES6에서 도입된 모듈을 사용할 수도 있다. 모던 브라우저에서 ES6 모듈을 사용 할 수 있다.</li>
<li>script 태그에 type=”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다.</li>
<li>모듈의 확장자는 mjs를 권장한다.<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">sec</span>=<span class="string">"lib.mjs"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">sec</span>=<span class="string">"app.mjs"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/02/25/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-26%20%EC%98%88%EC%8A%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-26%20%EC%98%88%EC%8A%B5/" class="post-title-link" itemprop="url">JS 수업 예습/2020-02-26 예습</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-25 22:07:16" itemprop="dateCreated datePublished" datetime="2020-02-25T22:07:16+09:00">2020-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-02 23:01:33" itemprop="dateModified" datetime="2020-03-02T23:01:33+09:00">2020-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1></li>
</ol>
<ul>
<li>함수는 자바스크립트에서 가장 중요한 핵심 개념이다.</li>
<li>수학의 함수는 입력을 받아서 출력을 내보내는 일련의 과정을 정의한 것이다</li>
<li><em>함수는 일련의 과정을 문들로 구현하고 코드블록으로 감싸서 하나의 실행 단위로 정의한 것이다</em></li>
<li>함수 내부로 입력을 전달받는 변수를 <em>매개변수(parameter)</em> 입력을 <em>인수(argument)</em> 출력을 <em>반환값(return value)</em> 라고 한다</li>
<li>함수는 값이며 여러개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다</li>
<li>함수는 함수 정의(function definition)를 통해 생성된다<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123; <span class="comment">// add : 함수이름, (x, y) 매개변수</span></span><br><span class="line">  <span class="keyword">return</span> x + y; <span class="comment">// 반환값</span></span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 인수</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">- 함수 정의만으로 함수가 실행되지 않는다. 수학의 함수처럼 미리 정의된 일련의 과정을 실행하기 실행하기 위해 필요한 입력, 즉 인수를 매개변수를 통해 함수에게 전달하면서 함수의 실행을 명시적으로 지시해야한다.</span></span><br><span class="line"><span class="string">- 이를 함수 호출(Function call/invoke)이라 한다.</span></span><br><span class="line"><span class="string">- 함수를 호출하면 코드블록에 담긴 문들이 일괄적으로 실행되고 실행결과, 즉 반환값을 반환한다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 함수의 사용 이유</span></span><br><span class="line"><span class="string">- 함수는 필요할 때 여러번 호출할 수 있음</span></span><br><span class="line"><span class="string">- 동일한 작업을 반복적으로 수행해야 한다면 같은 코드를 중복해서 여러번 작성하는 것이 아니라 미리 정의된 함수를 재사용 하는 것이 효율적</span></span><br><span class="line"><span class="string">- 힘수는 몇번이든 호출 할 수 있으므로 _코드의 재사용_ 이라는 측면에서 유리함</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">2</span>;</span><br><span class="line">result = x + y; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">3</span>;</span><br><span class="line">y = <span class="number">4</span>;</span><br><span class="line">result = x + y; <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">5</span>;</span><br><span class="line">y = <span class="number">6</span>;</span><br><span class="line">result = x + y; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 위 코드를 아래와 같이 함수를 사용하면 중복을 제거하고 코드를 재사용 할 수 있음</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x , y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">result = add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">result = add(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 7</span></span><br><span class="line">result = add(<span class="number">5</span>, <span class="number">6</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><em>함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다</em></p>
<h2 id="1-함수-리터럴"><a href="#1-함수-리터럴" class="headerlink" title="1. 함수 리터럴"></a>1. 함수 리터럴</h2><ul>
<li>자바스크립트에서 함수는 객체 타입의 값임</li>
<li>함수 리터럴은 function 키워드, 함수이름, 매개변수 목록, 그리고 함수 몸체로 구성 됨</li>
</ul>
<p><em>함수 리터럴의 구성 요소</em></p>
<ul>
<li><p>함수이름</p>
<ul>
<li>함수 이름은 식병자 이다. 따라서 식별자 네이밍 규칙을 준수해야한다.</li>
<li>함수 이름은 함수 몸채 내에서만 참조할 수 있는 식별자 이다.</li>
<li>함수 이름은 생략 할 수 있다. 함수 이름이 있는 함수를 기명함수(named function), 함수 이름이 없는 함수를 익명 함수(anonymous function)이라 한다</li>
</ul>
</li>
<li><p>매개면수 목록</p>
<ul>
<li>0개 이상의 매개변수를 소괄호로 감싸고 쉽표로 구분한다.</li>
<li>매개변수에는 함수 호출문의 인수가 순서대로 할당된다. 즉 매개변수 목록은 순서에 의미가 있다</li>
<li>매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수 해야한다.</li>
</ul>
</li>
<li><p>함수몸체</p>
<ul>
<li>함수가 호출 되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드블록이다</li>
<li>함수 몸체는 함수 호출에 의해 실행된다</li>
</ul>
</li>
</ul>
<p><em>함수 리터럴은 값으로 평가될 수 있으며 이때 값은 객체대, 즉 함수는 객체다.</em><br><em>일반 객체는 호출 할 수 없지만 함수는 호출 할 수 있고 일반 객체에 없는 함수만의 고유한 프로퍼티를 갖음</em></p>
<h2 id="2-함수정의"><a href="#2-함수정의" class="headerlink" title="2. 함수정의"></a>2. 함수정의</h2><ul>
<li><p>함수 선언문(Function declaration/Function statement)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>함수 표현식(Function expression)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Function 생성자 함수 (Function constructor)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x + y'</span></span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>화살표 함수 (Arrow function) : ES6</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (x, y) ==&gt; x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="2-1-함수-선언문"><a href="#2-1-함수-선언문" class="headerlink" title="2-1 함수 선언문"></a>2-1 함수 선언문</h3><ul>
<li><p>함수 선언문을 사용하여 함수를 정의하는 방식은 아래와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//함수 참조</span></span><br><span class="line"><span class="comment">//console.dir은 console.log와는 달리 함수 객체의 프로퍼티 까지 출력한다(node.js 환경에서는 console.log와 같은 결과가 출력됨)</span></span><br><span class="line"><span class="built_in">console</span>.dir(add); <span class="comment">// f add(x, y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></li>
<li><p>함수 선언문은 함수 리터럴과 형태가 동일하다.</p>
</li>
<li><p>함수 리터럴은 함수 이름을 생략 할 수 있으나 <em>함수 선언문은 함수 이름을 생략 할 수 없다.</em></p>
</li>
<li><p>함수 선언문은 표현식이 아닌 문이다.(크롬 개발자 도구에서 함수 선언물을 실행하면 완료값으로 undefined를 출력한다.)</p>
</li>
<li><p>함수 선언문이 만약 표현식인 문이라면 완료값 undefined 대신 표현식이 평가되어 생성된 함수가 출력 되어야 함</p>
</li>
<li><p>표현식이 아닌 문은 변수에 할당 할 수 없으나 함수 선언문은 변수에 할당 되는 것 처럼 보인다</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문을 변수에 할당</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">//7</span></span><br></pre></td></tr></table></figure></li>
<li><p>자바스크립트 엔진은 함수 이름이 있는 함수 럴을 단독으로 사용하면 함수 리터럴로 해석</p>
</li>
<li><p>변수에 할당하거나 피연산자로 사용하면 함수 리터럴 표현식으로 해석한다</p>
</li>
</ul>
<h3 id="2-2-함수-표현식"><a href="#2-2-함수-표현식" class="headerlink" title="2-2 함수 표현식"></a>2-2 함수 표현식</h3><ul>
<li>자바스크립트 함수는 값처럼 변수에 할당 할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다.</li>
<li>이처럼 값의 성질을 갖는 객채를 일급객체라고 한다. 자바스클비트 함수는 일급 객체이다.</li>
<li>일급 객체라고 하는것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다</li>
<li>함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당 할 수 있다.(함수 표현식)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></li>
<li>함수 리터럴의 함수 이름은 생략할 수 있다. 이러한 함수를 익명함수라 한다.</li>
<li>함수 표현식의 함수 리터럴은 이름을 생략하는것이 일반적이다.</li>
<li>자바스크립트 엔진은 함수 선언문의 함수 이름으로 식별자를 암묵적 생성하고 생성된 함수 객체를 할당하므로 함수 표현식과 유사하게 동작하는것 처럼 보인다.</li>
<li>함수 선언문은 표현식이 아닌 문이고 함수 표현식은 표현식인 문이다.</li>
</ul>
<h3 id="2-3-함수-생성-시점과-호이스팅"><a href="#2-3-함수-생성-시점과-호이스팅" class="headerlink" title="2-3 함수 생성 시점과 호이스팅"></a>2-3 함수 생성 시점과 호이스팅</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 참조</span></span><br><span class="line"><span class="built_in">console</span>.dir(add); <span class="comment">//f add(x, y)</span></span><br><span class="line"><span class="built_in">console</span>.dir(sub); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> sub = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다</li>
<li>함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출 할 수 없다</li>
<li>이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.</li>
<li>함수 선언문으로 함수를 정의하면 럴타임 이전에 함수 객체가 먼저 생성된다. 그리고 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 생성하고 생성된 함수 객체를 할당한다.</li>
<li><em>함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅 이라고 한다</em></li>
<li>함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화 된다</li>
<li>변수 할당운의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.</li>
<li>함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아닌 변수 호이스팅이 발생한다</li>
</ul>
<h3 id="2-4-Function-생성자-함수"><a href="#2-4-Function-생성자-함수" class="headerlink" title="2-4 Function 생성자 함수"></a>2-4 Function 생성자 함수</h3><ul>
<li>자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new연산자와 함께 호출하면 객체를 생성하여 반환한다</li>
<li>생성자 함수 : 생성자 함수는 샛체를 생성하는 함수를 말한다. 객체를 생성하는 방식은 객체 리터럴 이외에 다양한 방법이 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x + y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span> + <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Function 생성자 함수는 일반적이지 많으며 바람직 하지도 않다.</li>
<li>Function 생성자 함수로 생성한 함수는 클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.</li>
</ul>
<h3 id="2-5-화살표-함수"><a href="#2-5-화살표-함수" class="headerlink" title="2-5 화살표 함수"></a>2-5 화살표 함수</h3><ul>
<li>ES6에서 새롭게 도입된 화살표 함수는 funtion 키워드 대신 화살표 (=&gt;, Fat arrow)를 사용하여 보다 간략한 방법으로 함수를 선언할 수 있다. </li>
<li>화살표 함수는 항상 익명함수로 정의한다</li>
<li>화살표 함수는 기존의 함수보다 표현이 간략한 것이 아니라 동작 또한 간략화 되어있다.</li>
<li>화살표 함수는 생성자 함수로 사용할 수 없으며 기존의 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments객체를 생성하지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//화살표함수</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x , y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-함수호출"><a href="#3-함수호출" class="headerlink" title="3. 함수호출"></a>3. 함수호출</h2><ul>
<li>함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.</li>
<li>함수 호출 연산자 내에는 0개 이상의 인수를 수비표로 구분하여 나열한다.</li>
<li>함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 컨트롤을 넘긴다.</li>
<li>이떄 매개면수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행되기 시작한다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//함수 호출</span></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 인수 1과 2는 매개변수 x, y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-매개변수와-인수"><a href="#3-1-매개변수와-인수" class="headerlink" title="3-1 매개변수와 인수"></a>3-1 매개변수와 인수</h3><ul>
<li>매개변수는 함수를 정의할 때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급됨</li>
<li>함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 undefined로 초기화 된 이후 인수가 순서대로 할당된다</li>
<li>매개변수 는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다.</li>
<li>함수는 매개변수의 인수와 개수를 체크하지 않는다. </li>
<li>인수가 부족하여 인수가 할당되지 않은 매개변수의 값은 undefined이다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>)); <span class="comment">// 매개변수 y에 전달할 값이 없어 undefined가 되며 산술연산 불가로 NaN</span></span><br></pre></td></tr></table></figure>
<ul>
<li>초과된 인수는 그냥 버러지는 것이 아니다. 모든 인수는 암묵적으로 argunments객체의 프로퍼티로 보관된다.</li>
<li>argunments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용 됨</li>
</ul>
<h3 id="3-2-인수-확인"><a href="#3-2-인수-확인" class="headerlink" title="3-2 인수 확인"></a>3-2 인수 확인</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 위 함수를 정의한 개발자의 의도는 아마 2개의 숫자 타입의 인수를 전달받아 그 합계를 반환하려는 것으로 추측 됨</span></span><br><span class="line"><span class="comment">// 하지만 코드 상으로 어떤 타입의 인수를 전달하여야 하는지 어떤 타입의 값을 반환해야 하는지 명확하지 않음</span></span><br><span class="line"><span class="comment">// 따라서 위 함수는 아래와 같이 호출 될 수 있음</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">'a'</span>, <span class="string">'b'</span>)) <span class="comment">// ab</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위 코드는 자바스크립트 문법상 어떠한 문제도 없으므로 자바스크립트 엔진은 아무런 이의 제기없이 위 코드를 실핼 할 것이다.</li>
<li>이러한 상황이 발생한 이유는 아래와 같기 때문에 함수를 정의할 때 인수가 전달 되었는지 확인이 필요하다<ol>
<li>자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.</li>
<li>자바스크립트 함수는 매개변수의 타입을 사전에 지정 할 수 없다.</li>
</ol>
</li>
</ul>
<h3 id="3-3-매개변수의-최대-개수"><a href="#3-3-매개변수의-최대-개수" class="headerlink" title="3-3 매개변수의 최대 개수"></a>3-3 매개변수의 최대 개수</h3><ul>
<li>ECMAScript 사양에서는 매개변수의 최대 개수에 대해 명시적으로 제한하고 있지 않다.</li>
<li>하지만 물리적 한계는 있으므로 자바스크립트 엔진 마다 매개변수의 최대 개수에 대한 제한이 있겠지만 충분히 많은 매개변수를 지정 할 수 있다</li>
<li>매개변수는 순서에 의미가 있다. </li>
<li>매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야한다.</li>
<li>함수의 매개변수는 코드 이해에  방해가 되는 요소이므로 이상적인 매개변수 개수는 0개이며 적을수록 좋다.</li>
</ul>
<h3 id="3-4-반환문"><a href="#3-4-반환문" class="headerlink" title="3-4 반환문"></a>3-4 반환문</h3><ul>
<li>함수는 <code>return</code>키워드와 반환값으로 이루어진 반환문을 사용하여 실행 결과를 함수 외부로 반환 할 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y; <span class="comment">// 값으 반환</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 반환 값으로 평가 됨</span></span><br><span class="line"><span class="keyword">var</span> result = multiply(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></li>
<li>위 예제 중 multiply함수는 두개의 인수를 전달 받아서 곱한 결과값을 반환한다. </li>
<li>반환값은 return 키워드를 사용해 반환한다.</li>
<li>함수는 return키워드를 사용해 자바스크립트에서 사용 가능한 모든 값을 반환할 수 있다.</li>
<li>함수 호출은 표현식이다, 이때 함수 호출 표현식은 return키워드가 반환한 값으로 평가된다.</li>
<li>반환문은 두가지 역할을 한다<ol>
<li>반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.</li>
<li>반환문은 return키워드 뒤에 지정한 값을 반환한다. return키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다.</li>
</ol>
</li>
<li>함수는 반환문을 생략 할 수 있다. 이때 함수는 함수 몸에의 마지막 문까지 실행한 후 암묵적으로 undefined를 반환한다.</li>
<li>return 키워드와 반환값 사이에 줄바꿈이 있으면 세미콜론 자동 삽입 기능에 의해 세미콜론이 추가되어 의도치 않은 결과가 발생할 수 있다.</li>
</ul>
<h2 id="4-참조에-의한-전달과-외부-상태의-변경"><a href="#4-참조에-의한-전달과-외부-상태의-변경" class="headerlink" title="4. 참조에 의한 전달과 외부 상태의 변경"></a>4. 참조에 의한 전달과 외부 상태의 변경</h2><ul>
<li>원시값은 값에의한 전달(pass by value), 객체는 참조에 의한 전달(pass by reference) 방식으로 동작한다</li>
<li>매개변수도 함수 몸체 내부에서 변수와 동일하게 취급 되므로 매개변수 또한 타입에 따라 값에의한 전달, 참조의 의한 전달 방식을 그대로 따른다</li>
<li>함수의 매개변수에 값을 전달하는 방식을 값에의한 호출(call by value), 참조에 의한 호출(call by reference)로 구별해 부르는 경우도 있으나 동작 박식은 값에 의한 전달, 참조에 의한 전달과 동일하다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeVal</span>(<span class="params">primitive, obj</span>) </span>&#123;</span><br><span class="line">  primitive += <span class="number">100</span>;</span><br><span class="line">  obj.name = <span class="string">'yong'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 외부상태</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">'song'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name : "song" &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복가되어 전달된다</span></span><br><span class="line">changeVal(num, person); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 원시값은 원본이 훼손되지 않는다</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체는 원본이 훼손된다</span></span><br><span class="line"><span class="built_in">console</span>. log(person); <span class="comment">// &#123; name : "yong" &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위 예제 중 changeVal 함수는 매개변수를 통해 전달받은 원시타입 인수와 객체타입 인수를 몸체에서 변경한다.</li>
<li>원시타입 인수를 전달받은 매개변수 primitive의 경우, 원시값은 변경 불가능한 값 이므로 직접 변경할 수 없기 때문에 재할당을 통해 원시값을 새로운 원시값으로 교체함</li>
<li>객체 타입의 인수를 전달받은 매개변수 obj의 경우 객체는 변경 가능한 값이므로 직접 변경할 수 있기 때문에 재할당 없이 직접 할당된 객체를 변경함</li>
</ul>
<h2 id="5-다양한-함수의-형태"><a href="#5-다양한-함수의-형태" class="headerlink" title="5. 다양한 함수의 형태"></a>5. 다양한 함수의 형태</h2><h3 id="5-1-즉시-실행-함수"><a href="#5-1-즉시-실행-함수" class="headerlink" title="5-1 즉시 실행 함수"></a>5-1 즉시 실행 함수</h3><ul>
<li>함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 함</li>
<li>즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수 없음</li>
<li>즉시 실행 함수는 함수 이름이 없는 익명함수를 사용하는것이 일반적임</li>
<li>즉시 실행 함수는 반드시 그룹 연산자 (…)로 감싸주어야 한다</li>
<li>그룹 연산자의 피연산자는 값으로 평가되므로 기명 또는 무명 함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다</li>
<li>그룹 연산자로 함수를 묶는 이유는 먼저 함수를 평가하여 함수 객체를 생성하기 위함이다</li>
<li>즉시 실행 함수도 일반 함수처럼 값을 반환 할 수 있고 전달할 수도 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 익명 즉시 실행 함수</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//기명 즉시 실행 함수</span></span><br><span class="line"><span class="comment">// 그룹 연산자 (...) 내의 기명 함수는 함수 선언문이 아니라 함수 리터럴로 평가되며 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자 이므로 즉시 실행 함수를 호출할 수 없다</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// referenceError</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-2-재귀-함수"><a href="#5-2-재귀-함수" class="headerlink" title="5-2 재귀 함수"></a>5-2 재귀 함수</h3><ul>
<li>함수가 자기 자신을 호출하는 것을 재귀호출(recursive call)이라 한다.</li>
<li>재귀 함구는 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 팩토리얼(계승)은 1부터 짜신까지의 모든 양의 정수의 곱이다.</span></span><br><span class="line"><span class="comment">// n! = 1 * 2 * ... * (n-1) * n</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 탈출 조건 : n이 1이하일 때 재귀 호출을 멈춘다</span></span><br><span class="line">  <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 재귀호출</span></span><br><span class="line">  <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">0</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">4</span>)); <span class="comment">// 24</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure></li>
<li>재귀 함수는 자신을 무한 재귀 호출한다.</li>
<li>따라서 재귀 함수 내에는 재귀 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다.</li>
<li>factorial 함수 내부에서 자기 자신을 호출 할 때 사용한 식별자 factorial은 함수 이름이다.</li>
<li>함수 이름은 함수 몸체 내부에서만 유효하다. 따라서 함수 내부에서는 함수 이름을 사용하여 자기 자신을 호출 할 수 있다</li>
<li>함수 표현식으로 정의한 함수 내부에서는 함수 이름은 물론 함수를 가리키는 식별자로도 자기 자신을 재귀 호출할 수 있다.</li>
<li>단, 함수 호출은 반드시 함수를 가리키는 식별자로 해야한다.</li>
</ul>
<h3 id="5-3-중첩함수"><a href="#5-3-중첩함수" class="headerlink" title="5-3 중첩함수"></a>5-3 중첩함수</h3><ul>
<li>함수 내부에 정의된 함수를 중첩함수 또는 내부함수라 한다.</li>
<li>중첨함수를 포함하는 함수는 외부함수라 부른다.</li>
<li>일반적으로 중첩함수는 자신을 포함하는 외부함수를 돕는 헬퍼 함수의 역할을 한다.</li>
<li>ES6부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하다.</li>
<li>호이스팅으로 인해 혼란이 발생 랑 수 있으므로 if문이나 for문 등의 코드블록에서 함수를 정의하는것은 바람직하지 않다</li>
</ul>
<h3 id="5-4-콜백-함수"><a href="#5-4-콜백-함수" class="headerlink" title="5-4 콜백 함수"></a>5-4 콜백 함수</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n만큼 어떤 일을 반복한다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//i를 출력한다</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">repeat(<span class="number">5</span>); <span class="comment">// 0, 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>repeat함수는 매개변수를 통해 전달받은 숫자만큼 반복하며 console.log(i)를 호출한다. </li>
<li>이때 repeat함수는 console.log(i)에 강하게 의존하고 있어 다른 일을 할 수 없다</li>
<li>따라서 repeat함수의 반복문 내에서 다른 일을 하고 싶다면 함수를 새롭게 정의해야한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">n, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// i를 전달하면서 f를 호출  </span></span><br><span class="line">    f(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logAll = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다.</span></span><br><span class="line">repeat(<span class="number">5</span>, logAll); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logOdds = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다</span></span><br><span class="line">repeat(<span class="number">5</span>, logOdds); <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>위 repeat 함수는 경우에 따라 변경되는 일을 함수 f로 추상화 하고 이를 외부에서 전달 받는다</li>
<li>자바스크립트의 함수는 일급 객체이므로 함수의 매개변수를 통해 함수를 전달할 수 있다.</li>
<li>이처럼 함구의 매개변수를 통해 전달되는 함수를 콜백 함수라고 하며, 콜백 함수를 매개변수를 통해 전달받은 함수를 고차함수 하고 한다.</li>
<li>중첩 함수가 외부 함수를 돕는 헬퍼 함수의 역할을 하는 것처럼 콜백 함수도 고차 함수에 전달되어 헬퍼 함수의 역할을 한다.</li>
<li>단 중첩 함수는 고정되어 있어서 교체하기 곤란하지만 콜백함수는 함수 외부에서 고차함수 내부로 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있음.</li>
<li>고차함수는 콜백 함수를 자신의 일부분으로 합성한다.</li>
<li>고차함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정하여 호출한다.</li>
<li>콜백 함수는 고차 함수에 의해 호출되며 이때 필요에 따라 인수도 전달 될 수 있다.</li>
<li>고차 함수에 콜백 함수를 전달 할 때 콜백 함수를 호출하지 않고 함수 자체를 전달해야 한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 콜백 함수가 고차 함수 내부에만 호출 된다면 콜백함수를 익명 함수 리터럴로 정의하면서 곧바로 고차함수에 전달하는것이 일반적임</span></span><br><span class="line">repeat(<span class="number">5</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>이때 콜백 함수로써 전달된 함수 리터럴은 고차함수가 호출 될 때마다 평가되어 함수 객체를 생성한다.</li>
<li>콜백 함수를 다른 곳에서도 호출할 필요가 있거나, 콜백 함수를 전달받는 함수가 자주 호출 된다면 함수 외부에서 콜백 함수를 정의한 후 함수 참조를 고차 함수에 전달하는 편이 효율적이다</li>
<li>콜백 함수는 일반적으로 비동기처리를 위해 사용하는 중요한 패턴이다</li>
</ul>
<h3 id="5-5-순수-함수와-비순수-함수"><a href="#5-5-순수-함수와-비순수-함수" class="headerlink" title="5-5 순수 함수와 비순수 함수"></a>5-5 순수 함수와 비순수 함수</h3><ul>
<li>함수형 프로그래밍 에서는 어떤 외부 상태에 의존하지도 않고 변경 시키지도 않는, 즉 부수효과가 없는 함수를 순수 함수하고 부르고, 외부 상태를 변경(부수효과)가 있는 함수를 비순수 함수라고 부른다.</li>
</ul>
<h4 id="순수함수"><a href="#순수함수" class="headerlink" title="순수함수"></a>순수함수</h4><ul>
<li>순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수를 말한다.</li>
<li>순수 함수는 어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 반환값을 만든다.</li>
<li>함수의 외부 상태에 의존하는 함수는 외부 상태에 따라 반환값이 달라진다.</li>
<li>순수 함수는 함수 외부상태를 변경하지 않는다<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>; <span class="comment">// 현재 카운트를 나타내는 상태</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 외부상태에 의존하지 않으며 변경하지도 않는 순수함수</span></span><br><span class="line"><span class="comment">// 순수함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 순수 함수가 반환한 결과값을 변수에 재할당 하여 상태를 변경</span></span><br><span class="line">count = increase(count);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">count = increase(count);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="비순수함수"><a href="#비순수함수" class="headerlink" title="비순수함수"></a>비순수함수</h4><ul>
<li>함수 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 함수를 비순수 함수라고 한다.</li>
<li>비순수 함수는 순수 함수와는 달리 외부 함수의 상태를 변경시키는 부수효과가 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>; <span class="comment">// 현재 카운트를 나타내는 상태 : increase 함수에 의해 변화한다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 외부 상태에 의존하여 외부 상태에 따라 변환값이 달라지는 비순수 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++count; <span class="comment">// 외부 상태를 변경한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 비순수 함수는 외부 상태를 변경하므로 상태 변화를 추적하기 어려워진다</span></span><br><span class="line">increase();</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">increase();</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><em>함수형 프로그래밍은 변수의 사용을 억제하여 상태 변경을 최소화 하고 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하려는 프로그래밍 패러다임</em></p>
<h1 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h1><h2 id="1-스코프란"><a href="#1-스코프란" class="headerlink" title="1. 스코프란?"></a>1. 스코프란?</h2><ul>
<li>스코프(Scope, 유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이고 중요한 개념임</li>
<li>var 키워드로 선언한 변수와 let 또는 const 키워드로 선언한 변수의 스코프도 다르게 동작함</li>
<li>함수의 매개변수가 함수 몸체 내부에서만 참조할수 있는 것은 매개변수의 스코프가 함수 몸체 내부로 한정되기 때문이다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.</span></span><br><span class="line">  <span class="comment">// 즉 매개변수의 스코프는 함수 몸체 내부이다</span></span><br><span class="line">  <span class="built_in">console</span>.log(x, y); <span class="comment">// 2 5</span></span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//매개변수는 함수 몸체 내부에서만 함조할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(x, y); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure></li>
<li>변수는 코드의 가장 바깥 영역 뿐만 아니라 코드 블록이나 함수 몸체 내에서도 선언 할 수 있다.</li>
<li>이때 코드 블록이나 함수는 중첩될 수 있다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> var1 = <span class="number">1</span>; <span class="comment">// 코드의 가장 바깥 영역에서의 선언</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> var2 = <span class="number">2</span>; <span class="comment">//코드블록 내에서 선언된 변수</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> var3 = <span class="number">3</span>; <span class="comment">//중첩된 코드블럭 내에서 선언된 번수</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> var4 = <span class="number">4</span>; <span class="comment">// 함수 내에서 선언된 변수</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> var5 = <span class="number">5</span>; <span class="comment">// 중첩된 함수 내에서 선언된 변수</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(var1); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(var2); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(var3); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(var4); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="built_in">console</span>.log(var5); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<ul>
<li>변수는 자신이 선언된 위치에 의해 자신이 유효한 번위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정된다.</li>
<li>변수 뿐만 아니라 모든 식별자가 그렇다</li>
<li>모든 식별자(변수이름, 함수이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정된다. 이를 스코프라 한다</li>
<li>즉, 스코프는 식별자가 유효한 범위를 말한다</li>
<li>스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙 이하고도 할 수 있다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'local'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// "local"</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// "global"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위 예제에서 코드의 가장 바깥 영역에 선언된 변수 x는 어디서든 참조할 수 있다.</li>
<li>하지만 foo 내부에서 선언된 변수 x는 함수 foo내부에서만 참조 할 수 있고 foo 외부에서는 참조할 수 없다.</li>
<li>이때 두개의 변수 x는 식별자 이름이 동일하지만 자신이 유효한 범위, 즉 스코프가 다른 별개의 변수이다.</li>
</ul>
<h2 id="2-스코프의-종류"><a href="#2-스코프의-종류" class="headerlink" title="2. 스코프의 종류"></a>2. 스코프의 종류</h2><ul>
<li>코드는 전역(global)과 지역(local)으로 구분할 수 있다.</li>
<li>전역 : 코드의 가장 바깥 영역 : 전역스코프 : 전역변수</li>
<li>지역 : 함수 몸체 내부 : 지역스코프 : 지역변수</li>
<li>이때 변수는 자신이 선언된 위치에 의해 자신이 유효한 범위인 스코프가 결정된다.</li>
<li>전역에서 선언된 변수는 전역 스코프를 갖는 전역변수이고, 지역에서 선언된 변수는 지역 스코프를 같는 지역 변수이다</li>
</ul>
<h3 id="2-1-전역과-전역-스코프"><a href="#2-1-전역과-전역-스코프" class="headerlink" title="2-1 전역과 전역 스코프"></a>2-1 전역과 전역 스코프</h3><ul>
<li>전역이란 코드의 가장 바깥 영역을 말한다.</li>
<li>전역은 전역 스코프를 만든다.</li>
<li>전역에 변수를 선언하면 전역 스코프를 갖는 전역변수가 된다.</li>
<li><em>전역 변수는 어디서든지 참조할 수 있다</em></li>
<li>전역 변수는 어디서든지 참조할 수 있으므로 함수 내부에서도 참조 할 수 있다.</li>
</ul>
<h3 id="2-2-지역과-지역-스코프"><a href="#2-2-지역과-지역-스코프" class="headerlink" title="2-2 지역과 지역 스코프"></a>2-2 지역과 지역 스코프</h3><ul>
<li>지역이란 함수 몸체 내부를 말한다.</li>
<li>지역은 지역 스코프를 만든다.</li>
<li>지역 변수는 자신이 선언된 지역과 하위 지역에서만 참조할 수 있다.</li>
<li>지역변수는 자인의 지역 스코프와 하위 지역 스코프에서 유효하다.</li>
</ul>
<h2 id="3-스코프체인"><a href="#3-스코프체인" class="headerlink" title="3. 스코프체인"></a>3. 스코프체인</h2><ul>
<li><p>함수는 전역에서 정의할 수도 있고 함수 몸체 내부에서 정의할 수도 있다.</p>
</li>
<li><p>함수 몸체 내부에서 함수가 정의된 것을 함수의 중첩이라 한다</p>
</li>
<li><p>함수 몸체 내부에서 정의한 함수를 중첩함수, 중첩함수를 포함하는 함수를 외부함수 라고 한다.</p>
</li>
<li><p>함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다.</p>
</li>
<li><p>이는 스코프는 함수의 중첩에 의해 계층적 구조를 갖는다는것을 의미한다.</p>
</li>
<li><p>중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 계층적 구조를 갖는다.</p>
</li>
<li><p>이때 외부 함수의 지역 스코프를 중첩함수의 상위 스코프라고 한다.</p>
</li>
<li><p>모든 스코프는 하나의 계층적 구조로 연결되며 모든 지역 스코프의 최상위 스코프는 전역 스코프이다.</p>
</li>
<li><p>이렇게 스코프가 계층적으로 연결된 것을 스코프 쳬인이라 부른다.</p>
</li>
<li><p>변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시자가하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.</p>
</li>
</ul>
<h3 id="3-1-스코프-체인에-의한-변수-검색"><a href="#3-1-스코프-체인에-의한-변수-검색" class="headerlink" title="3-1 스코프 체인에 의한 변수 검색"></a>3-1 스코프 체인에 의한 변수 검색</h3><ul>
<li>스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.</li>
<li>상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다</li>
</ul>
<h3 id="3-2-스코프-체인에의한-함수-검색"><a href="#3-2-스코프-체인에의한-함수-검색" class="headerlink" title="3-2 스코프 체인에의한 함수 검색"></a>3-2 스코프 체인에의한 함수 검색</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'golobal function foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'local function foo'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  foo(); <span class="comment">// (1)</span></span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<ul>
<li>함수 선언문으로 함수를 정의하면 자바스크립트 엔진에 의해 다른 코드가 실행되기 전에 함수 객체가 먼저 생성된다.</li>
<li>그리고 자바스크립트 엔진은 함수 이름과 동일한 이름의 변수를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.</li>
<li>따라서 위 예제의 모든 함수는 자바 스크립트 엔진에 의해 암묵적으로 선언된 함수 이름과 동일한 이름의 변수에 할당된다.</li>
<li>(1) 에서 함수 foo를 호출하면 자바스크립트 엔진은 함수를 호출하기 위해 먼저 함수를 가리키는 변수 foo를 검색한다.</li>
<li>이처럼 함수도 변수에 할당되기 때문에 스코프를 갖는다.</li>
<li>함수는 변수에 함수 객체가 할당되는것 외에는 일반 변수와 다를바가 없다.</li>
<li>따라서 변수를 검색할 때 사용하는 규칙 이라기 보다 식별자를 검색하는 규칙이라고 표현하는것이 보다 더 적합하다.</li>
</ul>
<h2 id="4-함수-레벨-스코프"><a href="#4-함수-레벨-스코프" class="headerlink" title="4. 함수 레벨 스코프"></a>4. 함수 레벨 스코프</h2><ul>
<li>지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다</li>
<li>이는 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다는 의미다.</li>
<li>c, java등 대부분의 프로그래밍 언어는 함수 몸체 만이 아니라 모든 코드블록이 이력 스코프를 만든다</li>
<li>이러한 특성을 블록레벨 스코프라고 한다</li>
<li>하지만 var키워드로 선언된 변수는 오로지 함수의 코드블록만을 지력 스코프로 인정한다. 이러한 특성을 함수레벨 스코프라고 한다.</li>
<li>let, const키워드는 블록레벨 스코프를 지원한다.</li>
</ul>
<h2 id="5-렉시컬-스코프"><a href="#5-렉시컬-스코프" class="headerlink" title="5. 렉시컬 스코프"></a>5. 렉시컬 스코프</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line">bar(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>위 예제 싱행 결과는 함수 bar의 상위 스코프가 무엇인지에 따라 결정된다. 두가지 패턴을 예측할 수 있다</p>
<ol>
<li>함수를 어디러 호출했는지에 따라 함수의 상위 스코프를 결정한다</li>
<li>함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.</li>
</ol>
</li>
<li><p>첫번쨔 방식으로 함수의 상위 스코프를 결정한다면 함수 bar의 상위 스코프는 삼수 foo와 전역일 것이다</p>
</li>
<li><p>두번째 방식으로 함수의 상위 스코프를 결정한다면 함수 bar의 상위 스코프는 전역일 것이다</p>
</li>
<li><p>프로그래밍 언어는 일반적으로 이 두가지 방식 중 하나의 방식으로 함수의 상위 스코프를 결정한다.</p>
</li>
<li><p>첫번째 방식을 동적 스코프라 한다.</p>
</li>
<li><p>함수가 어디서 호출 될 지 알수 없다</p>
</li>
<li><p>함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 동적 스코프라 부른다.</p>
</li>
<li><p>두번째 방식을 렉시컬 스코프라 한다.</p>
</li>
<li><p>함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프라 부른다.</p>
</li>
</ul>
<p><em>자바스크립트는 렉시클 스코프를 따른다</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/02/24/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-24%20%EC%98%88%EC%8A%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/24/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-24%20%EC%98%88%EC%8A%B5/" class="post-title-link" itemprop="url">JS 수업 예습/2020-02-24 예습</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-24 18:50:18" itemprop="dateCreated datePublished" datetime="2020-02-24T18:50:18+09:00">2020-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-02 22:43:22" itemprop="dateModified" datetime="2020-03-02T22:43:22+09:00">2020-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="타입변환"><a href="#타입변환" class="headerlink" title="타입변환"></a>타입변환</h1><ul>
<li><p>명시적 타입변환 : 개발자가 의도적으로 값의 타입을 변환하는 것(타입 캐스팅)</p>
</li>
<li><p>암묵적 타입변환 : 개발자가 의도하지 않았지만 자바스크립트 엔진에 의해 암묵적으로 타입이 자동변환 되는 것(타입 강제전환)</p>
</li>
<li><p>타입 변환 시 기존의 원시값은 변하지 않고 기존 원시값을 이용해 다른 타입의 원시값을 새로 생성함</p>
</li>
<li><p>암묵적 타입 변환은 변수의 값을 재할당 하는 것이 아닌 새로운 값을 만들어 단 한번만 사용하고 버림(자바스크립트 엔진이 표현식을 예러 없이 평가하기 위함)</p>
</li>
</ul>
<h2 id="1-암묵적-타입변환"><a href="#1-암묵적-타입변환" class="headerlink" title="1. 암묵적 타입변환"></a>1. 암묵적 타입변환</h2><ul>
<li>자바스크립트 엔진은 개발자의 의도와 상관 없이 코드의 문맥을 고려하여 암묵적으로 데이터 값을 강제 변환한다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'10'</span> + <span class="number">2</span> --&gt; 숫자 <span class="number">2</span>가 문자열 <span class="string">'2'</span>로 암묵적 타입 변환되어 문자열 <span class="string">'102'</span> 가 됨</span><br><span class="line"><span class="comment">//'10'이 문자열 이므로 자바스크립트 엔진이 2를 문자열로 기대함</span></span><br><span class="line"><span class="number">5</span> * <span class="string">'10'</span> --&gt; 문자열 <span class="string">'10'</span>이 숫자 <span class="number">10</span>으로 암묵적 타입 변환 되어 <span class="number">50</span>이 됨</span><br><span class="line"><span class="comment">// * 연산자의 피연산자는 숫자만 해당 되므로 문자열 '10'을 숫자 10으로 타입 변환 함</span></span><br><span class="line">!<span class="number">0</span> --&gt; 숫자 <span class="number">0</span>이 불린값 <span class="literal">false</span> 로 타입 변환 하여 <span class="literal">true</span> 가 됨</span><br><span class="line"><span class="comment">// ! 연산자는 피연산자가 불린값만 해당하므로 숫자 0을 false로 암묵적 타입 변환 함</span></span><br></pre></td></tr></table></figure>

<h3 id="1-1-문자열-타입으로-변환"><a href="#1-1-문자열-타입으로-변환" class="headerlink" title="1-1 문자열 타입으로 변환"></a>1-1 문자열 타입으로 변환</h3><ul>
<li>자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가 할 때 문자열이 아닌 피연산자가 있다면 문자열로 암묵적 타입 변환 한다</li>
<li>문자열 타입이 아닌 값을 문자열로 표기할 때 <code>값 + &#39;&#39;</code>로 공백 문자열을 문자열 연결 연산자를 통해 연결하면 기존 값이 문자열 값으로 암묵적 타입 변환 된다. (symbol type은 type error 발생)</li>
</ul>
<h3 id="1-2-숫자-타입으로-변환"><a href="#1-2-숫자-타입으로-변환" class="headerlink" title="1-2 숫자 타입으로 변환"></a>1-2 숫자 타입으로 변환</h3><ul>
<li>-, *, / 등 산술연산자나 비교 연산자의 피연산자는 문맥상 모두 숫자여야 한다</li>
<li>산술 연산 표현식 평가 중 피연산자가 숫자 타입이 아니라면 숫자 타입으로 암묵적으로 타입 변환 한다</li>
<li>암묵적으로 타입 변환이 가능하지 않는 경우는 평가 결과가 NaN 이 된다</li>
</ul>
<h3 id="1-3-불리언-타입으로-변환"><a href="#1-3-불리언-타입으로-변환" class="headerlink" title="1-3 불리언 타입으로 변환"></a>1-3 불리언 타입으로 변환</h3><ul>
<li>if, for 등 조건문이나 삼항 조건 연산자의 조건식의 경우 모두 불리언 값이어야 함</li>
<li>자바스크립트 엔진은 조건식의 평가 결과를 불리언 값으로 암묵적으로 타입 변환 함</li>
<li>자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy값 (참으로 평가 되는 값) 또는 Falsy 값 (거짓으로 평가되는 값) 으로 구분 함</li>
<li>거짓으로 평가되는 값은 다음과 같고 이외에는 참으로 평가되는 값임<ul>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0, -0</li>
<li>NaN</li>
<li>‘ ‘ (빈 문자열)</li>
</ul>
</li>
</ul>
<h2 id="2-명시적-타입변환"><a href="#2-명시적-타입변환" class="headerlink" title="2. 명시적 타입변환"></a>2. 명시적 타입변환</h2><ul>
<li>개발자의 의도에 의해 명시적으로 타입을 변환하는 법</li>
</ul>
<h3 id="2-1-문자열-타입으로-변환"><a href="#2-1-문자열-타입으로-변환" class="headerlink" title="2-1 문자열 타입으로 변환"></a>2-1 문자열 타입으로 변환</h3><ol>
<li><p>String 생성자 함수를 new연산자 없이 호출하는 법</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">1</span>)); --&gt; 문자열 <span class="string">'1'</span></span><br><span class="line"><span class="comment">// 숫자 타입을 문자열 타입으로 전환 함</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">true</span>)); --&gt; 문자열 <span class="string">'true'</span></span><br><span class="line"><span class="comment">// 불리언 타입을 문자열 타입으로 전환함</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.prototype.toString 메소드를 사용하는 방법</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>).toString()); --&gt; 문자열 <span class="string">'1'</span></span><br><span class="line"><span class="comment">// 숫자 타입을 문자열 타입으로 전환 함</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).toString()); --&gt; 문자열 <span class="string">'true'</span></span><br><span class="line"><span class="comment">// 불리언 타입을 문자열 타입으로 전환함</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>문자열 연결 연산자를 이용하는 방법</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="string">''</span>); --&gt; 문자열 <span class="string">'1'</span></span><br><span class="line"><span class="comment">// 숫자 타입을 문자열 타입으로 전환 함</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + <span class="string">''</span>); --&gt; 문자열 <span class="string">'true'</span></span><br><span class="line"><span class="comment">// 불리언 타입을 문자열 타입으로 전환함</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-2-숫자-타입으로-변환"><a href="#2-2-숫자-타입으로-변환" class="headerlink" title="2-2 숫자 타입으로 변환"></a>2-2 숫자 타입으로 변환</h3><ol>
<li><p>Number 생성자 함수를 New 연산자 없이 호출하는 방법</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">'1'</span>)); --&gt; 숫자 <span class="number">1</span></span><br><span class="line"><span class="comment">// 문자열 타입을 숫자 타입으로 전환 함</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">true</span>)); --&gt; 숫자 <span class="number">1</span></span><br><span class="line"><span class="comment">// 불리언 타입을 숫자 타입으로 전환함</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>parselnt, parseFloat 함수를 사용하는 방법(문자열만 숫자타입으로 변환 가능)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">'1'</span>)); --&gt; 숫자 <span class="number">1</span></span><br><span class="line"><span class="comment">// 문자열 타입을 숫자 타입으로 전환 함</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">'10.53'</span>)); --&gt; 숫자 <span class="number">10.53</span></span><br><span class="line"><span class="comment">// 문자열 타입을 숫자 타입으로 전환 함</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>‘+’ 단항 산술 연산자를 이용하는 방법</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="string">'1'</span>); --&gt; 숫자 <span class="number">1</span></span><br><span class="line"><span class="comment">// 문자열 타입을 숫자 타입으로 전환 함</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="literal">true</span>); --&gt; 숫자 <span class="number">1</span></span><br><span class="line"><span class="comment">// 불리언 타입을 숫자 타입으로 전환함</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>‘*’ 산술 연산자를 이용하는 방법</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> * <span class="number">1</span>); --&gt; 숫자 <span class="number">1</span></span><br><span class="line"><span class="comment">// 문자열 타입을 숫자 타입으로 전환 함</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> * <span class="number">1</span>); --&gt; 숫자 <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> * <span class="number">1</span>); --&gt; 숫자 <span class="number">0</span></span><br><span class="line"><span class="comment">// 불리언 타입을 숫자 타입으로 전환함</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-3-불리언-타입으로-전환"><a href="#2-3-불리언-타입으로-전환" class="headerlink" title="2-3 불리언 타입으로 전환"></a>2-3 불리언 타입으로 전환</h3><ol>
<li><p>Boolean 생성자 함수를 new 연산자 없이 호출하는 방법</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">''</span>)); --&gt; 불리언 <span class="literal">false</span>(거짓으로 평가됨)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">null</span>)); --&gt; 불리언 <span class="literal">false</span>(거짓으로 평가됨)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">undefined</span>)); --&gt; 불리언 <span class="literal">false</span>(거짓으로 평가됨)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>)); --&gt; 불리언 <span class="literal">false</span>(거짓으로 평가됨)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>)); --&gt; 불리언 <span class="literal">false</span>(거짓으로 평가됨)</span><br><span class="line"><span class="comment">// 거짓으로 평가되는 값일 경구 false가 됨</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">'x'</span>)); --&gt; 불리언 <span class="literal">true</span>(참으로 평가됨)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">1</span>)); --&gt; 불리언 <span class="literal">true</span>(참으로 평가됨)</span><br><span class="line"><span class="comment">// 거짓으로 평가되는 값 이외에는 true가 됨</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>‘!’부정 논리 연산자를 두변 사용하는 방법</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!!<span class="string">''</span>); --&gt; 불리언 <span class="literal">false</span>(거짓으로 평가됨)</span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">null</span>); --&gt; 불리언 <span class="literal">false</span>(거짓으로 평가됨)</span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">undefined</span>); --&gt; 불리언 <span class="literal">false</span>(거짓으로 평가됨)</span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">0</span>); --&gt; 불리언 <span class="literal">false</span>(거짓으로 평가됨)</span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">NaN</span>); --&gt; 불리언 <span class="literal">false</span>(거짓으로 평가됨)</span><br><span class="line"><span class="comment">// 거짓으로 평가되는 값일 경구 false가 됨</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">'x'</span>); --&gt; 불리언 <span class="literal">true</span>(참으로 평가됨)</span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">1</span>); --&gt; 불리언 <span class="literal">true</span>(참으로 평가됨)</span><br><span class="line"><span class="comment">// 거짓으로 평가되는 값 이외에는 true가 됨</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="단축평가"><a href="#단축평가" class="headerlink" title="단축평가"></a>단축평가</h2><ul>
<li>or(||) 연산자와 and(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수 있음</li>
<li>or(||) 연산자와 and(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가 됨</li>
</ul>
<h3 id="AND-연산-시-단축평가"><a href="#AND-연산-시-단축평가" class="headerlink" title="AND 연산 시 단축평가"></a>AND 연산 시 단축평가</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Cat'</span> &amp;&amp; <span class="string">'Dog'</span> --&gt; <span class="string">'Dog'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>첫번째 피연산자 ‘Cat’은 참으로 평가되는 값으로 true로 평가되어 두번째 피연산자를 평가해 결과를 결정함</li>
<li>이때 논리 연산 결과를 결정하는 두번째 피연산자 ‘Dog’를 그대로 반환 함</li>
</ul>
<h3 id="OR-연산-시-단축평가"><a href="#OR-연산-시-단축평가" class="headerlink" title="OR 연산 시 단축평가"></a>OR 연산 시 단축평가</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Cat'</span> || <span class="string">'Dog'</span> --&gt; <span class="string">'Cat'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>첫번째 피연산자 ‘Cat’은 참으로 평가되는 값으로 true로 평가되어 두번째 피연산자 까지 평가하지 않아도 표현식을 평가 할 수 있음</li>
<li>이때 논리 연산 결과를 결정한 첫번째 피연산자 ‘Cat’을 그대로 출력 함</li>
</ul>
<ul>
<li><p>단축 평가를 사용하면 if문 대체 가능함</p>
</li>
<li><p>주어진 조건이 참으로 평가되는 값일때 and연산자 표현식으로 if문을 대체할 수 있음</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(done) message = <span class="string">'완료'</span>; <span class="comment">// done이 true일때 massage에 '완료'를 할당</span></span><br><span class="line"></span><br><span class="line">message = done &amp;&amp; <span class="string">'완료'</span>; <span class="comment">// done이 true일 때 결과를 결정하는 두번째 피연산자 '완료'가 그대로 message로 할당</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>주어진 조건이 거짓으로 평가되는 값 일때 or연산자 표현식으로 if문 대체 가능</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!done) message = <span class="string">'미완료'</span>; <span class="comment">// done이 false일때 massage에 '완료'를 할당</span></span><br><span class="line"></span><br><span class="line">message = done || <span class="string">'미완료'</span>; <span class="comment">// done이 false일 때 결과를 결정하는 두번째 피연산자 '미완료'가 그대로 message로 할당</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>삼항 조건 연산자는 if…else문은 대체 가능 함</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(done) message = <span class="string">'완료'</span>;</span><br><span class="line"><span class="keyword">else</span> message = <span class="string">'미완료'</span>;</span><br><span class="line"></span><br><span class="line">message = done ? <span class="string">'완료'</span> : <span class="string">'미완료'</span>;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="객체-리터럴"><a href="#객체-리터럴" class="headerlink" title="객체 리터럴"></a>객체 리터럴</h1><h2 id="1-객체란"><a href="#1-객체란" class="headerlink" title="1. 객체란?"></a>1. 객체란?</h2><ul>
<li>자바스크립트는 객채(object)기반의 프로그래밍 언어임</li>
<li>자바 스크립트를 이루고 있는 거의 “모든 것”이 객체임</li>
<li>원시값을 제외한 나머지 값을(함수, 배열, 정규 표현식)은 모두 객체임</li>
<li>원시 타입은 닫 하나의 값만 나타내지만 객체 타입(object / reference type)은 다양한 타입의 값들을 하나 단위로 구성한 자료구조임</li>
<li>원시 타입의 값은 변경 불가능한 값이지만 객체는 변경 가능한 값임</li>
<li>객체는 키(key)와 값(value)으로 구성된 프로퍼티(Property)들의 집합이다<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span>,</span><br><span class="line">  age: <span class="number">32</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// name, age --&gt; 프로퍼티 키</span></span><br><span class="line"><span class="comment">// 'song', 32 --&gt; 프로퍼티 값</span></span><br><span class="line"><span class="comment">// name: 'song' --&gt; 프로퍼티</span></span><br></pre></td></tr></table></figure></li>
<li>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있음</li>
<li>자바스크립트 함수는 일습 객체 이므로 값으로 취급할 수 있다.</li>
<li>프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메소드(Method)라 부른다<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  num: <span class="number">0</span>, <span class="comment">// 프로퍼티</span></span><br><span class="line">  increase: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.num++;</span><br><span class="line">  &#125; <span class="comment">// 메소드</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>프로퍼티 : 객체의 상태를 나타내는 값(data)</li>
<li>메소드 : 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)</li>
</ul>
</li>
</ul>
<h2 id="2-객체-리터럴에-의한-객체-생성"><a href="#2-객체-리터럴에-의한-객체-생성" class="headerlink" title="2. 객체 리터럴에 의한 객체 생성"></a>2. 객체 리터럴에 의한 객체 생성</h2><ul>
<li><p>C++과 Java같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new연산자와 함께 생성자(constructor)를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다</p>
<ul>
<li>인스턴스 : 클래스에 의해 생성되어 메모리에 저장된 실체</li>
</ul>
</li>
<li><p>자바스크립트는 프로토타입 기반 객체 지향 언어로서 클래스 기반 객체지향 언어와는 다른 다양한 객체 생성 방법이 존재하는데 아래와 같다</p>
<ul>
<li>객체 리터럴</li>
<li>Object 생성자 함수</li>
<li>생성자 함수</li>
<li>Object.create 메소드</li>
<li>클래스(ES6)</li>
</ul>
<ul>
<li>위 객체 생성 방법 중 객체 리터럴 방법이 일반적이고 간단하다(객체 리터럴은 객체를 생성하는 표기법이다)</li>
<li>객체 리터럴은 중괄호 {} 내에 0개 이상의 프로퍼티를 정의한다.</li>
<li>변수의 할당이 이루어 지는 시점에 자바스크립트 엔진은 객체 리터럴을 해석하여 객체를 생성한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person); <span class="comment">// object 출력</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "song", sayHello: f&#125; 출력</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>만약 중괄호 내 프로퍼티를 정하지 않으면 빈 객체가 생성된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;; <span class="comment">// 빈 객체</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person); <span class="comment">// object 출력</span></span><br></pre></td></tr></table></figure></li>
<li><p>객체 리터럴의 중괄호는 코드블럭을 의미하는 것이 아님</p>
</li>
<li><p>코드블록의 중괄호 뒤에는 세미콜론을 붙이지 않지만 객체 리터럴은 값으로 평가되는 표현식이므로 객체를 닫는 중괄호 뒤에 세미콜론을 붙인다</p>
</li>
<li><p>객체리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식임</p>
</li>
<li><p>객체의 생성과 동시에 프로퍼티를 만들 수 있고 객체를 생성한 이후에 프로퍼티를 동적으로 추가 할 수 있음</p>
</li>
</ul>
<h2 id="3-프로퍼티"><a href="#3-프로퍼티" class="headerlink" title="3. 프로퍼티"></a>3. 프로퍼티</h2><ul>
<li>객체는 프로퍼티의 집합이며 프로퍼티는 key와 value로 구성 됨</li>
<li>프로퍼티를 나열할 때는 쉼포’,’로 구분 함</li>
</ul>
<ul>
<li>프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol값</li>
<li>프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값</li>
</ul>
<ul>
<li>프로퍼티 키는 값에 접근할 수 있는 이름으로 식별자 역할을 함</li>
<li>식별자 네이밍 규칙을 반드시 따라야 하는것은 아니나 따르지 않는 이름은 반드시 따옴표를 사용해야 함<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">'Buyong'</span>, <span class="comment">// 식별자 네이밍 규칙에 따른 유효한 이름</span></span><br><span class="line">  <span class="string">'last-name'</span>: <span class="string">'Song'</span> <span class="comment">// 식별자 네이밍 규칙에 따르지 않은 유요하지 않은 이름 (- 연산자가 있는 표현식으로 해석 됨)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;firstName: "Buyong", last-name:"Song"&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>문자열 또는 타입 변환을 통해 문자열로 평가될 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성하는 것이 가능함<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> key = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line">obj[key] = <span class="string">'world'</span>; </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;hello: world&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>빈 문자열을 프로퍼티 키로 사용해도 에러 발생은 없으나 키로서 의미를 가지지 못함</li>
<li>프로퍼티 키에 문자열이나 symbol값 이외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 된다.(프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 붙지 않지만 내부적으로는 문자열로 변함)</li>
<li>예약어를 프로퍼티 키로 사용해도 에러 발생은 없으나 예상치 못한 상황이 발생할 수도 있음</li>
<li>이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.(이때도 에러 발생 없음)</li>
</ul>
<h2 id="4-메소드"><a href="#4-메소드" class="headerlink" title="4. 메소드"></a>4. 메소드</h2><ul>
<li>자바스크립트에서 함수는 일금 객체이다</li>
<li>함수는 값으로 취급할 수 있으며 프로퍼티의 값이 될 수 있다</li>
<li>프로퍼티 값이 함수인 경우 일반 함수와 구분하기 위해 메소드(Method)라 부른다</li>
</ul>
<h2 id="5-프로퍼티-접근"><a href="#5-프로퍼티-접근" class="headerlink" title="5. 프로퍼티 접근"></a>5. 프로퍼티 접근</h2><ul>
<li>프로퍼티 값에 접근하려면 마침표(.)를 사용하는 마침표 표기법 또는 대괄호 []를 사용하는 대괄호 표기법을 사용한다</li>
<li>프로퍼티 키가 식별자 네이밍 규칙을 따르는 이름이면 마침표 표기법과 대괄호 표기법 모두 사용 가능하다</li>
<li>마침표 또는 대괄호 좌측에는 객체로 평가 될 수 있는 표현식을 기술한다. 마침표 우측 또는 대괄호 내부에는 프로퍼티 키를 지정한다<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// 마침표 표기법에 의한 접근</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'name'</span>]); <span class="comment">// 대괄호 표기법에 의한 접근(대괄호 내부 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어랴 함, 따옴표가 없으면 식별자로 해석)</span></span><br></pre></td></tr></table></figure></li>
<li>프로퍼티 키가 네이밍 규칙을 준수하지 않은 이름이면 반드시 대괄호 표기법을 사용해야 함</li>
<li>단 프로퍼티 키가 숫자로 이루어진 문자열 일 경우 따옴표 생략 가능</li>
</ul>
<h2 id="6-프로퍼티-값-갱신"><a href="#6-프로퍼티-값-갱신" class="headerlink" title="6. 프로퍼티 값 갱신"></a>6. 프로퍼티 값 갱신</h2><ul>
<li>이미 존재하는 프로퍼티 값을 할당하면 프로퍼티 값이 갱신된다</li>
</ul>
<h2 id="7-프로퍼티-동적-생성"><a href="#7-프로퍼티-동적-생성" class="headerlink" title="7. 프로퍼티 동적 생성"></a>7. 프로퍼티 동적 생성</h2><ul>
<li>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다</li>
</ul>
<h2 id="8-프로퍼티-삭제"><a href="#8-프로퍼티-삭제" class="headerlink" title="8. 프로퍼티 삭제"></a>8. 프로퍼티 삭제</h2><ul>
<li>delete연산자는 객체의 프로퍼티를 삭제한다.</li>
<li>이때 delete연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 펴현식 이어야 한다</li>
<li>존재하지 않는 프로퍼티를 삭제하면 에러 없이 무시된다<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span></span><br><span class="line">&#125;;</span><br><span class="line">person.age = <span class="number">32</span>; <span class="comment">// 프로퍼티 동적 생성</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.age; <span class="comment">// 동적생성된 age 프로퍼티 삭제 </span></span><br><span class="line"><span class="keyword">delete</span> person.address; <span class="comment">// address 프로퍼티 없음으로 삭제 안됨</span></span><br></pre></td></tr></table></figure>
<h2 id="9-ES6에서-추가된-객체-리터럴의-확장기능"><a href="#9-ES6에서-추가된-객체-리터럴의-확장기능" class="headerlink" title="9. ES6에서 추가된 객체 리터럴의 확장기능"></a>9. ES6에서 추가된 객체 리터럴의 확장기능</h2></li>
</ul>
<h3 id="9-1-프로퍼티-축약-표현"><a href="#9-1-프로퍼티-축약-표현" class="headerlink" title="9-1 프로퍼티 축약 표현"></a>9-1 프로퍼티 축약 표현</h3><ul>
<li>ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티가 동일한 이름일 때 프로퍼티를 생략할 수 있다</li>
<li>이때 프로퍼티 키는 변수 이름으로 자동 생성된다</li>
</ul>
<h3 id="9-2-프로퍼티-키-동적-생성"><a href="#9-2-프로퍼티-키-동적-생성" class="headerlink" title="9-2 프로퍼티 키 동적 생성"></a>9-2 프로퍼티 키 동적 생성</h3><ul>
<li>문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식을 사용해 프로퍼티를 동적으로 생성할 수 있다</li>
<li>단 프로퍼티로 사용할 표현식을 대괄호[]로 묶어야 한다</li>
</ul>
<h3 id="9-3-메소드-축약표현"><a href="#9-3-메소드-축약표현" class="headerlink" title="9-3 메소드 축약표현"></a>9-3 메소드 축약표현</h3><ul>
<li>ES6 에서는 메소드를 정의할 때 function키워드를 생략한 축약 표현을 사용할 수 있다</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/02/21/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-21%20%EC%98%88%EC%8A%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/21/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-21%20%EC%98%88%EC%8A%B5/" class="post-title-link" itemprop="url">2020-02-21 예습</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-21 20:00:00" itemprop="dateCreated datePublished" datetime="2020-02-21T20:00:00+09:00">2020-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-02 22:48:06" itemprop="dateModified" datetime="2020-03-02T22:48:06+09:00">2020-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h1><ul>
<li>연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교 논리, 타입 지수연산 등을 수행해 하나의 값을 만듬</li>
<li>연산의 대상은 피 연산자라고 함</li>
<li>피연산자는 값으로 평가될 수 있는 표현식이어야 함</li>
</ul>
<h2 id="산술연산자"><a href="#산술연산자" class="headerlink" title="산술연산자"></a>산술연산자</h2><ul>
<li>피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자값을 만듬</li>
</ul>
<h3 id="이항-산술-연산자"><a href="#이항-산술-연산자" class="headerlink" title="이항 산술 연산자"></a>이항 산술 연산자</h3><ul>
<li>2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만듬</li>
<li>모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수효과가 없음</li>
</ul>
<p>‘+’ 덧셈<br>‘-‘ 뻴셈<br>‘*’ 곱셈<br>‘/‘ 나눗셈<br>‘%’ 나머지</p>
<h3 id="단항-산술-연산자"><a href="#단항-산술-연산자" class="headerlink" title="단항 산술 연산자"></a>단항 산술 연산자</h3><ul>
<li>단항 산술 연산자는 11개의 피연산자를 산술 연산하여 숫자 타입의 값을 만듬</li>
<li>증가(++), 감소(–) 연산자는 피연산자의 값을 변경하는 부수효과가 있음(피연산자의 값을 변경하는 암묵적 할당이 이루어짐)</li>
</ul>
<p>‘++’ 증가 (부수효과 있음)<br>‘–’ 감소 (부수효과 있음)<br>‘+’ 어떠한 효과도 없다, 음수를 양수로 반전하지도 않는다<br>‘-‘ 양수를 음수로 음수를 양수로 반전한 값을 반환한다</p>
<h3 id="문자열-연결-연산자"><a href="#문자열-연결-연산자" class="headerlink" title="문자열 연결 연산자"></a>문자열 연결 연산자</h3><ul>
<li>+연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다</li>
</ul>
<h2 id="할당-연산자"><a href="#할당-연산자" class="headerlink" title="할당 연산자"></a>할당 연산자</h2><ul>
<li>할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌할에 있는 변수에 할당한다.</li>
</ul>
<h2 id="비교-연산자"><a href="#비교-연산자" class="headerlink" title="비교 연산자"></a>비교 연산자</h2><ul>
<li>비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값을 반환한다</li>
<li>비교 연산자는 제어문의 조건식에서 주로 사용한다</li>
</ul>
<h3 id="동등-일치-비교-연산자"><a href="#동등-일치-비교-연산자" class="headerlink" title="동등 / 일치 비교 연산자"></a>동등 / 일치 비교 연산자</h3><ul>
<li>동등 비교 연산자와 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값을 갖는지 비교하여 불리언 값을 반환한다</li>
<li>동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다</li>
</ul>
<ul>
<li>x == y : x와 y의 값이 같음 (동등비교)</li>
<li>x === y : x와 y의 값과 타입이 같음 (일치비교)</li>
<li>x != y : x와 y의 값이 다름 (부동등비교)</li>
<li>x !== y : x와 y의 값과 타입이 다름 (불일치비교)</li>
</ul>
<h3 id="대소-관계-비교-연산자"><a href="#대소-관계-비교-연산자" class="headerlink" title="대소 관계 비교 연산자"></a>대소 관계 비교 연산자</h3><ul>
<li>대소관계 비교 연산자는 치연산자의 크기를 비교하여 불리언 값을 반환한다</li>
</ul>
<ul>
<li>x &gt; y : x가 y보다 크다</li>
<li>x &lt; y : x가 y보다 작다</li>
<li>x &gt;= y : x가 y보다 같거나 크다 </li>
<li>x &lt;= y : x가 y보다 같거나 작다</li>
</ul>
<h2 id="삼항-조건-연산자"><a href="#삼항-조건-연산자" class="headerlink" title="삼항 조건 연산자"></a>삼항 조건 연산자</h2><ul>
<li>조건식의 평가 결과에 따라 반환할 값을 경정함<ul>
<li>조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값</li>
</ul>
</li>
</ul>
<h2 id="논리연산자"><a href="#논리연산자" class="headerlink" title="논리연산자"></a>논리연산자</h2><ul>
<li>논리 연산자는 우항과 좌항의 피연산자를 논리 연산한다.</li>
</ul>
<ul>
<li>|| : or</li>
<li>&amp;&amp; : and</li>
<li>! : not</li>
</ul>
<h2 id="쉼표연산자"><a href="#쉼표연산자" class="headerlink" title="쉼표연산자"></a>쉼표연산자</h2><ul>
<li>왼쪽 피연산자 부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다</li>
</ul>
<h2 id="그룹-연산자"><a href="#그룹-연산자" class="headerlink" title="그룹 연산자"></a>그룹 연산자</h2><ul>
<li>그룹 연산자 ()는 피연산자의 표현식을 가장 먼저 평가한다. 따라서 그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있다</li>
</ul>
<h2 id="typeof-연산자"><a href="#typeof-연산자" class="headerlink" title="typeof 연산자"></a>typeof 연산자</h2><ul>
<li>typeof연산자는 피연산자의 타입을 문자열로 반환한다</li>
</ul>
<h2 id="지수연산자"><a href="#지수연산자" class="headerlink" title="지수연산자"></a>지수연산자</h2><ul>
<li>ES7에서 새롭게 도입됨</li>
<li>좌항의 피연산자를 밑으로 우항의 피연산자를 지수로 거듭제곱하여 숫자 타입의 값을 반환 함</li>
</ul>
<h1 id="제어문"><a href="#제어문" class="headerlink" title="제어문"></a>제어문</h1><ul>
<li>주어진 조건에 따라 코드블록을 실행하거나 반복실행 할때 사용 함</li>
<li>제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있음</li>
<li>제어문은 코드의 흐름을 이해하기 어렵게 만들어 가독성을 해치는 간점이 있음</li>
</ul>
<h2 id="블록문"><a href="#블록문" class="headerlink" title="블록문"></a>블록문</h2><ul>
<li>블록문은 0개 이상의 중괄호로 묶은 것으로 코드블록 또는 블록이라고 부르기도 함</li>
<li>자바스크립트는 블록문은 하나의 실행 단위로 취급 함</li>
<li>블록문은 단독으로 사용 될 수도 있으나 일반적으로 제어문이나 함수를 정의할 때 사용하는것이 일반적임</li>
</ul>
<h2 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h2><ul>
<li>조건문은 주어진 조건식의 평가 결과에 따라 코드블럭의 실행을 결정한다</li>
<li>자바스크립트는 if…else 문과 switch문을 제공한다</li>
</ul>
<h3 id="if…else문"><a href="#if…else문" class="headerlink" title="if…else문"></a>if…else문</h3><ul>
<li>if…else문은 주어진 평과 결과에 따라 실행할 코드 블럭을 결정한다</li>
<li>평가 결과는 불리언 값으로 평가된다</li>
<li>조건식의 평가 결과가 참인 경우 if문 다음의 코드 블럭이 살행되고 거짓인 경우 else문 다음의 코드 블럭이 실행된다</li>
</ul>
<h3 id="switch문"><a href="#switch문" class="headerlink" title="switch문"></a>switch문</h3><ul>
<li>switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 case문으로 실행 순서를 이동시킨다</li>
<li>switch 문의 표현식과 일치하는 표현식을 갖는 case문이 없다면 실행 순서는 default문으로 이동한다</li>
<li>default 옵션으로 사용할 수도 있고 사용하지 않을수도 있다</li>
<li>switch문의 표현식은 불리언 값보다는 문자열, 숫자 값인 경우가 많다.(다양한 상황에 따라 실행할 코드블럭을 결정할 때 사용)</li>
</ul>
<h2 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h2><ul>
<li>반복문은 주어진 조건식의 평가 결과가 참인 경우 코드블럭을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드블럭을 다시 실행한다(조건식이 거짓일때까지 실행)</li>
<li>자바스크립트는 3가지 반복문 for문, while문, do…while문을 제공한다.</li>
<li>그외 for…in문과 for…of문이 있음</li>
</ul>
<h3 id="for문"><a href="#for문" class="headerlink" title="for문"></a>for문</h3><ul>
<li>for문은 조건식이 거짓으로 판별될 때까지 코드블럭을 반복 실행한다.<ul>
<li>for (변수 선언문 또는 할당 문; 조건식; 증감식) {<br>조건식이 참인 경우 반복 실행될 문;<br>}</li>
</ul>
</li>
<li>for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다, 어떤식도 선언하지 않으면 무한 루프가 된다</li>
<li>for문 내에 for문을 중첩해 사용할 수 있다  </li>
</ul>
<h3 id="while문"><a href="#while문" class="headerlink" title="while문"></a>while문</h3><ul>
<li>while문은 주어진 조건식의 평과 결과가 참이면 코드 블록을 계속해서 반복 실행한다.</li>
<li>조건문의 평가 결과가 거짓이 되면 실행을 종료한다</li>
<li>조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참, 거짓을 구별한다</li>
<li>평가 결과가 언제나 참이면 무한 루프가 된다</li>
<li>무한 루프를 탈출하기 위해서는 코드블럭 내에 if문으로 탈출 조건을 만들고 break문으로 코드블럭을 탈출한다</li>
</ul>
<h3 id="do…while문"><a href="#do…while문" class="headerlink" title="do…while문"></a>do…while문</h3><ul>
<li>do…while문은 코드블럭을 먼저 실행하고 조건식을 평가한다(코드블럭은 무조건 한번 이상 실행)</li>
</ul>
<h3 id="brack문"><a href="#brack문" class="headerlink" title="brack문"></a>brack문</h3><ul>
<li>brack문은 레이블 문, 반복문, switch문의 코드 블록을 탈출한다.</li>
<li>이외에 brack문을 사용하면 문법에러가 발행함</li>
</ul>
<h3 id="continue문"><a href="#continue문" class="headerlink" title="continue문"></a>continue문</h3><ul>
<li>반복문의 코드블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다.</li>
<li>brack문처럼 반복문을 탈출하지는 않는다</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/02/20/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-20%20%EC%98%88%EC%8A%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/20/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-20%20%EC%98%88%EC%8A%B5/" class="post-title-link" itemprop="url">2020-02-20 예습</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-20 20:00:00" itemprop="dateCreated datePublished" datetime="2020-02-20T20:00:00+09:00">2020-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-02 22:48:00" itemprop="dateModified" datetime="2020-03-02T22:48:00+09:00">2020-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="표현식과-문"><a href="#표현식과-문" class="headerlink" title="표현식과 문"></a>표현식과 문</h1><p><img src="../image/IMG_34FD262B2561-1.jpeg" alt="값과 리터럴, 표현식의 관계"></p>
<h3 id="값"><a href="#값" class="headerlink" title="값"></a>값</h3><ul>
<li>값은 표현식이 평가되어 생성된 결과가 메모리에 저장된 것</li>
<li>값은 메모리에 2진수 형태로 저장됨</li>
<li>모든 값은 데이터 타입을 가짐</li>
<li>값은 데이터 타입에 따라 같은 2진수 값이라도 다르게 해석될 수 있음</li>
</ul>
<h3 id="리터럴"><a href="#리터럴" class="headerlink" title="리터럴"></a>리터럴</h3><ul>
<li>사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기방식</li>
</ul>
<h3 id="표현식"><a href="#표현식" class="headerlink" title="표현식"></a>표현식</h3><ul>
<li>값으로 평가될 수 있는 모든 문(statement)</li>
<li>리터럴은 자바스크립트 엔진에 의해 평가되어 값을 생성하므로 리터럴 그 자체로 표현식임</li>
<li>표현식은 리터럴, 식별자, 연산자, 함수호출 등의 조합으로 이루어질 수 있음</li>
<li>표현식과 표현식이 평가된 값은 동등한 관계(동치)</li>
<li>표현식은 값처럼 사용할 수 있음(값이 위치할 수 있는 자리에는 표현식도 위치 가능)</li>
</ul>
<h3 id="문-statement"><a href="#문-statement" class="headerlink" title="문(statement)"></a>문(statement)</h3><ul>
<li>프로그램을 구성하는 기본 단위이자 최소 실행 단위</li>
<li>문은 여러 토큰들로 구성 됨(토큰은 문법적으로 더이상 나눌 수 없는 코드의 기본 요소)</li>
<li>문은 컴퓨터에 내리는 명령임</li>
<li>할당문 반복문 조건문 으로 구성됨</li>
</ul>
<h3 id="세미콜론-자동-완성-기능"><a href="#세미콜론-자동-완성-기능" class="headerlink" title="세미콜론 자동 완성 기능"></a>세미콜론 자동 완성 기능</h3><ul>
<li>함수의 코드블록 뒤에는 세미콜론을 붙이지 않음(함수의 코드 블록은 자체 종결성을 갖음)</li>
<li>자바스크립트 엔진은 문의 끝이라 예측되는 지점에 세미콜론을 자동으로 붙여주는 기능이 있음</li>
<li>세미콜론 사용을 권장함</li>
</ul>
<h3 id="표현식인-문과-표현식이-아닌-문"><a href="#표현식인-문과-표현식이-아닌-문" class="headerlink" title="표현식인 문과 표현식이 아닌 문"></a>표현식인 문과 표현식이 아닌 문</h3><ul>
<li>표현식인 문 : 값으로 평가될 수 있는 문</li>
<li>표현식이 아닌 문 : 값으로 평가될 수 없는 문</li>
</ul>
<h1 id="데이터타입"><a href="#데이터타입" class="headerlink" title="데이터타입"></a>데이터타입</h1><h3 id="원시타입-숫자-문자열-불리언-undefined-null-symbol"><a href="#원시타입-숫자-문자열-불리언-undefined-null-symbol" class="headerlink" title="원시타입(숫자, 문자열, 불리언, undefined, null, symbol)"></a>원시타입(숫자, 문자열, 불리언, undefined, null, symbol)</h3><h5 id="1-숫자"><a href="#1-숫자" class="headerlink" title="1. 숫자"></a>1. 숫자</h5><ul>
<li>배정밀도 64비트 부동소수점 형식을 따름</li>
<li>모든 수를 실수로 처리(정수만을 위한 타입이 없음)</li>
<li>정수, 실수, 2진수, 8진수, 16진수 리터럴을 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장됨</li>
<li>자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석됨</li>
<li>숫자타입을 추가적으로 3가지 특별한 값들도 포함됨<ul>
<li>Infinity : 양의 무한대</li>
<li>-Infinity : 음의 무한대</li>
<li>NaN : 산술 연산 불가</li>
</ul>
</li>
</ul>
<h5 id="2-문자열"><a href="#2-문자열" class="headerlink" title="2. 문자열"></a>2. 문자열</h5><ul>
<li><p>텍스트 데이터를 나타내는데 사용</p>
</li>
<li><p>작은따옴표(‘’), 큰따옴표(“”), 백틱(₩₩)(템플릿 리터럴)으로 텍스트를 감쌈(일반적으로는 작은 따옴표)</p>
</li>
<li><p>문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자와 같은 토큰으로 인식함</p>
<h6 id="2-1-템플릿-리터럴"><a href="#2-1-템플릿-리터럴" class="headerlink" title="2-1 템플릿 리터럴"></a>2-1 템플릿 리터럴</h6><ul>
<li>일반적인 따옴표 대비 백틱을 사용</li>
<li>ES6 부터 추가됨</li>
<li>일반 문자열에서 줄바꿈을 허용되지 않지만 템플릿 문자열은 허용 됨</li>
<li>모든 공백이 있는 그대로 적용 됨</li>
<li>표현식 삽입을 통해 간단히 문자열을 삽입할 수 있음, 문자열 연산자보다 가독성 우수(${표현식})</li>
<li>표현식의 평가 결과가 문자열이 아니더라도 강제로 문자열로 타입이 변환된다.</li>
<li>일반 문자열에서의 표현식 삽입은 표현식 자체가 문자열이 됨</li>
</ul>
</li>
</ul>
<h5 id="3-불리언"><a href="#3-불리언" class="headerlink" title="3. 불리언"></a>3. 불리언</h5><ul>
<li>참, 거짓을 나타내는 true, false뿐이다</li>
</ul>
<h5 id="4-undefined"><a href="#4-undefined" class="headerlink" title="4. undefined"></a>4. undefined</h5><ul>
<li>변수 선언 시 자바스크립트 엔진의 초기화에 의해 할당되는 암묵적인 값</li>
</ul>
<h5 id="5-null"><a href="#5-null" class="headerlink" title="5. null"></a>5. null</h5><ul>
<li>변수에 값이 없다는 것을 의도적으로 명시할 때 사용</li>
<li>변수가 이전에 참조하던 값을 더이상 참조하지 않겠다는 의미임</li>
</ul>
<h5 id="6-symbol"><a href="#6-symbol" class="headerlink" title="6. symbol"></a>6. symbol</h5><ul>
<li>충돌 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다</li>
<li>함수를 호출해 생성하고 이때 생성된 심볼 값은 노출되지 않고 다른 값과 절대 중복되지 않음</li>
</ul>
<h3 id="객체타입"><a href="#객체타입" class="headerlink" title="객체타입"></a>객체타입</h3><ul>
<li>원시타입의 6가지 데이터 타입 이외의 값</li>
</ul>
<h2 id="데이터-타입의-필요성"><a href="#데이터-타입의-필요성" class="headerlink" title="데이터 타입의 필요성"></a>데이터 타입의 필요성</h2><ul>
<li>데이터 타입에 의한 메모리 공간의 크기 결정</li>
<li>값을 참조할 때 한번에 읽어들여야 할 메모리 공간의 크기 결정</li>
<li>데이터 타입에 의한 값의 해석</li>
</ul>
<h2 id="동적-타이핑"><a href="#동적-타이핑" class="headerlink" title="동적 타이핑"></a>동적 타이핑</h2><ul>
<li>정적타입언어<ul>
<li>변수의 타입을 설정할 수 없음</li>
<li>변수에 선언한 타입에 맞는 값만 할당할 수 있음</li>
<li>컴파일 시점에 타입을 체크하며 체크를 통과하지 못하면 에러 발생</li>
</ul>
</li>
<li>동적타입언어(자바스크립트)<ul>
<li>선언이 아닌 할당에 의해 타입이 결정됨</li>
<li>재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있음(동적 타이핑)</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/02/10/1st-post/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/10/1st-post/" class="post-title-link" itemprop="url">1st-post</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-02-10 12:37:52 / Updated at: 12:39:46" itemprop="dateCreated datePublished" datetime="2020-02-10T12:37:52+09:00">2020-02-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>hello</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="다음 페이지"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          흝어보기
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">angryboo</p>
  <div class="site-description" itemprop="description">I can do this all day</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">카테고리</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">태그</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">angryboo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
