<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"angryboo.github.io","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="I can do this all day">
<meta property="og:type" content="website">
<meta property="og:title" content="angryboo">
<meta property="og:url" content="https://angryboo.github.io/index.html">
<meta property="og:site_name" content="angryboo">
<meta property="og:description" content="I can do this all day">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="angryboo">
<meta property="article:tag" content="vs">
<meta property="article:tag" content=" html">
<meta property="article:tag" content=" css">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://angryboo.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>angryboo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">angryboo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">angryboo blog</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>홈</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>카테고리</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>아카이브</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/15/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-15%20%EB%B9%8C%ED%8A%B8%EC%9D%B8%20%EA%B0%9D%EC%B2%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-15%20%EB%B9%8C%ED%8A%B8%EC%9D%B8%20%EA%B0%9D%EC%B2%B4/" class="post-title-link" itemprop="url">빌트인 객체</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-15 12:57:11 / Updated at: 17:23:20" itemprop="dateCreated datePublished" datetime="2020-03-15T12:57:11+09:00">2020-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="빌트인-객체"><a href="#빌트인-객체" class="headerlink" title="빌트인 객체"></a>빌트인 객체</h1><h2 id="1-자바스크립트-객체의-분류"><a href="#1-자바스크립트-객체의-분류" class="headerlink" title="1. 자바스크립트 객체의 분류"></a>1. 자바스크립트 객체의 분류</h2><ol>
<li>표준 빌트인 객체<ul>
<li>ECMAScript 사양에 정의 된 객체를 말하며 애플리케이션 전역의 공통 기능을 제공함.</li>
<li>자바스크립트 실행환경과 관게없이 언제나 사용 가능 함</li>
<li>전역 객체의 프로퍼티 처럼 제공됨으로 별도의 선언 없이 전역변수처럼 언제나 참조 가능</li>
</ul>
</li>
<li>호스트 객체<ul>
<li>ECMAScript 사양에는 정의되어 있지는 않지만 자바스크립트 실행환경에서 추가적으로 제공함</li>
</ul>
</li>
<li>사용자 정의 객체<ul>
<li>사용자가 직접 정의한 객체를 의미함</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-표준-빌트인-객체"><a href="#2-표준-빌트인-객체" class="headerlink" title="2. 표준 빌트인 객체"></a>2. 표준 빌트인 객체</h2><ul>
<li>자바스크립트는 Object, String, Number, Boolean, Symbol, Date, Mathm RegExp, Array, Map/Set 등 40여개의 표준 빌트인 객체를 제공함</li>
<li>Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체이다.</li>
<li>생성자 함수 객체는 표준 빌트인 객체는 프로토타입 메소드와 정적 메소드를 제공하고 생성자함수 객체가 아닌 표준 빌트인 객체는 정적 메소드만을 제공한다.</li>
<li>생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩 된 객체다.</li>
<li>표준 빌트인 객체의 prototype 프로퍼티에 바인딩 된 객ㅊ체는 다양한 기능의 메소드를 제공한다.</li>
<li>또한 인스턴스 없이도 호출 가능한 정적 메소드도 제공한다.</li>
</ul>
<hr>
<h2 id="3-원시값과-래퍼객체"><a href="#3-원시값과-래퍼객체" class="headerlink" title="3. 원시값과 래퍼객체"></a>3. 원시값과 래퍼객체</h2><ul>
<li>원시값인 문자열, 숫자, 불리언 값의 경우, 마치 객체처럼 이들 원시값에 마침표 표기법으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해 줌</li>
<li>문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라고 함</li>
</ul>
<hr>
<h2 id="4-전역객체"><a href="#4-전역객체" class="headerlink" title="4. 전역객체"></a>4. 전역객체</h2><ul>
<li><p>전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체</p>
</li>
<li><p>어떤 객체에도 속하지 않은 최상위 객체</p>
</li>
<li><p>환경에 따라 브라우저에서는 window, node.js 에서는 global이 전역 객체를 가르킴</p>
</li>
<li><p>전역 객체는 표준 빌트인 객체와 환경에 따른 호스트객체, 그리고 var키워드로 선언한 전역 변수와 전역함수를 프로퍼티로 갖는다.</p>
</li>
<li><p>전역 객체의 특징</p>
<ul>
<li>전역 객체는 개발자가 의도적으로 생성할 수 없음.(전역 객체 생성자 함수도 없음)</li>
<li>전역 객체를 참조할 때 window를 생략할 수 있다.</li>
<li>전역 객체는 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.</li>
<li>자바스크립트 실행 환경에 따라 추가적인 프로퍼티와 메소드를 갖는다.</li>
<li>var 키워드로 선언한 전역변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.</li>
<li>let, const로 선언한 전역변수는 전역 객체의 프로퍼티가 아니다.</li>
<li>브라우저 환경의 모든 자바스크립트 코드는 하나의 전역객체 window를 공유한다. (파일이 분리되어 있어도 하나의 전역객체를 공유)</li>
</ul>
</li>
</ul>
<h3 id="4-1-빌트인-전역-프로퍼티"><a href="#4-1-빌트인-전역-프로퍼티" class="headerlink" title="4-1 빌트인 전역 프로퍼티"></a>4-1 빌트인 전역 프로퍼티</h3><ul>
<li>빌트인 전역 프로퍼티는 전역객체의 프로퍼티를 의미한다.</li>
<li>주로 애플리케이션 전역에서 사용하는 값을 의미한다.</li>
</ul>
<ol>
<li>Infinity : Infinity 프로퍼티는 양/음의 무한대를 나타내는 숫자값 Infinity를 갖는다.</li>
<li>NaN : 숫자가 아님을 나타내는 숫자값 NaN을 갖는다.</li>
<li>undefined : undefined 프로퍼티는 원시타입 undefined를 값으로 갖는다.</li>
</ol>
<h3 id="4-2-빌트인-전역함수"><a href="#4-2-빌트인-전역함수" class="headerlink" title="4-2 빌트인 전역함수"></a>4-2 빌트인 전역함수</h3><ul>
<li>빌트인 전력함수는 애플리케이션 전역에서 호출할 수 있는 전역객체의 메소드임</li>
</ul>
<ol>
<li>eval : 문자열 형태로 매개변수에 전달된 코드를 헌타임에 동적으로 평가하고 실행하여 결과값을 반환</li>
<li>isFinite : 매개변수에 전달된 값이 정상적인 유한수인지 검사하여 불리언 타입으로 반환.</li>
<li>isNaN : 매개변수에 전달된 값이 NaN 인지 검사하여 그 결과를 불리언 타입으로 반환</li>
<li>parseFloat : 매개변수에 전달된 문자열을 부동소수점 숫자로 변환하여 반환(공백이 있으면 첫번째 문자열만 반환</li>
<li>parselnt : 매개변수에 전달된 문자열을 정수형 숫자로 해석해서 반환(반환은 언제나 10진수임)</li>
<li>encodeURI : / decodeURI<ul>
<li>encodeURI는 매개변수로 전달 된 URI를 인코딩한다.</li>
<li>인코딩 이란 URI 문자들을 이스케이프 처리 하는것</li>
<li>이스케이프 처리는 문자를 아스키 문자 set으로 변환하는것</li>
<li>decodeURI는 인코딩 된 문자를 매개변수로 받아 인코딩 이전으로 디코딩 한다.</li>
</ul>
</li>
<li>encodeURIComponent / decodeURIComponent<ul>
<li>encodeURIComponent는 매개변수로 전달 된 URI 구성요소를 인코딩 한다.</li>
<li>쿼리 파라미터의 구분자도 인코딩 한다</li>
</ul>
</li>
</ol>
<h3 id="4-3-암묵적-전역"><a href="#4-3-암묵적-전역" class="headerlink" title="4-3 암묵적 전역"></a>4-3 암묵적 전역</h3><ul>
<li>선언되지 않은 식별자(변수)에 값을 할당하면 자바스크립트 엔진이 암묵적으로 전역 객체의 프로퍼티를 동적 생성하여 값을 할당함</li>
<li>전역 객체의 프로퍼티로 등록 되었을 뿐 변수는 아님</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/15/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-15%20%EC%97%84%EA%B2%A9%EB%AA%A8%EB%93%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-15%20%EC%97%84%EA%B2%A9%EB%AA%A8%EB%93%9C/" class="post-title-link" itemprop="url">엄격 모드</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-15 11:22:00 / Updated at: 12:56:43" itemprop="dateCreated datePublished" datetime="2020-03-15T11:22:00+09:00">2020-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="엄격모드"><a href="#엄격모드" class="headerlink" title="엄격모드"></a>엄격모드</h1><h2 id="1-strit-mode란"><a href="#1-strit-mode란" class="headerlink" title="1. strit mode란?"></a>1. strit mode란?</h2><ul>
<li>오타나 문접 지식의 미비 등으로 인한 실수를 예방하기 위하여 ES5 부터 적용됨</li>
<li>자바 스크립트 언어를 보다 엄격히 적용하여 기존에 무시되던 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 면시적인 에러를 발생시킴</li>
</ul>
<hr>
<h2 id="2-strit-mode의-적용"><a href="#2-strit-mode의-적용" class="headerlink" title="2. strit mode의 적용"></a>2. strit mode의 적용</h2><ul>
<li>strict mode를 적용하려면 전역의 선두 또는 함수 몸체의 선두에 <code>&#39;use strict&#39;;</code> 을 추가시킨다</li>
<li>전역의 선두에 추가하면 스크립트 전체에 strict mode가 적용된다.</li>
<li>함수 몸체 선두에 추가하면 해당 함수와 중첩된 함수에 stric mode가 적용된다</li>
<li>코드의 선두에 stric mode를 위치시키지 않으면 제대로 동작하지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="3-전역에-strict-mode를-적용하는것은-피하자"><a href="#3-전역에-strict-mode를-적용하는것은-피하자" class="headerlink" title="3. 전역에 strict mode를 적용하는것은 피하자"></a>3. 전역에 strict mode를 적용하는것은 피하자</h2><ul>
<li>외부 서드파티 라이브러리를 사용하는 경우, 라이브러리가 non-strict mode일 경우도 있기 때문에 strict mode를 적용하는것은 바람직하지 않다.</li>
</ul>
<hr>
<h2 id="4-함수단위로-strict-mode를-적용하는것도-피하자"><a href="#4-함수단위로-strict-mode를-적용하는것도-피하자" class="headerlink" title="4. 함수단위로 strict mode를 적용하는것도 피하자"></a>4. 함수단위로 strict mode를 적용하는것도 피하자</h2><ul>
<li>어떤함수는 적용하고 어떤함수는 적용하지 않는 것은 바람직하지 않음</li>
<li>함수에 일일히 strict mode를 적용하는 것은 번거로움</li>
<li>stric mode가 적용된 함수가 참조할 함수 외부의 컨텍스트에 strict mode를 적용하지 않는다면 문제가 발생할 가능성이 있음</li>
</ul>
<hr>
<h2 id="5-strict-mode가-발생시키는-에러"><a href="#5-strict-mode가-발생시키는-에러" class="headerlink" title="5. strict mode가 발생시키는 에러"></a>5. strict mode가 발생시키는 에러</h2><ol>
<li>암묵적 전역<ul>
<li>선언하지 않는 변수 참조 시 ReferenceError 발생</li>
</ul>
</li>
<li>변수, 함수, 매개변수의 삭제<ul>
<li>delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생한다.</li>
</ul>
</li>
<li>매개변수 이름의 중복<ul>
<li>중복된 함수 매개변수 이름을 사용하면 SyntaxError 가 발생한다.</li>
</ul>
</li>
<li>with 문의 사용<ul>
<li>whit 문을 사용하면 SyntaxError가 발생한다.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-Strict-mode-적용에-의한-변화"><a href="#6-Strict-mode-적용에-의한-변화" class="headerlink" title="6. Strict mode 적용에 의한 변화"></a>6. Strict mode 적용에 의한 변화</h2><ol>
<li><p>일반 함수의 this</p>
<ul>
<li>strict mode에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩 된다</li>
<li>생성자 함수가 아닌 일반 함수 내부에서는 this를 사용할 필요가 없기 때문이다.</li>
</ul>
</li>
<li><p>argument 객체</p>
<ul>
<li>strict mode 에서는 매개변수에 전달된 인수를 재할당하여 변경하여도 arguments 객체에 반영되지 않는다  </li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/14/%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%97%B0%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/14/%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%97%B0%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/" class="post-title-link" itemprop="url">문제 풀이/알고리즘 연습 문제</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-14 21:17:32 / Updated at: 21:19:58" itemprop="dateCreated datePublished" datetime="2020-03-14T21:17:32+09:00">2020-03-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/" itemprop="url" rel="index">
                    <span itemprop="name">문제풀이</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="알고리즘-연습문제-과제-제출"><a href="#알고리즘-연습문제-과제-제출" class="headerlink" title="알고리즘 연습문제 과제 제출"></a>알고리즘 연습문제 과제 제출</h1><ol>
<li>선형검색<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linearSearch</span>(<span class="params">array, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] === target) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">1</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">3</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">5</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">6</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(linearSearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">-1</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<ol start="2">
<li>이진 검색<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">array, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (array[mid] &lt; target) start = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; target) end = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] === target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">1</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">5</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">8</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">70</span>], <span class="number">15</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">7</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], <span class="number">-5</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<ol start="3">
<li>버블 정렬<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sort = array;</span><br><span class="line">  <span class="keyword">let</span> range = array.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; range; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sort[j] &gt; sort[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">const</span> now = sort[j];</span><br><span class="line">        <span class="keyword">const</span> next = sort[j + <span class="number">1</span>];</span><br><span class="line">        sort[j] = next;</span><br><span class="line">        sort[j + <span class="number">1</span>] = now;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    range -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sort;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>])); <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort([<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>])); <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort([<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>])); <span class="comment">// [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/11/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-12%20%EC%98%88%EC%8A%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/11/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-12%20%EC%98%88%EC%8A%B5/" class="post-title-link" itemprop="url">프로토타입</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-03-11 19:11:41" itemprop="dateCreated datePublished" datetime="2020-03-11T19:11:41+09:00">2020-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-12 20:26:11" itemprop="dateModified" datetime="2020-03-12T20:26:11+09:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h1><hr>
<h2 id="1-객체지향-프로그래밍"><a href="#1-객체지향-프로그래밍" class="headerlink" title="1. 객체지향 프로그래밍"></a>1. 객체지향 프로그래밍</h2><p>객체 지향 프로그래밍은 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적의 관점에서 벗어나 객체들의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임</p>
<ul>
<li>객체는 속성을 통해 여려개의 값을 하나의 단위로 구성한 복합적인 자료구조 임</li>
</ul>
<hr>
<h2 id="2-상속과-프로토타입"><a href="#2-상속과-프로토타입" class="headerlink" title="2. 상속과 프로토타입"></a>2. 상속과 프로토타입</h2><ul>
<li>상속은 어떤 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용 할 수 있는것을 말함.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea());</span><br><span class="line"><span class="built_in">console</span>.log(circle2.getArea());</span><br></pre></td></tr></table></figure></li>
<li>위 예제의 코드를 보면 getArea 메소드는 언제나 변하지 않지만 생성자 함수로 인스턴스가 만들어 질 때마다 중복 생성된다.(getArea가 this로 바인딩 되어 인스턴스의 프로퍼티로 들어감)</li>
<li>생성자 함수로 생성된 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 메모리를 불필요하게 낭비함</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea());</span><br><span class="line"><span class="built_in">console</span>.log(circle2.getArea());</span><br></pre></td></tr></table></figure>
<ul>
<li>위외 같이 Circle 생성자 함수의 프로토타입에 메소드를 동적 할당하여 인스턴스의 메소드 중복을 해결할 수 있다.</li>
<li>생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입의 모든 프로퍼티와 메소드를 상속 받는다.</li>
</ul>
<hr>
<h2 id="3-프로토타입-객체"><a href="#3-프로토타입-객체" class="headerlink" title="3. 프로토타입 객체"></a>3. 프로토타입 객체</h2><ul>
<li>프로토타입 객체란 객체간 상속을 구현하기 위해 사용된다.</li>
<li>프로토타입은 어떤 객체의 상위 역할을 하는 객체로써 다른 객체에 공유 프로퍼티를 제공한다.</li>
<li>프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티 처럼 자유롭게 사용할 수 있다.</li>
</ul>
<h3 id="3-1-proto-접근자-프로퍼티"><a href="#3-1-proto-접근자-프로퍼티" class="headerlink" title="3-1 proto 접근자 프로퍼티"></a>3-1 <strong>proto</strong> 접근자 프로퍼티</h3><ul>
<li>모든 객체는 <strong>proto</strong>접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 접근할 수 있음.</li>
<li><em><strong>proto</strong>는 접근자 프로퍼티이다</em></li>
<li>[[Prototype]] 내부슬롯은 프로퍼티가 아니기 때문에 직접 접근할 수 없으며 <strong>proto</strong>접근자 프로퍼티를 통해 간접적으로 접근할 수 있다.</li>
<li>Object.getOwnPropertyDescriptor 로 <strong>proto</strong>에 접근하면 접근자 프로퍼티의 어트피뷰트가 출력 됨</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> parent = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">// null : obj객체의 프로토타입은 null</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.y, obj.x); <span class="comment">// 2 undefined : obj 객체에는 현재 y프로퍼티만 존재</span></span><br><span class="line"></span><br><span class="line">obj.__proto__ = parent; <span class="comment">// obj객체의 __proto__ setter함수에 parent객체를 할당</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">// Object &#123;x: 1&#125; : obj 객체의 프로토타입에 obj객체가 할당 됨</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.y, obj.x); <span class="comment">// 2 1 : obj 객체가 parent객체의 x 프로퍼티를 상속받아 출력</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><em><strong>proto</strong>접근자 프로퍼티는 상속을 통해 사용된다.</em></p>
</li>
<li><p><strong>proto</strong>접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티 이다.</p>
</li>
<li><p>모든 객체는 상속을 통해 Object.prototype.<strong>proto</strong>접근자 프로퍼티를 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">'song'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">'__proto__'</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="comment">// person 객체는 __proto__프로퍼티를 소유하지 않는다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype, <span class="string">'__proto__'</span>))</span><br><span class="line"><span class="comment">// Object &#123;get: function get __proto__(), set: function set __proto__(), enumerable: false, configurable: true&#125;</span></span><br><span class="line"><span class="comment">// __proto__ 프포퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티 이다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;.__proto__ === <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="comment">// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>프로토타입 체인</p>
<ul>
<li>모든 객체는 프로토타입 계층 구조인 프로토타입 체인에 묶여있다. </li>
<li>자바스크립트 엔진은 객체의 프로퍼티에 접근하려고 할때 해당 객체에 접근하려는 프로퍼티가 없다면 <strong>proto</strong>접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다.</li>
<li>프로토타입 체인의 최상위 객체는 Object.prototype 이며 이 객체의 프로퍼티와 메소드는 모든 객체에게 상속된다.</li>
</ul>
</li>
<li><p><strong>proto</strong>접근자 프로퍼티를 통해 프로토타입에 접근하는 이유</p>
<ul>
<li>[[Prototype]] 내부 슬롯의 값, 즉 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함임 </li>
</ul>
</li>
<li><p>프로토타입 체인은 단방향 링크드 리스트로 구현되어야 함.</p>
</li>
<li><p><em><strong>proto</strong>접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 비추천</em></p>
</li>
<li><p>프로토타입의 참조를 취득할 경우는 <strong>Object.getPrototypeOf</strong> 메소드를 사용하는 것이 좋다</p>
</li>
<li><p>프로토타입을 교체하는 경우는 <strong>Object.setProtypeOf</strong> 메소드를 사용하는 것이 좋다.</p>
</li>
</ul>
<h3 id="3-2-함수-객체의-prototype-프로퍼티"><a href="#3-2-함수-객체의-prototype-프로퍼티" class="headerlink" title="3-2 함수 객체의 prototype 프로퍼티"></a>3-2 함수 객체의 prototype 프로퍼티</h3><ul>
<li>함수 객체는 <strong>proto</strong>접근자 프로퍼티 이오에 protype 프로퍼티도 소유한다. </li>
<li>함수 객체의 protopype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가르킨다.</li>
<li>prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다.</li>
<li>모든 객체가 가지고 있는 <strong>proto</strong>접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 객체를 가리키자만 이들 프로퍼티를 사용하는 주체가 다르다<table>
<thead>
<tr>
<th>구분</th>
<th>소유</th>
<th>값</th>
<th>사용주체</th>
<th>사용목적</th>
</tr>
</thead>
<tbody><tr>
<td><strong>proto</strong>접근자 프로퍼티</td>
<td>모든객체</td>
<td>프로토타입의 참조</td>
<td>모든 객체</td>
<td>모든 객체가 상속을 위해 자신의 프로토타입에 접근하기 위해 사용</td>
</tr>
<tr>
<td>prototype 프로퍼티</td>
<td>함수객체</td>
<td>프로토타입의 참조</td>
<td>생성자 함수</td>
<td>생성자 함수가 자신이 생성할 인스턴스의 프포토타입을 할당하기 위해 사용</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="3-3-프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#3-3-프로토타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="3-3 프로토타입의 constructor 프로퍼티와 생성자 함수"></a>3-3 프로토타입의 constructor 프로퍼티와 생성자 함수</h3><ul>
<li>모든 프로토타입은 constructor 프로퍼티를 갖는다.</li>
<li>이 constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.</li>
<li>이 연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이루어진다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Song'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me.__proto__ === Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 인스턴스의 __proto__ 접근자 프로퍼티는 생성자 함수의 prototype을 가르킴</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 프로토타입에서 상속받은 constructor 프로퍼티는 생성자 함수를 가르킴</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// prototype의 constructor 프로퍼티는 생성자 함수를 가르킴</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.hasOwnProperty(<span class="string">'constructor'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 생성자 함수는 constructor 프로퍼티를 갖지 않음</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.hasOwnProperty(<span class="string">'constructor'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 프로토타입은 constructor 프로퍼티를 갖음</span></span><br><span class="line"><span class="built_in">console</span>.log(me.hasOwnProperty(<span class="string">'constructor'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 인스턴스는 constructor 프로퍼티를 직접 갖지 않고 프로토타입에서 상속받음</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입"><a href="#4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입" class="headerlink" title="4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입"></a>4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</h2><ul>
<li><p>생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결되는데 이때 생성자 함수는 인스턴스를 생성한 생성자 함수이다.</p>
</li>
<li><p>리터럴 표기법에 의한 객체 생성 방식과 같이 명시적으로 new연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하지 않는 객체 생성방식도 존재함</p>
</li>
<li><p>리터럴 표기법에 의해 생성된 객체도 물론 프로토타입이 존재함</p>
</li>
<li><p>하지만 리터럴 표기법에 의해 생성된 객체의 경우, 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 할 수 없음</p>
</li>
<li><p><strong>Object 생성자 함수와 객체 리터럴로 생성된 객체는 추상연산 Object.Create를 호출하여 빈 객체를 생성하는것은 동일하나 세부 내용은 다름으로 객체 리터럴에 의해 생성된 객체는 Object생성자 함수가 생성한 객체가 아니다</strong></p>
</li>
<li><p>리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요하다.</p>
</li>
<li><p>따라서 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 갖는다.</p>
</li>
<li><p>프로토타입은 생성자 함수와 더불어 생성되며 prototype, constructor 프로퍼티에 의해 연경되어 있다.</p>
</li>
<li><p>프로토타입과 생성자함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다.</p>
</li>
</ul>
<hr>
<h2 id="5-프로토타입의-생성-시점"><a href="#5-프로토타입의-생성-시점" class="headerlink" title="5. 프로토타입의 생성 시점"></a>5. 프로토타입의 생성 시점</h2><ul>
<li>생성자 함수는 사용자가 직접 정의한 사용자 정의 생성자 함수와 자바스크립트가 기본 제공하는 빌트인 생성자 함수로 구분할 수 있다.</li>
<li>프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.</li>
</ul>
<h3 id="5-1-사용자-정의-생성자-함구와-프로토타입-생성-시점"><a href="#5-1-사용자-정의-생성자-함구와-프로토타입-생성-시점" class="headerlink" title="5-1 사용자 정의 생성자 함구와 프로토타입 생성 시점"></a>5-1 사용자 정의 생성자 함구와 프로토타입 생성 시점</h3><ul>
<li>생성자 함수로서 호출할 수 있는 함수, 즉 constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더물어 생성된다.</li>
<li>빌트인 생성자 함수가 아닌 사용자 정의 생성자 함수는 자신이 평가되어 함수 객체로 생성되는 시점에 프로토타입도 더불어 생성되며 생성된 프로토타입은 언제나 Object.prototype이다.</li>
</ul>
<h3 id="5-2-빌트인-생성자-함수와-프로토타입-생성-시점"><a href="#5-2-빌트인-생성자-함수와-프로토타입-생성-시점" class="headerlink" title="5-2 빌트인 생성자 함수와 프로토타입 생성 시점"></a>5-2 빌트인 생성자 함수와 프로토타입 생성 시점</h3><ul>
<li>빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성 됨</li>
<li>모든 빌트인 생성자 함는 전역객체가 생성되는 시점에 생성된다.</li>
</ul>
<hr>
<h2 id="6-객체-생성-방식과-프로토타입의-결정"><a href="#6-객체-생성-방식과-프로토타입의-결정" class="headerlink" title="6. 객체 생성 방식과 프로토타입의 결정"></a>6. 객체 생성 방식과 프로토타입의 결정</h2><ul>
<li>객체는 아래와 같이 다양한 생성 방법이 있다<ul>
<li>객체 리터럴</li>
<li>Object 생성자 함수</li>
<li>생성자 함수</li>
<li>Object.create 메소드</li>
<li>클래스 (ES6)</li>
</ul>
</li>
<li>이와 같이 다양한 방식으로 생성된 모든 객체는 각각의 방식마다 세부적인 객체 생성 방식의 차이는 있으나 추상 연산 ObjectCreate에 의해 생성된다는 공통점을 갖는다.</li>
</ul>
<h3 id="6-1-객체-리터럴에-의해-생성된-객체의-프로토타입"><a href="#6-1-객체-리터럴에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-1 객체 리터럴에 의해 생성된 객체의 프로토타입"></a>6-1 객체 리터럴에 의해 생성된 객체의 프로토타입</h3><ul>
<li>자바스크립트 엔진은 객체 리터럴을 평가하여 생성할 때, 추상연산 ObjectCreate를 호출한다.</li>
<li>이때 추상연산 ObjectCreate에 전달되는 프로토타입은 Object.protype이다. </li>
<li>즉, 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype이다.</li>
</ul>
<h3 id="6-2-Object-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#6-2-Object-생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-2 Object 생성자 함수에 의해 생성된 객체의 프로토타입"></a>6-2 Object 생성자 함수에 의해 생성된 객체의 프로토타입</h3><ul>
<li>명시적으로 Object생성자 함수를 호출하여 객체를 생성하면 빈 객체가 생성된다.</li>
<li>Object 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 추상 연산 ObjectCreate를 호출한다.</li>
<li>Object 생성자 함수가 빈객체를 만든다는 것을 제외하면 객체 리터럴 방식과 동일한 구조이다.</li>
</ul>
<h3 id="6-3-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#6-3-생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-3 생성자 함수에 의해 생성된 객체의 프로토타입"></a>6-3 생성자 함수에 의해 생성된 객체의 프로토타입</h3><ul>
<li>new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 방식과 마찬가지로 추상 연산 ObjectCreate를 호출한다.</li>
<li>이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩 되어있는 객체이다.</li>
<li>즉 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 protype 프로퍼티에 바인딩 되어있는 객체이다.</li>
<li>생성자 함수를 통해 생성된 모든 객체는 프로토타입에 추가된 메소드를 프로퍼티를 상속받아 자신의 프로퍼티 처럼 사용할 수 있다.</li>
</ul>
<hr>
<h2 id="7-프로토타입-체인"><a href="#7-프로토타입-체인" class="headerlink" title="7. 프로토타입 체인"></a>7. 프로토타입 체인</h2><ul>
<li>자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <strong>proto</strong>접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색하고 이것을 프로토타입 체인이라고 한다.</li>
<li>프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘이다.</li>
<li>프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype이다. 따라서 모든 객체는 Object.prototype을 상속받는다.</li>
<li>프로토타입 에인의 종점인 Object.prototype에서도 프로퍼티를 검색할 수 없는 경우 undefined를 반환한다.</li>
</ul>
<p><strong>프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘, 스코프체인은 식별자 검색을 위한 메커니즘</strong></p>
<hr>
<h2 id="8-캡슐화"><a href="#8-캡슐화" class="headerlink" title="8. 캡슐화"></a>8. 캡슐화</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'song'</span>);</span><br><span class="line"></span><br><span class="line">me.sayHello() <span class="comment">// Hi my name is song</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>위 코드와 같이 즉시실행 함수를 사용하여 생성자 함수와 프로토타입을 확장하는 코드를 하나의 함수 내에 깔끔하게 모을 수 있다.</p>
</li>
<li><p>위 패턴을 사용하면 캡슐화를 쉽게 구현할 수 있다.</p>
</li>
<li><p>켭슐화는 정보의 일부를 외부에 노출되지 않도록 감추어 적절하지 못한 접근으로부터 정보를 보호하고 객체간의 상호 의존성, 즉 결합도를 낮추는 효과가 있다.</p>
</li>
<li><p>현재 위 코드의 name 프로퍼티는 현재 외부로 노출되어 있어서 자유롭게 변경할 수 있다.</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _name = <span class="string">''</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi my name is <span class="subst">$&#123;_name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'song'</span>);</span><br><span class="line"></span><br><span class="line">me.sayHello() <span class="comment">// Hi my name is song </span></span><br><span class="line"></span><br><span class="line">me._name = <span class="string">'Kim'</span>;</span><br><span class="line">me.sayHello() <span class="comment">// Hi my name is song </span></span><br><span class="line"><span class="comment">// _name은 지역변수 이기 때문에 외부에서 함부로 변경 할 수 없다</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-오버라이딩과-프로퍼티-쉐도잉"><a href="#9-오버라이딩과-프로퍼티-쉐도잉" class="headerlink" title="9. 오버라이딩과 프로퍼티 쉐도잉"></a>9. 오버라이딩과 프로퍼티 쉐도잉</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'song'</span>);</span><br><span class="line"></span><br><span class="line">me.sayHello(); <span class="comment">// Hi my name is song </span></span><br><span class="line"></span><br><span class="line">me.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hey my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">me.sayHello(); <span class="comment">// Hey my name is song </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> you = <span class="keyword">new</span> Person(<span class="string">'Kim'</span>);</span><br><span class="line">you.sayHello(); <span class="comment">// Hi my name is Kim</span></span><br></pre></td></tr></table></figure>
<ul>
<li>프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색하여 프로토타입 프로퍼티를 덮어쓰는것이 아닌 인스턴스 프로퍼티로 추가한다.</li>
<li>이때 인스턴스 메소드는 프로토타입 메소드를 오버라이딩 하였고 프로토타입 메소드는 가려진다(프로퍼티 쉐도잉)</li>
<li>프로토타입을 삭제하는 경우도 마찬가지로 인스턴스 프로퍼티가 삭제된다</li>
</ul>
<hr>
<h2 id="10-프로토타입-교체"><a href="#10-프로토타입-교체" class="headerlink" title="10. 프로토타입 교체"></a>10. 프로토타입 교체</h2><ul>
<li>프로토타입은 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있당는것을 의미한다.</li>
<li>프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있다.</li>
</ul>
<h3 id="10-1-생성자-함수에-의한-프로토타입의-교체"><a href="#10-1-생성자-함수에-의한-프로토타입의-교체" class="headerlink" title="10-1 생성자 함수에 의한 프로토타입의 교체"></a>10-1 생성자 함수에 의한 프로토타입의 교체</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생성자 함수를 통한 prototype을 객체리터럴로 교체</span></span><br><span class="line">  Person.prototype = &#123; </span><br><span class="line">    <span class="keyword">constructor</span>: Person, // prototype 교체 시 <span class="keyword">constructor</span> 연결이 해제됨으로 생성자 함수간 링크를 설정해 준다</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hi my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'song'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위 코드의 객체 리터럴은 constructor 프로퍼티가 없음으로 생성자 함수와 프로토타입간의 링크가 파괴됨</li>
<li>교체한 객체 리터럴 내부에 constructor 프로퍼티를 추가하여 프로토타입의 constructor 프로퍼티를 되살림</li>
</ul>
<h3 id="10-3-인스턴스에-의한-프로토타입의-교체"><a href="#10-3-인스턴스에-의한-프로토타입의-교체" class="headerlink" title="10-3 인스턴스에 의한 프로토타입의 교체"></a>10-3 인스턴스에 의한 프로토타입의 교체</h3><ul>
<li>프로토타입은 생성자 함수의 prototype 프로퍼티 뿐만 아니라 인스턴스의 <strong>proto</strong>접근자 프로퍼티로 접근할 수 있다.</li>
<li>생성자 함수의 prototype 프로퍼티에 다른 임의의 객체를 바인딩 하는것은 미래에 생성할 인스턴스의 프로토타입을 교체하는 것이다.</li>
<li><strong>proto</strong>접근자 프로퍼티를 통해 프로토타입을 교체하는것은 이미 생성된 프로토타입을 교체하는 것이다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Song'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person, // prototype 교체 시 <span class="keyword">constructor</span> 연결이 해제됨으로 생성자 함수간 링크를 설정해 준다</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = parent;</span><br><span class="line"><span class="comment">// 인스턴스에 의한 프로토타입 교체 시 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가르키지 않음으로 명시적으로 지정</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(me, parent);</span><br><span class="line"></span><br><span class="line">me.sayHello();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === <span class="built_in">Object</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype === <span class="built_in">Object</span>.getPrototypeOf(me)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="11-instanseof-연산자"><a href="#11-instanseof-연산자" class="headerlink" title="11. instanseof 연산자"></a>11. instanseof 연산자</h2><ul>
<li>instanceof 연산자는 이항 연산자로써 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 피연산자로 받는다</li>
<li>우변의 피연산자가 함수가 아닌 경우 TypeError가 발생한다.<br><code>객체 instanceof 생성자함수</code></li>
<li>좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스라면 true로 평가되고 그렇지 않은 경우에는 false로 평가된다.</li>
<li>instanseof 연산자는 상속관계를 고려한다.</li>
</ul>
<hr>
<h2 id="12-직접상속"><a href="#12-직접상속" class="headerlink" title="12. 직접상속"></a>12. 직접상속</h2><h3 id="12-1-Object-create에-의한-직접-상속"><a href="#12-1-Object-create에-의한-직접-상속" class="headerlink" title="12-1 Object.create에 의한 직접 상속"></a>12-1 Object.create에 의한 직접 상속</h3><ul>
<li><p>Object.create 메소드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.</p>
</li>
<li><p>Object.create 메소드도 다른 객체 생성 방식과 마찬가지로 추상연산 ObjectCreate를 호출한다.</p>
</li>
<li><p>Object.create 메소드의 첫번째 매개변수에는 생성할 객체의 프로토타입으로 지정할 객체를 전달한다.</p>
</li>
<li><p>두번째 매개변수에는 생성할 객체의 프로퍼티를 갖는 객체를 전달한다.</p>
</li>
<li><p>이 메소드의 형식은 Object.define.Propertyies 메소드의 두번째 인수와 동일하다.</p>
</li>
<li><p>두번째 인수는 옵션이므로 생략 가능하다.</p>
</li>
<li><p>Object.create 메소드의 장점</p>
<ul>
<li>new 연산자가 없이도 객체를 생성할 수 있다</li>
<li>프로토타입을 지정하면서 객체를 생성할 수 있다. 이때 생성자 함수와 프로토타입 간의 링크가 파괴되지 않는다.</li>
<li>객체 리터럴에 의해 생성된 객체도 특정 객체를 상속받을 수 있다.</li>
</ul>
</li>
<li><p>Object.create 메소드의 단점</p>
<ul>
<li>프로토타입 종점에 위치하는 객체를 생성할수 있음</li>
</ul>
</li>
</ul>
<h3 id="12-2-객체-리터럴-내부에서-proto-에-의한-직접-상속"><a href="#12-2-객체-리터럴-내부에서-proto-에-의한-직접-상속" class="headerlink" title="12-2 객체 리터럴 내부에서 __proto_에 의한 직접 상속"></a>12-2 객체 리터럴 내부에서 __proto_에 의한 직접 상속</h3><ul>
<li>Object.create 메소드 사용의 경우 두번째 인자로 프로퍼티를 정의하는것이 번거롭다</li>
<li>ES6 에서는 객체 리터럴 내부에서 __proto_접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myProto = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  y: <span class="number">20</span>,</span><br><span class="line">  __proto__: myProto</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.x, obj.y); <span class="comment">// 10 20</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj) === myProto); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<ol start="13">
<li>정적 프로퍼티 / 메소드</li>
</ol>
<ul>
<li>정적 프로퍼티/메소드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드를 말한다.</li>
<li>생성자 함수가 생성한 인스턴스는 자신의 프로토타입 체인에 속한 프로퍼티/메소드에 접근할 수 있다</li>
<li>정적 프로퍼티/메소드는 인스턴스의 프로토타입 체인에 속한 객체의 프로퍼티/메소드가 아니므로 인스턴스로 접근할 수 없다.</li>
</ul>
<hr>
<h2 id="14-프로퍼티-존재-확인"><a href="#14-프로퍼티-존재-확인" class="headerlink" title="14. 프로퍼티 존재 확인"></a>14. 프로퍼티 존재 확인</h2><ul>
<li>in 연산자는 객체 내에 프로퍼티가 존재하는지 여부를 확인한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Song'</span>,</span><br><span class="line">  address: <span class="string">'Paju'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'address'</span> <span class="keyword">in</span> person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'age'</span> <span class="keyword">in</span> person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>in 연산자는 확인 대상 객체의 프로퍼티 뿐만 아니라 확인 대상 객체가 상속받은 모든 프로토타입 프로퍼티를 확인하므로 주의해야한다.</li>
</ul>
<hr>
<h2 id="15-프로퍼티-열거"><a href="#15-프로퍼티-열거" class="headerlink" title="15. 프로퍼티 열거"></a>15. 프로퍼티 열거</h2><h3 id="15-1-for…in문"><a href="#15-1-for…in문" class="headerlink" title="15.1 for…in문"></a>15.1 for…in문</h3><ul>
<li>객체의 모든 프로퍼티를 순회하며 열거하려면 for…in문을 사용한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Song'</span>,</span><br><span class="line">  address: <span class="string">'Paju'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">': '</span> + person[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-2-Object-keys-values-entries"><a href="#15-2-Object-keys-values-entries" class="headerlink" title="15.2 Object.keys/values/entries"></a>15.2 Object.keys/values/entries</h3><ul>
<li><p>for…in문은 객체 자신의 프로퍼티 뿐만 아니라 상속받은 프로퍼티도 열거하기 때문에 Object.prototype.hasOwnProperty 메소드를 사용하여 객체 자신의 프로퍼티 인지 확인하는 추가 처리가 필요하다</p>
</li>
<li><p>객체 자신의 프로퍼티 만을 열거하기 위해서는 for…in문을 사용하는것 보다 Object.key/values/entries 메소드를 사용하는것을 권장한다.</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Song'</span>,</span><br><span class="line">  address: <span class="string">'Paju'</span>,</span><br><span class="line">  __proto__: &#123; <span class="attr">age</span>: <span class="number">32</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!person.hasOwnProperty(key)) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">': '</span> + person[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person)); <span class="comment">// ["name", "address"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(person)); <span class="comment">// ["Song", "Paju"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(person)); <span class="comment">// [Array[2], Array[2]]</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/10/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-10%20%EC%98%88%EC%8A%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/10/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-03-10%20%EC%98%88%EC%8A%B5/" class="post-title-link" itemprop="url">JS 수업 예습/2020-03-10 예습</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-10 17:34:45 / Updated at: 17:38:26" itemprop="dateCreated datePublished" datetime="2020-03-10T17:34:45+09:00">2020-03-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="생성자-함수에-의한-객체-생성"><a href="#생성자-함수에-의한-객체-생성" class="headerlink" title="생성자 함수에 의한 객체 생성"></a>생성자 함수에 의한 객체 생성</h1><h2 id="1-Object-생성자-함수"><a href="#1-Object-생성자-함수" class="headerlink" title="1. Object 생성자 함수"></a>1. Object 생성자 함수</h2><ul>
<li>new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다.</li>
<li>빈객체를 생성한 이후 프로퍼티 또는 메소드를 추가하여 객체를 완성할 수 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//빈객채의 생성</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> ObjectW();</span><br><span class="line"></span><br><span class="line"><span class="comment">//프로퍼티 추가</span></span><br><span class="line">person.name = <span class="string">'Song'</span>;</span><br><span class="line">person.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi! My Name is '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// Object &#123;name: "Song", sayHello: function ()&#125;</span></span><br><span class="line">person.sayHello(); <span class="comment">// Hi! My Name is Song</span></span><br></pre></td></tr></table></figure>
<ul>
<li>생성자 함수란 new 연산자와 함께 호출하여 격체(인스턴스)를 생성하는 함수를 말한다.</li>
<li>생성자 함수에 의해 생성된 객채를 인스턴스라 한다.</li>
</ul>
<h2 id="2-생성자-함수"><a href="#2-생성자-함수" class="headerlink" title="2. 생성자 함수"></a>2. 생성자 함수</h2><h3 id="2-1-객체-리터럴에-의한-객체-생성-방식의-문제점"><a href="#2-1-객체-리터럴에-의한-객체-생성-방식의-문제점" class="headerlink" title="2-1 객체 리터럴에 의한 객체 생성 방식의 문제점"></a>2-1 객체 리터럴에 의한 객체 생성 방식의 문제점</h3><ul>
<li>객체 리터럴에 의한 객체 생성 방식은 간편하지만 단 하나의 객채만을 생성하기 때문에 동일한 프로퍼티를 갖는 객채를 여러개 생성하는 경우 비효율적임</li>
</ul>
<h3 id="2-2-생성자-함수에-의한-객체-생성-방식의-장점"><a href="#2-2-생성자-함수에-의한-객체-생성-방식의-장점" class="headerlink" title="2-2 생성자 함수에 의한 객체 생성 방식의 장점"></a>2-2 생성자 함수에 의한 객체 생성 방식의 장점</h3><ul>
<li>생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스) 처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러개를 간편하게 생성할 수 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//생성자함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>); <span class="comment">// 반지름이 5인 Circle객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">10</span>); <span class="comment">//  반지름이 10인 Circle 객체를 생성</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getDiameter()); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getDiameter()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p><strong>this : this 는 객체 자신의 프로퍼티나 메소드를 함조하기 위한 자기 함조변수이다. this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다</strong></p>
<table>
<thead>
<tr>
<th>함수 호출 방식</th>
<th>this가 가리키는 값</th>
</tr>
</thead>
<tbody><tr>
<td>일반 함수로서 호출</td>
<td>전역 객체</td>
</tr>
<tr>
<td>메소드로서 호출</td>
<td>메소드를 호출한 객체</td>
</tr>
<tr>
<td>생성자 함수로서 호출</td>
<td>생성자 함수가 생성할 인스턴스</td>
</tr>
</tbody></table>
<ul>
<li>생성자 함수는 말 그대로 객체(인스턴스)를 생성하는 함수이다</li>
<li>자바와 같은 클래스 기반 객체지향 언어의 생성자 와는 다르게 그 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 <strong>new연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.</strong></li>
</ul>
<h3 id="2-3-내부-메소드-Call-과-Construct"><a href="#2-3-내부-메소드-Call-과-Construct" class="headerlink" title="2-3 내부 메소드 [[Call]] 과 [[Construct]]"></a>2-3 내부 메소드 [[Call]] 과 [[Construct]]</h3><ul>
<li>함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로써 호출할 수 있는것을 물론 생성자 ㅎ마수로서 호출할 수 있다.</li>
<li>생성자 함수로써 호출된다는 것은 new연산자와 함께 호출하여 객체를 생성하는것을 의미한다.</li>
<li>함수는 객체이므로 일반 객체와 동일하게 동작할 수 있다.</li>
<li>함수 객체는 일반 객체의 내부 슬롯과 내부 메소드를 모두 가지고 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수는 객체이다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 객체이므로 프로퍼틸를 소유할 수 있다</span></span><br><span class="line">foo.prop = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 객체이므로 메소드를 소유할 수 있다.</span></span><br><span class="line">foo.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.prop);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.method();</span><br></pre></td></tr></table></figure>
<ul>
<li>내부 메소드 [[Call]]을 갖는 함수 객체를 callable이라 하며, 내부 메소드인 [[Construct]]를 갖는 함수 객체를 constructor, [[Construct]]를 갖지 않은 함수 객체를 non-constructor라고 부른다</li>
<li>callable은 호출할 수 있는 객체, 즉 함수를 말하며, constructor는 생성자 함수로서 호출할 수 있는 객체를 의미한다.</li>
<li>생성자 함수로서 호출될 수 있다는 것은 new연산자와 함께 호출되는 것을 의미한다.</li>
<li>함수가 일밙적인 함수로서 호출되면 함수 객체의 내부 메소드 [[Call]]가 먼저 호출되고 new연산자와 함께 생성자 함수로서 호출되면 내부 메소드 [[Construct]]가 호출된다</li>
<li>모든 함수 객체는 내부 메소드 [[Call]]을 갖고 있으므로 호출할 수 있다.</li>
<li>하지만 모든 함수 객체가 [[Construct]]를 갖지는 않는다.</li>
</ul>
<h3 id="2-4-constructor와-non-constructor의-구분"><a href="#2-4-constructor와-non-constructor의-구분" class="headerlink" title="2-4 constructor와 non-constructor의 구분"></a>2-4 constructor와 non-constructor의 구분</h3><ul>
<li>자바 스크립트 엔진은 함수를 생성 할 때 FunctionCrreate라는 추정 연산을 사용한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일반 함수 정의 : kind = 'Normal'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//  프로퍼티 x에 할당된 것은 일반 함수 정의이다. 메소드 정의로 인정하지 않는다.</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;</span><br><span class="line">  x: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반함수로 정의된 함수만이 constructor이다</span></span><br><span class="line"><span class="keyword">new</span> foo(); <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">new</span> bar(); <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">new</span> baz.x(); <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 화살표 함수 정의 : kind = 'Arrow'</span></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> arrow(); <span class="comment">// typeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드 정의 : kind = 'Method'</span></span><br><span class="line"><span class="comment">// ES6의 메소드 축약 표현만을 메소드 정의로 인정한다.</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> obj.x(); <span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-5-생성자-함수의-인스턴스-생성과정"><a href="#2-5-생성자-함수의-인스턴스-생성과정" class="headerlink" title="2-5 생성자 함수의 인스턴스 생성과정"></a>2-5 생성자 함수의 인스턴스 생성과정</h3><ul>
<li>생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿으로서 동작하여 인스턴스를 생성하는것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것이다</li>
<li>생성자 함수가 인스턴스를 생성하는것은 필수이고, 생성된 인스턴스를 초기화 하는것은 옵션이다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//생성자함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 인스턴스 초기화</span></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>); <span class="comment">// 반지름이 5인 Circle객체를 생성</span></span><br></pre></td></tr></table></figure>
<ul>
<li>함수 내부의 코드를 살펴보면 this에 프로퍼티를 추가하고 필요에 따라 인수로 전달된 초기값을 프로퍼티 값으로 할당한다.</li>
<li>자바 스크입트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다. new 연산자와 함께 생성자 함수가 호출되면 자바 스크립트 엔진은 아래와 같은 과정을 거쳐 인스턴스를 생성하고 초기화 한 후, 인스턴스를 반환한다.<ol>
<li>인스턴스 생성과 this 바인딩<ul>
<li>암묵적으로 빈 객체가 생선된다. 이 빈객체가 바로 생성자 함수가 생선한 인스턴스이다. 그리고 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩 된다.</li>
</ul>
</li>
<li>인스턴스 초기화<ul>
<li>생성자 함수에 기술되어 있는 코드가 실행되어 this에 바인딩 되어있는 인스턴스를 초기화 한다. 즉 this에 바인딩 되어 있는 인스턴스에 프로퍼티나 메소드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화 하거나 고정값을 할당한다.</li>
</ul>
</li>
<li>인스턴스 반환<ul>
<li>생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩 된 this가 암묵적으로 반환된다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="2-6-new연산자"><a href="#2-6-new연산자" class="headerlink" title="2-6 new연산자"></a>2-6 new연산자</h4><ul>
<li>new 연산자와 함께 생ㅅ어자 람수에 의해 생선된 객체(인스턴스)는 프로토 타입에의해 생성자 함수와 연결된다. 이를 이용해 new연산자와 함께 호출 되었는지를 확인할 수 있다.</li>
</ul>
<h1 id="함수와-일급객체"><a href="#함수와-일급객체" class="headerlink" title="함수와 일급객체"></a>함수와 일급객체</h1><h2 id="1-일급객체"><a href="#1-일급객체" class="headerlink" title="1. 일급객체"></a>1. 일급객체</h2><ol>
<li>무명의 리터럴로 생성할 수 있다. 즉 런타임에 생성이 가능하다.</li>
<li>변수나 자료구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개변수에게 전달 할 수 있다.</li>
<li>함수의 결과값으로 반환 할 수 있다.</li>
</ol>
<p><strong>함수형 프로그래밍</strong></p>
<ul>
<li><p>함수형 프로그래밍은 순수함수와 보조함수의 조합을 통해 외부상태를 변경하는 부수효과를 최소화하여 불변성을 지향하는 프로그래밍</p>
</li>
<li><p>함수는 객체이지만 일반 객체와는 차이가 있다. 일반 객체는 호출할 수 없지만 함수 객체는 호출할 수 있다. 그리고 함수 객체에는 일반 객체에 없는 함수 고유의 프로퍼티를 소유한다.</p>
</li>
</ul>
<h2 id="2-함수-객체의-프로퍼티"><a href="#2-함수-객체의-프로퍼티" class="headerlink" title="2. 함수 객체의 프로퍼티"></a>2. 함수 객체의 프로퍼티</h2><ol>
<li>argument 프로퍼티<ul>
<li>함수 호출 시 전달 된 인수들의 정보를 담고 있는 유사배열 객체</li>
<li>함수 내부에서 지역변수처럼 사용</li>
<li>함수 외부에서 사용할 수 없음</li>
<li>매개변수 개수를 확정할 수 없는 가변인자 함수를 구현할 때 유용하게 사용됨</li>
</ul>
</li>
<li>caller 프로퍼티</li>
<li>length 프로퍼티 함수 객체의 length 프로퍼티는 함수 정의 시 선언한 매개변수의 개수를 가리킴</li>
<li>name 프포퍼티 : 함수 객체의 name 프로퍼티는 함수 이름을 나타낸다.</li>
<li><em>_Proto</em> 접근자 프로퍼티</li>
<li>prototype 프로퍼티</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/02/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/03-02%20%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%20%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/03-02%20%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%20%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/" class="post-title-link" itemprop="url">JS 수업 예습/03-02 프로퍼티 어트리뷰트</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-03-02 16:26:02" itemprop="dateCreated datePublished" datetime="2020-03-02T16:26:02+09:00">2020-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-03 10:50:03" itemprop="dateModified" datetime="2020-03-03T10:50:03+09:00">2020-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="프로퍼티-어트리뷰트"><a href="#프로퍼티-어트리뷰트" class="headerlink" title="프로퍼티 어트리뷰트"></a>프로퍼티 어트리뷰트</h1><h2 id="1-내부-슬롯과-내부-메소드"><a href="#1-내부-슬롯과-내부-메소드" class="headerlink" title="1. 내부 슬롯과 내부 메소드"></a>1. 내부 슬롯과 내부 메소드</h2><ul>
<li>내부 슬롯(Internal slot)과 내부 메소드(Internal method)는 자바 스크립트 자바 스크립트 엔진의 알고리즘을 설명하지 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티(Pseudo)와 의사 메소드 이다 ECMAScript 사양에 등장하는 이중 대괄호 ([[…]])로 감싼 이름들이 내부 슬롯과 메소드이다.</li>
<li>내부 슬롯과 내부 메소드는 ECMAScript 사양에 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작하지만 외부로 공개된 객체의 프로퍼티는 아니다.</li>
<li>즉 내부 슬롯과 내부 메소드는 자바스크립트 엔진의 내부 로직이므로 원칙적으로 자바스크립트는 내부 슬록과 내부 메소드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않는다.</li>
<li>단, 일부 내부 슬롯과 내부 메소드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.</li>
</ul>
<h2 id="2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h2><ul>
<li>자바스크립트 엔진은 프로퍼티를 생성할 때, 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.</li>
<li>프로퍼티의 상태란 프로퍼티의 값(value), 값의 갱신 가능(writable) 여부, 열거 가능(enumerable) 여부, 재정의 가능(configurable) 여부를 말한다.</li>
<li>프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값(meta-property)인 내부슬롯 ([[Value]], [[Writable]], [[Enumerable]], [[configurable]]) 이다.</li>
<li>따라서 프로퍼티 어트리뷰트에 직접 접근 할 수 없지만, Object.getOwnPropertyDescriptor 메소드를 사용하여 간접적으로 확인할 수는 있다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "song", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Object.getOwnPropertyDescriptor 메소드를 호출할 때, 첫번째 매개변수에는 객체의 참조를 전달하고 두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다.</li>
<li>이때 Object.getOwnPropertyDescriptor 메소드는 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.</li>
<li>만약 존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 프로퍼티 디스크립터를 요구하면 undefined가 반환된다.</li>
</ul>
<ul>
<li>Object.getOwnPropertyDescriptor 메소드는 하나의 프로퍼티에 대해 디스크립터 객체를 반환한다</li>
<li>Object.getOwnPropertyDescriptors 메소드는 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크럽터 객체를 반환한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//프로퍼티 동적 생성</span></span><br><span class="line">person.age = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크럽터 객체들을 반환한다</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person));</span><br><span class="line"><span class="comment">// name: &#123;value: "song", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">// age: &#123;value: 32, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-데이터-프로퍼티와-접근자-프로퍼티"><a href="#3-데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="3. 데이터 프로퍼티와 접근자 프로퍼티"></a>3. 데이터 프로퍼티와 접근자 프로퍼티</h2><ul>
<li>프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 구분한다.<ul>
<li>데이터 프로퍼티(Data Property) : 키와 값으로 구성된 일반적 프로퍼티다.</li>
<li>접근자 프로퍼티(Assessor Property) : 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 잡근자 함수(Accessor)로 구성된 프로퍼티 이다.</li>
</ul>
</li>
</ul>
<h3 id="3-1-데이터-프로퍼티"><a href="#3-1-데이터-프로퍼티" class="headerlink" title="3-1 데이터 프로퍼티"></a>3-1 데이터 프로퍼티</h3><ul>
<li>데이터 프로퍼티는 아래와 같은 프로퍼티 어트리뷰트를 갖는다.</li>
<li>이 프로퍼티 어트리뷰트는 자바스크립트 엔진이 프로퍼티를 생성할 때, 기본값으로 자동 정의된다.<table>
<thead>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th>프로퍼티 디스크럽터 객체의 프로퍼티</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>[[Value]]</td>
<td>value</td>
<td>- 프로퍼티 키로 프로퍼티 값에 접근하면 반환되는 값이다. <br>- 프로퍼티 키로 프로퍼티 값을 저장하면 [[value]]에 값을 저장한다. 이때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다.</td>
</tr>
<tr>
<td>[[Writable]]</td>
<td>writable</td>
<td>- 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다. <br>-[[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기전용 프로퍼티가 된다.</td>
</tr>
<tr>
<td>[[Enumerable]]</td>
<td>enumerable</td>
<td>- 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다. <br>- [[Enumerable]]의 값이 false인 경우, 해당 프로퍼티는 for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td>configurable</td>
<td>- 프로퍼티 재정의 가능 여부를 나타내며 불리언 값을 갖는다. <br> [[Configurable]]의 값이 false인 경우, 해당 프로퍼티를 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 혀용된다.</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="3-2-접근자-프로퍼티"><a href="#3-2-접근자-프로퍼티" class="headerlink" title="3-2 접근자 프로퍼티"></a>3-2 접근자 프로퍼티</h3><ul>
<li>접근자 프로퍼티(Accessor property)는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(Accessor function)로 구성된 프로퍼티 이다.</li>
<li>접근자 프로퍼티는 아래와 같은 프로퍼티 어트리뷰트를 갖는다.<table>
<thead>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th>프로퍼티 디스크럽터 객체의 프로퍼티</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>[[Get]]</td>
<td>get</td>
<td>접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수이다. 즉 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[get]]의 값, 즉 getter함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다</td>
</tr>
<tr>
<td>[[Set]]</td>
<td>set</td>
<td>접근자 프로퍼티를 통해 프로퍼티 값을 저장할 때 호출되는 접근자 함수이다. 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 Setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</td>
</tr>
<tr>
<td>[[Enumerable]]</td>
<td>enumerable</td>
<td>데이터 타입의 [[Enumerable]]와 같다.</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td>configurable</td>
<td>데이터 타입의 [[Configurable]]와 같다.</td>
</tr>
</tbody></table>
</li>
<li>접근자 함수는 getter/setter함수라고도 부른다. 접근자 프로퍼티는 grtter와 setter 함수를 모두 정의할 수도 있고 하나만 정의할 수도 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">'Buyong'</span>,</span><br><span class="line">  lastName: <span class="string">'Song'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fullName은 접근자 함수로 구성된 접근자 프로퍼티이다.</span></span><br><span class="line">  <span class="comment">// getter 함수</span></span><br><span class="line">  <span class="keyword">get</span> fullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter 함수</span></span><br><span class="line">  <span class="keyword">set</span> fullName(name) &#123;</span><br><span class="line">    [<span class="keyword">this</span>.firstName, <span class="keyword">this</span>.lastName] = name.split(<span class="string">' '</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 접근하면 getter함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(person.fullName); <span class="comment">// Buyong Song</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 프로퍼티를 통한 값의 참조</span></span><br><span class="line"><span class="built_in">console</span>.log(person.firstName, person.lastName); <span class="comment">// Buyong Song</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 값의 저장</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.</span></span><br><span class="line">person.fullName = <span class="string">'angry boo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; firstName: 'angry', lastName: 'boo', fullName: [Getter/Setter] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 프로퍼티 값의 참조</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 접근하면 getter함수가 출력된다</span></span><br><span class="line"><span class="built_in">console</span>.log(person.fullName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// firstName은 데이터 프로퍼티이다.</span></span><br><span class="line"><span class="comment">// 데이터 프로퍼티는 value, writable, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.</span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'firstName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  value: 'angry',</span></span><br><span class="line"><span class="comment">  writable: true,</span></span><br><span class="line"><span class="comment">  enumerable: true,</span></span><br><span class="line"><span class="comment">  configurable: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fullName은 접근자 프로퍼티 이다.</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어프리뷰트를 갖는다.</span></span><br><span class="line">descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'fullName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  get: [Function: get fullName],</span></span><br><span class="line"><span class="comment">  set: [Function: set fullName],</span></span><br><span class="line"><span class="comment">  enumerable: true,</span></span><br><span class="line"><span class="comment">  configurable: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>접근자 프로퍼티 fullName으로 프로퍼티 값에 접근하면 내부적으로 [[Get]] 내부 메소드가 호출되어 아래와 같이 작동한다<ol>
<li>프로퍼티 키가 유효한지 확인한다. 프로퍼티 키는 몬자열 또는 심볼이어야 한다. 프로퍼티 키 “fullName”은 문자열 이므로 프로퍼티 키다.</li>
<li>프로토타입 체인에서 프로퍼티를 검색한다. person객체에 fullName 프로퍼티가 존재한다.</li>
<li>검색된 fullName 프로퍼티가 테이터 프로퍼티인지 접근자 프로퍼티인지 확인한다. fullName 프로퍼티는 접근자 프로퍼티다.</li>
<li>접근자 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 함수를 호출하여 그 결과를 반환한다. 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값은 Object.getOwnPropertyDesciptor 메소드가 반환하는 프로퍼티 디스크립터 객체의 get 프로퍼티 값과 같다.</li>
</ol>
</li>
</ul>
<h2 id="4-프로퍼티-정의"><a href="#4-프로퍼티-정의" class="headerlink" title="4. 프로퍼티 정의"></a>4. 프로퍼티 정의</h2><ul>
<li>프로퍼티 정의 : 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적의로 정의하거나, 기존 어트리뷰트를 재정의 하는것</li>
<li>Object.defineProperty 메소드를 사용하면 프로퍼티 어트리뷰트를 정의할 수 있음</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//데이터 프로퍼티 정의</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'firstName'</span>, &#123;</span><br><span class="line">  value: <span class="string">'Buyong'</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'lastName'</span>, &#123;</span><br><span class="line">  value: <span class="string">'Song'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'firstName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="comment">// Object &#123;value: "Buyong", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 디스크립터 객체의 프로퍼티를 누락 시키면 undefined, false가 기본값이다.</span></span><br><span class="line">descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'lastName'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="comment">//Object &#123;value: "Song", writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 정의</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'fullName'</span>, &#123;</span><br><span class="line">  <span class="comment">//getter 함수</span></span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter 함수</span></span><br><span class="line">  <span class="keyword">set</span>(name) &#123;</span><br><span class="line">    [<span class="keyword">this</span>.firstName, <span class="keyword">this</span>.lastName] = name.split(<span class="string">' '</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="5-객체-변경-금지"><a href="#5-객체-변경-금지" class="headerlink" title="5. 객체 변경 금지"></a>5. 객체 변경 금지</h2><ul>
<li>자바스크립트는 객체의 변경을 방지할 수 있는 다양한 메소드를 제공한다. 객체 변경 방지 메소드 들은 객체의 변경을 금지하는 강도가 다르다.<table>
<thead>
<tr>
<th>구분</th>
<th></th>
<th align="center">메소드</th>
<th align="center">프로퍼티 추가</th>
<th align="center">프로퍼티 삭제</th>
<th align="center">프로퍼티 값 읽기</th>
<th align="center">프로퍼티 어트리뷰트 재정의</th>
</tr>
</thead>
<tbody><tr>
<td>객체 확장 금지</td>
<td>Object.preventExtensions</td>
<td align="center">X</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">O</td>
</tr>
<tr>
<td>객체 밀봉</td>
<td>Object.seal</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">X</td>
</tr>
<tr>
<td>객체 동결</td>
<td>Object.freeze</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">O</td>
<td align="center">X</td>
<td align="center">X</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="5-1-객체-확장-금지"><a href="#5-1-객체-확장-금지" class="headerlink" title="5-1 객체 확장 금지"></a>5-1 객체 확장 금지</h3><ul>
<li>Object.preventExtensions 메소드는 객체의 확장을 금지한다.</li>
<li>객체의 확장 금지란 프로퍼티 추가 금지를 의미한다.</li>
<li><strong>확장이 금지괸 객체는 프로퍼티 추가가 금지됨다</strong></li>
</ul>
<h3 id="5-2-객체-밀봉"><a href="#5-2-객체-밀봉" class="headerlink" title="5-2 객체 밀봉"></a>5-2 객체 밀봉</h3><ul>
<li>객체 밀봉이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지를 의미한다.</li>
<li><strong>밀봉된 객체는 읽기와 쓰기만 가능하게 된다</strong></li>
</ul>
<h3 id="5-3-객체-동결"><a href="#5-3-객체-동결" class="headerlink" title="5-3 객체 동결"></a>5-3 객체 동결</h3><ul>
<li>Object.freeze메소드는 객체를 동결한다.</li>
<li>객체 동결이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미한다.</li>
<li><strong>동결된 객체는 읽기만 가능하게 된다</strong></li>
</ul>
<h3 id="5-4-불변-객체"><a href="#5-4-불변-객체" class="headerlink" title="5-4 불변 객체"></a>5-4 불변 객체</h3><ul>
<li>객체 변경 방지 메소드 들은 얕은 변경 방기로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지는 못하다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/03/02/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/03-02%20let,%20const%EC%99%80%20%EB%B8%94%EB%A1%9D%EB%A0%88%EB%B2%A8%20%EC%8A%A4%EC%BD%94%ED%94%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/03-02%20let,%20const%EC%99%80%20%EB%B8%94%EB%A1%9D%EB%A0%88%EB%B2%A8%20%EC%8A%A4%EC%BD%94%ED%94%84/" class="post-title-link" itemprop="url">JS 수업 예습/03-02 let, const와 블록레벨 스코프</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-03-02 08:55:25 / Updated at: 23:01:33" itemprop="dateCreated datePublished" datetime="2020-03-02T08:55:25+09:00">2020-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="let-const와-블록레벨-스코프"><a href="#let-const와-블록레벨-스코프" class="headerlink" title="let, const와 블록레벨 스코프"></a>let, const와 블록레벨 스코프</h1><h2 id="1-var-키워드로-선언한-변수의-문제점"><a href="#1-var-키워드로-선언한-변수의-문제점" class="headerlink" title="1. var 키워드로 선언한 변수의 문제점"></a>1. var 키워드로 선언한 변수의 문제점</h2><h3 id="1-1-변수-중복-선언-허용"><a href="#1-1-변수-중복-선언-허용" class="headerlink" title="1-1 변수 중복 선언 허용"></a>1-1 변수 중복 선언 허용</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.</span></span><br><span class="line"><span class="comment">// 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<ul>
<li>var 키워드 사용 시 동일한 변수 이름이 선언되어 있는 것을 모르고 중복 선언을 하고 할당까지 하면 미리 선언된 변수의 값이 변경되는 부작용이 있다</li>
</ul>
<h3 id="1-2-함수-레벨-스코프"><a href="#1-2-함수-레벨-스코프" class="headerlink" title="1-2 함수 레벨 스코프"></a>1-2 함수 레벨 스코프</h3><ul>
<li>var 키워드로 선언한 변수는 오로지 함수의 블록 만은 지역 스코프로 인정한다</li>
<li>var 키워드로 선언한 변수는 코드 블록 내에서 선언하여도 모두 전역변수가 된다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// 0 1 2 3 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 의도치 않게 처음 선언한 변수 i가 for문에 의하여 변경되었다.</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-3-변수-호이스팅"><a href="#1-3-변수-호이스팅" class="headerlink" title="1-3 변수 호이스팅"></a>1-3 변수 호이스팅</h3><ul>
<li>var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.</li>
<li>var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다.</li>
<li>var 키워드로 선언한 변수는 언제나 undefined를 반환한다.</li>
<li>변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의헤 에러를 발생시키지는 않지만 프로그램의 흐름 상 맞지 않을 뿐더러 가독성을 떨어뜨리고 오류를 발생 시킬 여지를 남긴다</li>
</ul>
<h2 id="2-let-키워드"><a href="#2-let-키워드" class="headerlink" title="2. let 키워드"></a>2. let 키워드</h2><h3 id="2-1-변수-중복선언-금지"><a href="#2-1-변수-중복선언-금지" class="headerlink" title="2-1 변수 중복선언 금지"></a>2-1 변수 중복선언 금지</h3><ul>
<li>let 키워드로 동일한 이을 갖는 변수를 중복 선언하면 문법에러 (SyntaxError)가 발생한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">456</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 456</span></span><br><span class="line"><span class="comment">// var 키워드로 변수 선언 시 중복 선언을 하면 아래 변수 선언문은 자바 스크립트 엔진에 의해 var키워드가 없는 것으로 동작하고 할당문인 것처름 됨</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">456</span>; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="comment">// let이나 const키워드로 선언된 변수는 같은 스코프 내에서 중복선언 허용 안됨</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-2-블록레벨-스코프"><a href="#2-2-블록레벨-스코프" class="headerlink" title="2-2 블록레벨 스코프"></a>2-2 블록레벨 스코프</h3><ul>
<li>let 키워드로 선언한 변수는 모든 코드블록(함수, if문, while문, try/carch문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">456</span>;</span><br><span class="line">  <span class="keyword">let</span> bar = <span class="number">456</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// referenceError</span></span><br></pre></td></tr></table></figure></li>
<li>함수도 코드 블록이므로 스코프를 만든다. 이때 함수 내의 코드블록은 함수레벨 스코프에 중첩된다</li>
</ul>
<h3 id="2-3-변수-호이스팅"><a href="#2-3-변수-호이스팅" class="headerlink" title="2-3 변수 호이스팅"></a>2-3 변수 호이스팅</h3><ul>
<li>var 키워드로 선언한 변수롸는 달리 let키워드로 선언한 변수는 변수 호이스킹이 발생하지 않는 것처럼 동작한다.</li>
<li>var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 “선언단계”와 “초기화단계” 가 한번에 진행된다.</li>
<li>즉 선언 단계에서 스코프에 변수 식별자를 등록하여 자바스크립트 엔진에 변수의 존재를 알리고 그 즉시 초기화 단계에서 undefined로 변수를 초기화 한다.</li>
<li><strong>let 키워드로 선언한 변수는 “선언단계”와 “초기화단계”가 분리되어 진행된다</strong></li>
<li>즉, 런타임 이전에 자바 스크립트 엔진에 의해 암묵적으로 선언단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다.</li>
<li>만약 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조에러가 발생한다.</li>
<li>따라서 스코프의 시작 지점부터 초기화 단계 시작 저점 까지는 변수를 참조할 수 없다.</li>
<li>스코프의 시작지점 부터 초기화 단계 시작 시점(변수 선언문) 까지는 변수를 참조할 수 없다.</li>
<li>스코프의 시작 지점부터 초기화의 시작 지점까지의 구간을 <strong>일시적 사각지대(Temppral Dead Zone; TDZ)</strong> 라고 부른다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo; <span class="comment">// 변수 선언문에서 초기화 단계가 실행된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">1</span>; <span class="comment">// 할당문에서 할당 단계가 실행된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는것처럼 보이지만 그렇지 않다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>; <span class="comment">// 전역변수</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>; <span class="comment">// 지역변수</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>let 키워드로 선언한 변수의 경우, 변수 호이스팅이 발생 하지 않는다면 위 예제의 전역변수 값인 1을 출력해야 한다</li>
<li>하지만 let키워드로 선언한 변수도 여전히 호이스팅이 발생하기 때문에 참조에러가 발생한다.</li>
</ul>
<h3 id="2-4-전역-객채와-let"><a href="#2-4-전역-객채와-let" class="headerlink" title="2-4 전역 객채와 let"></a>2-4 전역 객채와 let</h3><ul>
<li><p>전역객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 측수한 객체이며 어떤 객체도 속하지 않는 최상위 객체이다.</p>
</li>
<li><p>전역 객체는 클라이언트 사이드 환경에서는 window, 서버 사이드 환경에서는 global 객체를 가리킨다.</p>
</li>
<li><p>var 키워드로 선언한 전역변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역 그리고 전역함수는 전역 객체의 프로퍼티가 된다.</p>
</li>
<li><p>전역객체의 프로퍼티를 참조할 때 window를 생ㄹ갸할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역변수</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 암묵적 전역</span></span><br><span class="line">y = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티이다</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.x); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 암묵적 전역은 전역 객체의 프로퍼티이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.y) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(y) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문으로 정의한 전역 함수는 전역 객체의 프로퍼티이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.foo); <span class="comment">// f f00() &#123;&#125;</span></span><br><span class="line"><span class="comment">// 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// f foo() &#123;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>let 키워드로 선언한 전역변수는 전역 객체 window의 프로퍼티가 아니다. 즉 window.foo와 같이 접근할 수 없다.</p>
</li>
<li><p>let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 된다</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let, const 키워드로 선언한 전역변수는 전역 객체의 프로퍼티가 아니다</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-const-키워드"><a href="#3-const-키워드" class="headerlink" title="3. const 키워드"></a>3. const 키워드</h2><ul>
<li>const 키워드는 상수를 선언하기 위해 사용한다. 하지만 반드시 상수만을 위해 사용하지는 않는다.</li>
</ul>
<h3 id="3-1-선언과-초기화"><a href="#3-1-선언과-초기화" class="headerlink" title="3-1 선언과 초기화"></a>3-1 선언과 초기화</h3><ul>
<li>const 키워드로 선언한 변수는ㄴ 반드시 선언과 동시에 할당이 이루어 져야한다.</li>
<li>const 키워드로 선언한 변수는 let 키워드로 선언한 변수와 마찬가지로 블록레벨 스코프를 가지며 호이스팅이 발생하지 않는 것처럼 동작한다.</li>
</ul>
<h3 id="3-2-재할당-금지"><a href="#3-2-재할당-금지" class="headerlink" title="3-2 재할당 금지"></a>3-2 재할당 금지</h3><ul>
<li>var 또는 let 키워드로 선언한 변수는 재할당이 자유로우나 const 키워드로 선언한 변수는 재할당이 금지된다.</li>
</ul>
<h3 id="3-3-상수"><a href="#3-3-상수" class="headerlink" title="3-3 상수"></a>3-3 상수</h3><ul>
<li>const 키워드로 선언한 변수에 원시값을 할당한 경우, 변수값을 변경 할 수 없다.</li>
<li>원시값은 변경 불가능한 값 이므로 재할당 없이 값을 변경할 수 있는 방법이 없기 때문이다.</li>
<li>일반적으로 상수의 이름은 대문자로 선언하여 상수임을 명확이 나타낸다.</li>
<li>여러 단어로 이루어진 경우에는 언더스코어(_)로 구분하여 스네이크 케이스로 표현하는것이 일반적이다.</li>
<li><strong>const 키워드로 선언된 변수에 원시값을 할당한 경우, 원시값은 변경할수 없는 값이고 const키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.</strong></li>
</ul>
<h3 id="3-4-const-키워드와-객체"><a href="#3-4-const-키워드와-객체" class="headerlink" title="3-4 const 키워드와 객체"></a>3-4 const 키워드와 객체</h3><ul>
<li>const 키워드로 선언된 변수에 원시값을 할당한 경우, 값을 변경할 수 없다.</li>
<li><strong>const 키워드로 선언된 변수에 객채를 할당할 경우 값을 변경 할 수 있다.</strong></li>
<li>const 키워드는 재할당을 금지할 뿐 불변을 의미하지는 않는다.</li>
</ul>
<h2 id="4-var-vs-let-vs-const"><a href="#4-var-vs-let-vs-const" class="headerlink" title="4. var vs let vs const"></a>4. var vs let vs const</h2><ul>
<li>변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 팔요한 경우에 한정해 사용하는 것이 좋다.</li>
<li>원시값인 경우, 가급적 상수를 사용하는 편이 좋다.</li>
<li>객체를 재할당 하는 경우는 생각보다 크지 않음으로 const 키워드를 사용하면 의도치 않은 재할당을 방지해 준다.</li>
<li>var와 let, cont 키워드는 다음처럼 사용한다.<ul>
<li>ES5를 사용한다면 var 키워드는 사용하지 않는다.</li>
<li>재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.</li>
<li>변경이 발생하지 않고 읽기 전용으로 사용하는 원시값과 객체에는 const 키워드를 사용한다.(const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전하다)</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/02/29/%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4/%EC%A0%9C%EC%96%B4%EB%AC%B8%20%EC%97%B0%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/29/%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4/%EC%A0%9C%EC%96%B4%EB%AC%B8%20%EC%97%B0%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/" class="post-title-link" itemprop="url">제어문 연습문제</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-29 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-29T00:00:00+09:00">2020-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-01 00:00:00" itemprop="dateModified" datetime="2020-03-01T00:00:00+09:00">2020-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/" itemprop="url" rel="index">
                    <span itemprop="name">문제풀이</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="제어문-연습-문제"><a href="#제어문-연습-문제" class="headerlink" title="제어문 연습 문제"></a>제어문 연습 문제</h1><ol>
<li><p>변수 X가 10보다 크고 20보다 작을 때 변수 X를 출력하는 조건식을 완성하라.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span> &amp;&amp; x &lt; <span class="number">20</span>) <span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 문을 사용하여 0부터 10미만 정수 중에서 짝수만을 작은 수부터 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for문을 사용하여 0부터 10 미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) str += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 문을 사용하여 0부터 10 미만의 정수 중에서 홀수만을 큰 수부터 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">  i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while문을 사용하여 0부터 10 미만의 정수 중에서 홀수만을 큰 수부터 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">  i -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
</li>
<li><p>1부터 20미만의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((i % <span class="number">2</span>) &amp;&amp; (i % <span class="number">3</span>)) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
</li>
<li><p>1부터 20 미만의 정수 중에서 2또는 3의 배수인 수의 총합을 구하시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(i % <span class="number">2</span>) || !(i % <span class="number">3</span>)) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
</li>
<li><p>두개의 주사위를 전졌을 떄, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dice = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> fst = <span class="number">1</span>; fst &lt; <span class="number">7</span>; fst++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> scd = <span class="number">1</span>; scd &lt; <span class="number">7</span>; scd++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fst + scd === <span class="number">6</span>) <span class="built_in">console</span>.log(dice = [fst, scd]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>삼각형 출력하기 - pattern 1 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt;= vtl; hzt++) &#123;</span><br><span class="line">    tree += <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>삼각형 출력하기 - pattern 2</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">5</span>; hzt++) &#123;</span><br><span class="line">    tree += vtl &gt; hzt ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>삼각형 출력하기 - pattern 3</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">5</span>; vtl &gt; <span class="number">0</span>; vtl--) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; vtl; hzt++) &#123;</span><br><span class="line">    tree += <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>삼각형 출력하기 - pattern 4</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">5</span>; hzt++) &#123;</span><br><span class="line">    tree += (vtl + hzt &gt; <span class="number">3</span>) ? <span class="string">'*'</span> : <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>정삼각형 출력하기</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">9</span>; hzt++) &#123;</span><br><span class="line">    tree += ((hzt &gt; (<span class="number">4</span> + vtl)) || (hzt &lt; (<span class="number">4</span> - vtl))) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>
</li>
<li><p>역정삼각형 출력하기</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">9</span>; hzt++) &#123;</span><br><span class="line">    tree += ((hzt &lt; (<span class="number">0</span> + vtl)) || (hzt &gt; (<span class="number">8</span> - vtl))) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tree += <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(tree);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="3-1-추가"><a href="#3-1-추가" class="headerlink" title="3/1 추가"></a>3/1 추가</h4><ul>
<li><p>콜백함수 응용 정삼각형, 정역삼각형 logic 동시 구현</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tree</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">9</span>; hzt++) &#123;</span><br><span class="line">      f(vtl, hzt);</span><br><span class="line">    &#125;</span><br><span class="line">    sum += <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fw</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += ((h &gt; (<span class="number">4</span> + v)) || (h &lt; (<span class="number">4</span> - v))) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bw</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += ((h &lt; (<span class="number">0</span> + v)) || (h &gt; (<span class="number">8</span> - v))) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tree(fw);</span><br><span class="line"><span class="comment">// 인수로 fw 입력 시 정삼각형, 인수로 bw 입력 시 정역삼각형 반환</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>콜백함수 응용 삼각형찍기 pattern1 ~ 4끼지 동시 구현</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tree</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> vtl = <span class="number">0</span>; vtl &lt; <span class="number">5</span>; vtl++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> hzt = <span class="number">0</span>; hzt &lt; <span class="number">5</span>; hzt++) &#123;</span><br><span class="line">      f(vtl, hzt);</span><br><span class="line">    &#125;</span><br><span class="line">    sum += <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ptn1</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += (v &lt; h) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ptn2</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += (v &gt; h) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ptn3</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += (v + h &gt;= <span class="number">5</span>) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ptn4</span>(<span class="params">v, h</span>) </span>&#123;</span><br><span class="line">  sum += (v + h &lt; <span class="number">4</span>) ? <span class="string">' '</span> : <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line">tree(ptn1);</span><br><span class="line"><span class="comment">// 인수로 ptn1 ~ ptn4 입력 시 삼각형은 패턴에 맞게 출력됨</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/02/27/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-27%20%EC%98%88%EC%8A%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/27/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-27%20%EC%98%88%EC%8A%B5/" class="post-title-link" itemprop="url">JS 수업 예습/2020-02-27 예습</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-27 19:29:20" itemprop="dateCreated datePublished" datetime="2020-02-27T19:29:20+09:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-02 23:01:33" itemprop="dateModified" datetime="2020-03-02T23:01:33+09:00">2020-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="전역변수의-문제점"><a href="#전역변수의-문제점" class="headerlink" title="전역변수의 문제점"></a>전역변수의 문제점</h1><h2 id="1-변수의-생명-주기"><a href="#1-변수의-생명-주기" class="headerlink" title="1. 변수의 생명 주기"></a>1. 변수의 생명 주기</h2><h3 id="1-1-지역변수의-생명-주기"><a href="#1-1-지역변수의-생명-주기" class="headerlink" title="1-1 지역변수의 생명 주기"></a>1-1 지역변수의 생명 주기</h3><ul>
<li>변수는 생물과 유사하게 생성되고 소멸되는 생명 주기가 있음</li>
<li>변수에 생명 주기가 없다면 한번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유한다.</li>
<li>변수는 자신이 선언된 위치에서 생성되고 소멸한다.</li>
<li>전역변수의 생명 주기는 애플리케이션의 생명 주기와 같다</li>
<li>함수 내부에서 선언된 지역변수는 함수가 호출되면 생성되고 함수가 종료되면 소멸한다.</li>
</ul>
<p><strong>함수 내부에서 선언한 변수는 함수가 호출 된 직후에 함수 몸체의 다른 코드가 실행되기 전 자바스크립트 엔진에 의해 먼저 실행된다.</strong><br><strong>지역변수의 생명 주기는 함수의 생명 주기와 일치한다</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 함수 몸체 실행 전 변수 x 생성</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'local'</span>; <span class="comment">// 변수 x에 'local 값 할당'</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); </span><br><span class="line">  <span class="keyword">return</span> x; <span class="comment">// 변수 x 소멸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>호이스팅은 스코프를 단위로 동작한다.</strong></p>
<ul>
<li>전역변수의 호이스팅은 전역 전체에서 유효하지만, 지역변수의 호이스팅은 함수 내에서만 유효함</li>
</ul>
<h3 id="1-2-전역변수의-생명-주기"><a href="#1-2-전역변수의-생명-주기" class="headerlink" title="1-2 전역변수의 생명 주기"></a>1-2 전역변수의 생명 주기</h3><ul>
<li>함수와는 달리 전역 코드는 병시적인 호출 없이 실행된다.</li>
<li>전역 코드는 함수 호출과 같이 전역 코드를 실행하는 진입점이 없고 코드가 로드 되자마자 곧바로 해석되고 실행한다.<ul>
<li>진입점 : C나 Java로 작성된 코드를 실행하면 가장 먼저 main함수가 호출된다. 이 main함수는 프로그램이 시작되는 지점이므로 이를 진입점 또는 시작점 이라고 한다.</li>
</ul>
</li>
<li>함수는 함수 몸체의 마지막 문 또는 return문이 실행되면 종료한다.</li>
<li>전역 코드에는 return문을 사용할 수 없으므로 마지막 문이 실행되어 더이상 실행할 문이 없을 때 종료한다.<ul>
<li>return 문의 위치 : return문은 함수 내부에서만 사용할 수 있다. 전역에서 return문을 사용하면 문법에러가 발생한다. </li>
</ul>
</li>
<li>var 키워드로 선언한 전역변수는 전역 객체의 프로퍼티가 된다.(전역 변수의 생명 주기가 전역 객채의 생명 주기와 일치)<ul>
<li>전역객채 : 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체이다. 전역객채는 클라이언트 사이드 환경에서는 window, 서버사이드 환경에서는 global 객체를 의미한다.</li>
</ul>
</li>
<li>브라우저 환경에서 전역객체는 window이므로 브라우저 환경에서 var키워드로 선언한 전역변수는 전역객체 window의 프로퍼티 이다</li>
<li>var 키워드로 선언한 전역변수는 웹 페이지를 종료할 때까지 유효하다.</li>
<li><strong>즉 전역변수는 전역객체의 생명 주기와 일치한다</strong></li>
</ul>
<h2 id="2-전역변수의-문제점"><a href="#2-전역변수의-문제점" class="headerlink" title="2. 전역변수의 문제점"></a>2. 전역변수의 문제점</h2><p><strong>암묵적 결합</strong></p>
<ul>
<li>전역변수를 선언한 의도는 코드 어디에서든지 전여ㅑㄱ변수를 사용하겠다는 것이다.</li>
<li>이는 모든 코드가 전역변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것으로 변수 유효범위가 크면 클수록 코드의 가독성은 나빠지고 변경될 수 있는 위험성도 높아진가</li>
</ul>
<p><strong>긴 생명주기</strong></p>
<ul>
<li><em>전역변수는 생명 주기가 길다.</em></li>
<li>따라서 메모리 리소스도 오랜시간 소비한다</li>
<li>var 키워드는 변수의 중복 선언을 허용하므로 생명 주기가 긴 전역 변수는 변수 이름이 중복 될 가틍성이 있다.</li>
<li>지역변수는 전역변수보다 생명 주기가 훨씬 짧은 만큼 메모리 리소스도 짧은 기간만 소비한다.</li>
</ul>
<p><strong>스코프 체인 상에서 종점에 존재</strong></p>
<ul>
<li>전역 변수의 또하나의 문제는 스코프 체인 상에서 종점에 존재한다는 것이다.</li>
<li>이는 변수는 검색할 때 전역변수가 가장 마지막에 검색되는 것을 말한다.</li>
<li><em>즉 전역변수의 검색 속도가 가장 느리다</em></li>
</ul>
<p><strong>네임 스페이스 오염</strong></p>
<ul>
<li>자바스크립트에서 가장 큰 문제점 중의 하나는 파일이 분리되어 있다 하더라도 전역 스코프를 공유한다는 것이다.</li>
<li>다른 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.</li>
</ul>
<h2 id="3-전역변수-사용-억제-방법"><a href="#3-전역변수-사용-억제-방법" class="headerlink" title="3. 전역변수 사용 억제 방법"></a>3. 전역변수 사용 억제 방법</h2><p><strong>전역변수를 반드시 사용하여야 할 이유를 찾지 못한다면 지역변수를 사용하여야 한다. 변수의 스코프는 좁을수록 좋다</strong></p>
<h3 id="3-1-즉시-실행-함수"><a href="#3-1-즉시-실행-함수" class="headerlink" title="3-1 즉시 실행 함수"></a>3-1 즉시 실행 함수</h3><ul>
<li>함수의 정의와 동시에 호출되는 즉시 실행 함수는 단 한번만 호출된다.</li>
<li><strong>모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시실행함수의 지역 변수가 된다</strong></li>
</ul>
<h3 id="3-2-네임스페이스-객체"><a href="#3-2-네임스페이스-객체" class="headerlink" title="3-2 네임스페이스 객체"></a>3-2 네임스페이스 객체</h3><ul>
<li>전역에 <em>네임스페이스(Namespace)</em> 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;; <span class="comment">// 전역 네임 스페이스 객체</span></span><br><span class="line">MYAPP.name = <span class="string">'song'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(MYAPP.name); <span class="comment">// song</span></span><br></pre></td></tr></table></figure></li>
<li>네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로퍼티로 추가하여 네임 스페이스를 계층적으로 구성할 수도 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;; <span class="comment">// 전역 네임 스페이스 객체</span></span><br><span class="line"></span><br><span class="line">MYAPP.person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span>,</span><br><span class="line">  address: <span class="string">'paju'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(MYAPP.person.name); <span class="comment">// song</span></span><br></pre></td></tr></table></figure></li>
<li>네임 스페이스를 분리하여 식별자 충동을 방지하는 효과는 있으나 네임 스페이스 객체 자체가 전역변수에 할당되므로 그다지 유용하지 않다.</li>
</ul>
<h3 id="3-3-모듈-패턴"><a href="#3-3-모듈-패턴" class="headerlink" title="3-3 모듈 패턴"></a>3-3 모듈 패턴</h3><ul>
<li>모듈 패턴은 클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다.</li>
<li>모듈 패턴은 자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다.</li>
<li>모듈 패턴의 특징은 전역 변수의 억제는 물론 캡슐화 까지 구현할 수 있다</li>
<li>캡슐화는 외부에 공개될 필요가 없는 정보를 외부에 노출시키지 않고 숨기는 것을 말하며 정보 은닉이라고도 한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//private 변수</span></span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 외부로 공개할 데이터나 메소드를 프로퍼티로 추가한 객체를 반환한다.</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increase() &#123;</span><br><span class="line">      <span class="keyword">return</span> ++num;</span><br><span class="line">    &#125;,</span><br><span class="line">    decrease() &#123;</span><br><span class="line">      <span class="keyword">return</span> --num;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="comment">// private 변수는 외부로 노출되지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter.num); <span class="comment">// undifined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Counter.increase()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter.increase()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter.decrease()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter.decrease()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위 예제의 즉시 실행 함수는 객체를 반환한다.</li>
<li>이 객체에는 외부에 노출하고 싶은 변수나 함수를 담아 반환한다.</li>
<li>이때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭멤버이다.</li>
<li>외부로 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않으면 외부에서 접근할 수 없는 프라이빗 멤버가 된다.</li>
</ul>
<h3 id="3-4-ES6-모듈"><a href="#3-4-ES6-모듈" class="headerlink" title="3-4 ES6 모듈"></a>3-4 ES6 모듈</h3><ul>
<li>전역변수의 남발을 억제하기 위해 ES6에서 도입된 모듈을 사용할 수도 있다. 모던 브라우저에서 ES6 모듈을 사용 할 수 있다.</li>
<li>script 태그에 type=”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다.</li>
<li>모듈의 확장자는 mjs를 권장한다.<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">sec</span>=<span class="string">"lib.mjs"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">sec</span>=<span class="string">"app.mjs"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://angryboo.github.io/2020/02/25/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-26%20%EC%98%88%EC%8A%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="angryboo">
      <meta itemprop="description" content="I can do this all day">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="angryboo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/JS%20%EC%88%98%EC%97%85%20%EC%98%88%EC%8A%B5/2020-02-26%20%EC%98%88%EC%8A%B5/" class="post-title-link" itemprop="url">JS 수업 예습/2020-02-26 예습</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-02-25 22:07:16" itemprop="dateCreated datePublished" datetime="2020-02-25T22:07:16+09:00">2020-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-03-02 23:01:33" itemprop="dateModified" datetime="2020-03-02T23:01:33+09:00">2020-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%EC%98%88%EC%8A%B5/" itemprop="url" rel="index">
                    <span itemprop="name">예습</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1></li>
</ol>
<ul>
<li>함수는 자바스크립트에서 가장 중요한 핵심 개념이다.</li>
<li>수학의 함수는 입력을 받아서 출력을 내보내는 일련의 과정을 정의한 것이다</li>
<li><em>함수는 일련의 과정을 문들로 구현하고 코드블록으로 감싸서 하나의 실행 단위로 정의한 것이다</em></li>
<li>함수 내부로 입력을 전달받는 변수를 <em>매개변수(parameter)</em> 입력을 <em>인수(argument)</em> 출력을 <em>반환값(return value)</em> 라고 한다</li>
<li>함수는 값이며 여러개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다</li>
<li>함수는 함수 정의(function definition)를 통해 생성된다<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123; <span class="comment">// add : 함수이름, (x, y) 매개변수</span></span><br><span class="line">  <span class="keyword">return</span> x + y; <span class="comment">// 반환값</span></span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 인수</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">- 함수 정의만으로 함수가 실행되지 않는다. 수학의 함수처럼 미리 정의된 일련의 과정을 실행하기 실행하기 위해 필요한 입력, 즉 인수를 매개변수를 통해 함수에게 전달하면서 함수의 실행을 명시적으로 지시해야한다.</span></span><br><span class="line"><span class="string">- 이를 함수 호출(Function call/invoke)이라 한다.</span></span><br><span class="line"><span class="string">- 함수를 호출하면 코드블록에 담긴 문들이 일괄적으로 실행되고 실행결과, 즉 반환값을 반환한다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 함수의 사용 이유</span></span><br><span class="line"><span class="string">- 함수는 필요할 때 여러번 호출할 수 있음</span></span><br><span class="line"><span class="string">- 동일한 작업을 반복적으로 수행해야 한다면 같은 코드를 중복해서 여러번 작성하는 것이 아니라 미리 정의된 함수를 재사용 하는 것이 효율적</span></span><br><span class="line"><span class="string">- 힘수는 몇번이든 호출 할 수 있으므로 _코드의 재사용_ 이라는 측면에서 유리함</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">2</span>;</span><br><span class="line">result = x + y; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">3</span>;</span><br><span class="line">y = <span class="number">4</span>;</span><br><span class="line">result = x + y; <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">5</span>;</span><br><span class="line">y = <span class="number">6</span>;</span><br><span class="line">result = x + y; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 위 코드를 아래와 같이 함수를 사용하면 중복을 제거하고 코드를 재사용 할 수 있음</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x , y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">result = add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">result = add(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 7</span></span><br><span class="line">result = add(<span class="number">5</span>, <span class="number">6</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><em>함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다</em></p>
<h2 id="1-함수-리터럴"><a href="#1-함수-리터럴" class="headerlink" title="1. 함수 리터럴"></a>1. 함수 리터럴</h2><ul>
<li>자바스크립트에서 함수는 객체 타입의 값임</li>
<li>함수 리터럴은 function 키워드, 함수이름, 매개변수 목록, 그리고 함수 몸체로 구성 됨</li>
</ul>
<p><em>함수 리터럴의 구성 요소</em></p>
<ul>
<li><p>함수이름</p>
<ul>
<li>함수 이름은 식병자 이다. 따라서 식별자 네이밍 규칙을 준수해야한다.</li>
<li>함수 이름은 함수 몸채 내에서만 참조할 수 있는 식별자 이다.</li>
<li>함수 이름은 생략 할 수 있다. 함수 이름이 있는 함수를 기명함수(named function), 함수 이름이 없는 함수를 익명 함수(anonymous function)이라 한다</li>
</ul>
</li>
<li><p>매개면수 목록</p>
<ul>
<li>0개 이상의 매개변수를 소괄호로 감싸고 쉽표로 구분한다.</li>
<li>매개변수에는 함수 호출문의 인수가 순서대로 할당된다. 즉 매개변수 목록은 순서에 의미가 있다</li>
<li>매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수 해야한다.</li>
</ul>
</li>
<li><p>함수몸체</p>
<ul>
<li>함수가 호출 되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드블록이다</li>
<li>함수 몸체는 함수 호출에 의해 실행된다</li>
</ul>
</li>
</ul>
<p><em>함수 리터럴은 값으로 평가될 수 있으며 이때 값은 객체대, 즉 함수는 객체다.</em><br><em>일반 객체는 호출 할 수 없지만 함수는 호출 할 수 있고 일반 객체에 없는 함수만의 고유한 프로퍼티를 갖음</em></p>
<h2 id="2-함수정의"><a href="#2-함수정의" class="headerlink" title="2. 함수정의"></a>2. 함수정의</h2><ul>
<li><p>함수 선언문(Function declaration/Function statement)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>함수 표현식(Function expression)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Function 생성자 함수 (Function constructor)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x + y'</span></span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>화살표 함수 (Arrow function) : ES6</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (x, y) ==&gt; x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="2-1-함수-선언문"><a href="#2-1-함수-선언문" class="headerlink" title="2-1 함수 선언문"></a>2-1 함수 선언문</h3><ul>
<li><p>함수 선언문을 사용하여 함수를 정의하는 방식은 아래와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//함수 참조</span></span><br><span class="line"><span class="comment">//console.dir은 console.log와는 달리 함수 객체의 프로퍼티 까지 출력한다(node.js 환경에서는 console.log와 같은 결과가 출력됨)</span></span><br><span class="line"><span class="built_in">console</span>.dir(add); <span class="comment">// f add(x, y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></li>
<li><p>함수 선언문은 함수 리터럴과 형태가 동일하다.</p>
</li>
<li><p>함수 리터럴은 함수 이름을 생략 할 수 있으나 <em>함수 선언문은 함수 이름을 생략 할 수 없다.</em></p>
</li>
<li><p>함수 선언문은 표현식이 아닌 문이다.(크롬 개발자 도구에서 함수 선언물을 실행하면 완료값으로 undefined를 출력한다.)</p>
</li>
<li><p>함수 선언문이 만약 표현식인 문이라면 완료값 undefined 대신 표현식이 평가되어 생성된 함수가 출력 되어야 함</p>
</li>
<li><p>표현식이 아닌 문은 변수에 할당 할 수 없으나 함수 선언문은 변수에 할당 되는 것 처럼 보인다</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문을 변수에 할당</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">//7</span></span><br></pre></td></tr></table></figure></li>
<li><p>자바스크립트 엔진은 함수 이름이 있는 함수 럴을 단독으로 사용하면 함수 리터럴로 해석</p>
</li>
<li><p>변수에 할당하거나 피연산자로 사용하면 함수 리터럴 표현식으로 해석한다</p>
</li>
</ul>
<h3 id="2-2-함수-표현식"><a href="#2-2-함수-표현식" class="headerlink" title="2-2 함수 표현식"></a>2-2 함수 표현식</h3><ul>
<li>자바스크립트 함수는 값처럼 변수에 할당 할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있다.</li>
<li>이처럼 값의 성질을 갖는 객채를 일급객체라고 한다. 자바스클비트 함수는 일급 객체이다.</li>
<li>일급 객체라고 하는것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다</li>
<li>함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당 할 수 있다.(함수 표현식)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></li>
<li>함수 리터럴의 함수 이름은 생략할 수 있다. 이러한 함수를 익명함수라 한다.</li>
<li>함수 표현식의 함수 리터럴은 이름을 생략하는것이 일반적이다.</li>
<li>자바스크립트 엔진은 함수 선언문의 함수 이름으로 식별자를 암묵적 생성하고 생성된 함수 객체를 할당하므로 함수 표현식과 유사하게 동작하는것 처럼 보인다.</li>
<li>함수 선언문은 표현식이 아닌 문이고 함수 표현식은 표현식인 문이다.</li>
</ul>
<h3 id="2-3-함수-생성-시점과-호이스팅"><a href="#2-3-함수-생성-시점과-호이스팅" class="headerlink" title="2-3 함수 생성 시점과 호이스팅"></a>2-3 함수 생성 시점과 호이스팅</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 참조</span></span><br><span class="line"><span class="built_in">console</span>.dir(add); <span class="comment">//f add(x, y)</span></span><br><span class="line"><span class="built_in">console</span>.dir(sub); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> sub = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다</li>
<li>함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출 할 수 없다</li>
<li>이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.</li>
<li>함수 선언문으로 함수를 정의하면 럴타임 이전에 함수 객체가 먼저 생성된다. 그리고 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 생성하고 생성된 함수 객체를 할당한다.</li>
<li><em>함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅 이라고 한다</em></li>
<li>함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화 된다</li>
<li>변수 할당운의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.</li>
<li>함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아닌 변수 호이스팅이 발생한다</li>
</ul>
<h3 id="2-4-Function-생성자-함수"><a href="#2-4-Function-생성자-함수" class="headerlink" title="2-4 Function 생성자 함수"></a>2-4 Function 생성자 함수</h3><ul>
<li>자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new연산자와 함께 호출하면 객체를 생성하여 반환한다</li>
<li>생성자 함수 : 생성자 함수는 샛체를 생성하는 함수를 말한다. 객체를 생성하는 방식은 객체 리터럴 이외에 다양한 방법이 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x + y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span> + <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Function 생성자 함수는 일반적이지 많으며 바람직 하지도 않다.</li>
<li>Function 생성자 함수로 생성한 함수는 클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.</li>
</ul>
<h3 id="2-5-화살표-함수"><a href="#2-5-화살표-함수" class="headerlink" title="2-5 화살표 함수"></a>2-5 화살표 함수</h3><ul>
<li>ES6에서 새롭게 도입된 화살표 함수는 funtion 키워드 대신 화살표 (=&gt;, Fat arrow)를 사용하여 보다 간략한 방법으로 함수를 선언할 수 있다. </li>
<li>화살표 함수는 항상 익명함수로 정의한다</li>
<li>화살표 함수는 기존의 함수보다 표현이 간략한 것이 아니라 동작 또한 간략화 되어있다.</li>
<li>화살표 함수는 생성자 함수로 사용할 수 없으며 기존의 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments객체를 생성하지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//화살표함수</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x , y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-함수호출"><a href="#3-함수호출" class="headerlink" title="3. 함수호출"></a>3. 함수호출</h2><ul>
<li>함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.</li>
<li>함수 호출 연산자 내에는 0개 이상의 인수를 수비표로 구분하여 나열한다.</li>
<li>함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 컨트롤을 넘긴다.</li>
<li>이떄 매개면수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행되기 시작한다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//함수 호출</span></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 인수 1과 2는 매개변수 x, y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-매개변수와-인수"><a href="#3-1-매개변수와-인수" class="headerlink" title="3-1 매개변수와 인수"></a>3-1 매개변수와 인수</h3><ul>
<li>매개변수는 함수를 정의할 때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급됨</li>
<li>함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 undefined로 초기화 된 이후 인수가 순서대로 할당된다</li>
<li>매개변수 는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다.</li>
<li>함수는 매개변수의 인수와 개수를 체크하지 않는다. </li>
<li>인수가 부족하여 인수가 할당되지 않은 매개변수의 값은 undefined이다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>)); <span class="comment">// 매개변수 y에 전달할 값이 없어 undefined가 되며 산술연산 불가로 NaN</span></span><br></pre></td></tr></table></figure>
<ul>
<li>초과된 인수는 그냥 버러지는 것이 아니다. 모든 인수는 암묵적으로 argunments객체의 프로퍼티로 보관된다.</li>
<li>argunments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용 됨</li>
</ul>
<h3 id="3-2-인수-확인"><a href="#3-2-인수-확인" class="headerlink" title="3-2 인수 확인"></a>3-2 인수 확인</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 위 함수를 정의한 개발자의 의도는 아마 2개의 숫자 타입의 인수를 전달받아 그 합계를 반환하려는 것으로 추측 됨</span></span><br><span class="line"><span class="comment">// 하지만 코드 상으로 어떤 타입의 인수를 전달하여야 하는지 어떤 타입의 값을 반환해야 하는지 명확하지 않음</span></span><br><span class="line"><span class="comment">// 따라서 위 함수는 아래와 같이 호출 될 수 있음</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">'a'</span>, <span class="string">'b'</span>)) <span class="comment">// ab</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위 코드는 자바스크립트 문법상 어떠한 문제도 없으므로 자바스크립트 엔진은 아무런 이의 제기없이 위 코드를 실핼 할 것이다.</li>
<li>이러한 상황이 발생한 이유는 아래와 같기 때문에 함수를 정의할 때 인수가 전달 되었는지 확인이 필요하다<ol>
<li>자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.</li>
<li>자바스크립트 함수는 매개변수의 타입을 사전에 지정 할 수 없다.</li>
</ol>
</li>
</ul>
<h3 id="3-3-매개변수의-최대-개수"><a href="#3-3-매개변수의-최대-개수" class="headerlink" title="3-3 매개변수의 최대 개수"></a>3-3 매개변수의 최대 개수</h3><ul>
<li>ECMAScript 사양에서는 매개변수의 최대 개수에 대해 명시적으로 제한하고 있지 않다.</li>
<li>하지만 물리적 한계는 있으므로 자바스크립트 엔진 마다 매개변수의 최대 개수에 대한 제한이 있겠지만 충분히 많은 매개변수를 지정 할 수 있다</li>
<li>매개변수는 순서에 의미가 있다. </li>
<li>매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야한다.</li>
<li>함수의 매개변수는 코드 이해에  방해가 되는 요소이므로 이상적인 매개변수 개수는 0개이며 적을수록 좋다.</li>
</ul>
<h3 id="3-4-반환문"><a href="#3-4-반환문" class="headerlink" title="3-4 반환문"></a>3-4 반환문</h3><ul>
<li>함수는 <code>return</code>키워드와 반환값으로 이루어진 반환문을 사용하여 실행 결과를 함수 외부로 반환 할 수 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y; <span class="comment">// 값으 반환</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 반환 값으로 평가 됨</span></span><br><span class="line"><span class="keyword">var</span> result = multiply(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></li>
<li>위 예제 중 multiply함수는 두개의 인수를 전달 받아서 곱한 결과값을 반환한다. </li>
<li>반환값은 return 키워드를 사용해 반환한다.</li>
<li>함수는 return키워드를 사용해 자바스크립트에서 사용 가능한 모든 값을 반환할 수 있다.</li>
<li>함수 호출은 표현식이다, 이때 함수 호출 표현식은 return키워드가 반환한 값으로 평가된다.</li>
<li>반환문은 두가지 역할을 한다<ol>
<li>반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.</li>
<li>반환문은 return키워드 뒤에 지정한 값을 반환한다. return키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다.</li>
</ol>
</li>
<li>함수는 반환문을 생략 할 수 있다. 이때 함수는 함수 몸에의 마지막 문까지 실행한 후 암묵적으로 undefined를 반환한다.</li>
<li>return 키워드와 반환값 사이에 줄바꿈이 있으면 세미콜론 자동 삽입 기능에 의해 세미콜론이 추가되어 의도치 않은 결과가 발생할 수 있다.</li>
</ul>
<h2 id="4-참조에-의한-전달과-외부-상태의-변경"><a href="#4-참조에-의한-전달과-외부-상태의-변경" class="headerlink" title="4. 참조에 의한 전달과 외부 상태의 변경"></a>4. 참조에 의한 전달과 외부 상태의 변경</h2><ul>
<li>원시값은 값에의한 전달(pass by value), 객체는 참조에 의한 전달(pass by reference) 방식으로 동작한다</li>
<li>매개변수도 함수 몸체 내부에서 변수와 동일하게 취급 되므로 매개변수 또한 타입에 따라 값에의한 전달, 참조의 의한 전달 방식을 그대로 따른다</li>
<li>함수의 매개변수에 값을 전달하는 방식을 값에의한 호출(call by value), 참조에 의한 호출(call by reference)로 구별해 부르는 경우도 있으나 동작 박식은 값에 의한 전달, 참조에 의한 전달과 동일하다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeVal</span>(<span class="params">primitive, obj</span>) </span>&#123;</span><br><span class="line">  primitive += <span class="number">100</span>;</span><br><span class="line">  obj.name = <span class="string">'yong'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 외부상태</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">'song'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name : "song" &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복가되어 전달된다</span></span><br><span class="line">changeVal(num, person); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 원시값은 원본이 훼손되지 않는다</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체는 원본이 훼손된다</span></span><br><span class="line"><span class="built_in">console</span>. log(person); <span class="comment">// &#123; name : "yong" &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위 예제 중 changeVal 함수는 매개변수를 통해 전달받은 원시타입 인수와 객체타입 인수를 몸체에서 변경한다.</li>
<li>원시타입 인수를 전달받은 매개변수 primitive의 경우, 원시값은 변경 불가능한 값 이므로 직접 변경할 수 없기 때문에 재할당을 통해 원시값을 새로운 원시값으로 교체함</li>
<li>객체 타입의 인수를 전달받은 매개변수 obj의 경우 객체는 변경 가능한 값이므로 직접 변경할 수 있기 때문에 재할당 없이 직접 할당된 객체를 변경함</li>
</ul>
<h2 id="5-다양한-함수의-형태"><a href="#5-다양한-함수의-형태" class="headerlink" title="5. 다양한 함수의 형태"></a>5. 다양한 함수의 형태</h2><h3 id="5-1-즉시-실행-함수"><a href="#5-1-즉시-실행-함수" class="headerlink" title="5-1 즉시 실행 함수"></a>5-1 즉시 실행 함수</h3><ul>
<li>함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 함</li>
<li>즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수 없음</li>
<li>즉시 실행 함수는 함수 이름이 없는 익명함수를 사용하는것이 일반적임</li>
<li>즉시 실행 함수는 반드시 그룹 연산자 (…)로 감싸주어야 한다</li>
<li>그룹 연산자의 피연산자는 값으로 평가되므로 기명 또는 무명 함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다</li>
<li>그룹 연산자로 함수를 묶는 이유는 먼저 함수를 평가하여 함수 객체를 생성하기 위함이다</li>
<li>즉시 실행 함수도 일반 함수처럼 값을 반환 할 수 있고 전달할 수도 있다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 익명 즉시 실행 함수</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//기명 즉시 실행 함수</span></span><br><span class="line"><span class="comment">// 그룹 연산자 (...) 내의 기명 함수는 함수 선언문이 아니라 함수 리터럴로 평가되며 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자 이므로 즉시 실행 함수를 호출할 수 없다</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// referenceError</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-2-재귀-함수"><a href="#5-2-재귀-함수" class="headerlink" title="5-2 재귀 함수"></a>5-2 재귀 함수</h3><ul>
<li>함수가 자기 자신을 호출하는 것을 재귀호출(recursive call)이라 한다.</li>
<li>재귀 함구는 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 팩토리얼(계승)은 1부터 짜신까지의 모든 양의 정수의 곱이다.</span></span><br><span class="line"><span class="comment">// n! = 1 * 2 * ... * (n-1) * n</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 탈출 조건 : n이 1이하일 때 재귀 호출을 멈춘다</span></span><br><span class="line">  <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 재귀호출</span></span><br><span class="line">  <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">0</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">4</span>)); <span class="comment">// 24</span></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure></li>
<li>재귀 함수는 자신을 무한 재귀 호출한다.</li>
<li>따라서 재귀 함수 내에는 재귀 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다.</li>
<li>factorial 함수 내부에서 자기 자신을 호출 할 때 사용한 식별자 factorial은 함수 이름이다.</li>
<li>함수 이름은 함수 몸체 내부에서만 유효하다. 따라서 함수 내부에서는 함수 이름을 사용하여 자기 자신을 호출 할 수 있다</li>
<li>함수 표현식으로 정의한 함수 내부에서는 함수 이름은 물론 함수를 가리키는 식별자로도 자기 자신을 재귀 호출할 수 있다.</li>
<li>단, 함수 호출은 반드시 함수를 가리키는 식별자로 해야한다.</li>
</ul>
<h3 id="5-3-중첩함수"><a href="#5-3-중첩함수" class="headerlink" title="5-3 중첩함수"></a>5-3 중첩함수</h3><ul>
<li>함수 내부에 정의된 함수를 중첩함수 또는 내부함수라 한다.</li>
<li>중첨함수를 포함하는 함수는 외부함수라 부른다.</li>
<li>일반적으로 중첩함수는 자신을 포함하는 외부함수를 돕는 헬퍼 함수의 역할을 한다.</li>
<li>ES6부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하다.</li>
<li>호이스팅으로 인해 혼란이 발생 랑 수 있으므로 if문이나 for문 등의 코드블록에서 함수를 정의하는것은 바람직하지 않다</li>
</ul>
<h3 id="5-4-콜백-함수"><a href="#5-4-콜백-함수" class="headerlink" title="5-4 콜백 함수"></a>5-4 콜백 함수</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n만큼 어떤 일을 반복한다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//i를 출력한다</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">repeat(<span class="number">5</span>); <span class="comment">// 0, 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>repeat함수는 매개변수를 통해 전달받은 숫자만큼 반복하며 console.log(i)를 호출한다. </li>
<li>이때 repeat함수는 console.log(i)에 강하게 의존하고 있어 다른 일을 할 수 없다</li>
<li>따라서 repeat함수의 반복문 내에서 다른 일을 하고 싶다면 함수를 새롭게 정의해야한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">n, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// i를 전달하면서 f를 호출  </span></span><br><span class="line">    f(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logAll = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다.</span></span><br><span class="line">repeat(<span class="number">5</span>, logAll); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logOdds = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다</span></span><br><span class="line">repeat(<span class="number">5</span>, logOdds); <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>위 repeat 함수는 경우에 따라 변경되는 일을 함수 f로 추상화 하고 이를 외부에서 전달 받는다</li>
<li>자바스크립트의 함수는 일급 객체이므로 함수의 매개변수를 통해 함수를 전달할 수 있다.</li>
<li>이처럼 함구의 매개변수를 통해 전달되는 함수를 콜백 함수라고 하며, 콜백 함수를 매개변수를 통해 전달받은 함수를 고차함수 하고 한다.</li>
<li>중첩 함수가 외부 함수를 돕는 헬퍼 함수의 역할을 하는 것처럼 콜백 함수도 고차 함수에 전달되어 헬퍼 함수의 역할을 한다.</li>
<li>단 중첩 함수는 고정되어 있어서 교체하기 곤란하지만 콜백함수는 함수 외부에서 고차함수 내부로 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있음.</li>
<li>고차함수는 콜백 함수를 자신의 일부분으로 합성한다.</li>
<li>고차함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정하여 호출한다.</li>
<li>콜백 함수는 고차 함수에 의해 호출되며 이때 필요에 따라 인수도 전달 될 수 있다.</li>
<li>고차 함수에 콜백 함수를 전달 할 때 콜백 함수를 호출하지 않고 함수 자체를 전달해야 한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 콜백 함수가 고차 함수 내부에만 호출 된다면 콜백함수를 익명 함수 리터럴로 정의하면서 곧바로 고차함수에 전달하는것이 일반적임</span></span><br><span class="line">repeat(<span class="number">5</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>이때 콜백 함수로써 전달된 함수 리터럴은 고차함수가 호출 될 때마다 평가되어 함수 객체를 생성한다.</li>
<li>콜백 함수를 다른 곳에서도 호출할 필요가 있거나, 콜백 함수를 전달받는 함수가 자주 호출 된다면 함수 외부에서 콜백 함수를 정의한 후 함수 참조를 고차 함수에 전달하는 편이 효율적이다</li>
<li>콜백 함수는 일반적으로 비동기처리를 위해 사용하는 중요한 패턴이다</li>
</ul>
<h3 id="5-5-순수-함수와-비순수-함수"><a href="#5-5-순수-함수와-비순수-함수" class="headerlink" title="5-5 순수 함수와 비순수 함수"></a>5-5 순수 함수와 비순수 함수</h3><ul>
<li>함수형 프로그래밍 에서는 어떤 외부 상태에 의존하지도 않고 변경 시키지도 않는, 즉 부수효과가 없는 함수를 순수 함수하고 부르고, 외부 상태를 변경(부수효과)가 있는 함수를 비순수 함수라고 부른다.</li>
</ul>
<h4 id="순수함수"><a href="#순수함수" class="headerlink" title="순수함수"></a>순수함수</h4><ul>
<li>순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수를 말한다.</li>
<li>순수 함수는 어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 반환값을 만든다.</li>
<li>함수의 외부 상태에 의존하는 함수는 외부 상태에 따라 반환값이 달라진다.</li>
<li>순수 함수는 함수 외부상태를 변경하지 않는다<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>; <span class="comment">// 현재 카운트를 나타내는 상태</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 외부상태에 의존하지 않으며 변경하지도 않는 순수함수</span></span><br><span class="line"><span class="comment">// 순수함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 순수 함수가 반환한 결과값을 변수에 재할당 하여 상태를 변경</span></span><br><span class="line">count = increase(count);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">count = increase(count);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="비순수함수"><a href="#비순수함수" class="headerlink" title="비순수함수"></a>비순수함수</h4><ul>
<li>함수 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 함수를 비순수 함수라고 한다.</li>
<li>비순수 함수는 순수 함수와는 달리 외부 함수의 상태를 변경시키는 부수효과가 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>; <span class="comment">// 현재 카운트를 나타내는 상태 : increase 함수에 의해 변화한다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 외부 상태에 의존하여 외부 상태에 따라 변환값이 달라지는 비순수 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++count; <span class="comment">// 외부 상태를 변경한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 비순수 함수는 외부 상태를 변경하므로 상태 변화를 추적하기 어려워진다</span></span><br><span class="line">increase();</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">increase();</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><em>함수형 프로그래밍은 변수의 사용을 억제하여 상태 변경을 최소화 하고 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하려는 프로그래밍 패러다임</em></p>
<h1 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h1><h2 id="1-스코프란"><a href="#1-스코프란" class="headerlink" title="1. 스코프란?"></a>1. 스코프란?</h2><ul>
<li>스코프(Scope, 유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이고 중요한 개념임</li>
<li>var 키워드로 선언한 변수와 let 또는 const 키워드로 선언한 변수의 스코프도 다르게 동작함</li>
<li>함수의 매개변수가 함수 몸체 내부에서만 참조할수 있는 것은 매개변수의 스코프가 함수 몸체 내부로 한정되기 때문이다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.</span></span><br><span class="line">  <span class="comment">// 즉 매개변수의 스코프는 함수 몸체 내부이다</span></span><br><span class="line">  <span class="built_in">console</span>.log(x, y); <span class="comment">// 2 5</span></span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//매개변수는 함수 몸체 내부에서만 함조할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(x, y); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure></li>
<li>변수는 코드의 가장 바깥 영역 뿐만 아니라 코드 블록이나 함수 몸체 내에서도 선언 할 수 있다.</li>
<li>이때 코드 블록이나 함수는 중첩될 수 있다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> var1 = <span class="number">1</span>; <span class="comment">// 코드의 가장 바깥 영역에서의 선언</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> var2 = <span class="number">2</span>; <span class="comment">//코드블록 내에서 선언된 변수</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> var3 = <span class="number">3</span>; <span class="comment">//중첩된 코드블럭 내에서 선언된 번수</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> var4 = <span class="number">4</span>; <span class="comment">// 함수 내에서 선언된 변수</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> var5 = <span class="number">5</span>; <span class="comment">// 중첩된 함수 내에서 선언된 변수</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(var1); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(var2); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(var3); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(var4); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="built_in">console</span>.log(var5); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<ul>
<li>변수는 자신이 선언된 위치에 의해 자신이 유효한 번위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정된다.</li>
<li>변수 뿐만 아니라 모든 식별자가 그렇다</li>
<li>모든 식별자(변수이름, 함수이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정된다. 이를 스코프라 한다</li>
<li>즉, 스코프는 식별자가 유효한 범위를 말한다</li>
<li>스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙 이하고도 할 수 있다</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'local'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// "local"</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// "global"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위 예제에서 코드의 가장 바깥 영역에 선언된 변수 x는 어디서든 참조할 수 있다.</li>
<li>하지만 foo 내부에서 선언된 변수 x는 함수 foo내부에서만 참조 할 수 있고 foo 외부에서는 참조할 수 없다.</li>
<li>이때 두개의 변수 x는 식별자 이름이 동일하지만 자신이 유효한 범위, 즉 스코프가 다른 별개의 변수이다.</li>
</ul>
<h2 id="2-스코프의-종류"><a href="#2-스코프의-종류" class="headerlink" title="2. 스코프의 종류"></a>2. 스코프의 종류</h2><ul>
<li>코드는 전역(global)과 지역(local)으로 구분할 수 있다.</li>
<li>전역 : 코드의 가장 바깥 영역 : 전역스코프 : 전역변수</li>
<li>지역 : 함수 몸체 내부 : 지역스코프 : 지역변수</li>
<li>이때 변수는 자신이 선언된 위치에 의해 자신이 유효한 범위인 스코프가 결정된다.</li>
<li>전역에서 선언된 변수는 전역 스코프를 갖는 전역변수이고, 지역에서 선언된 변수는 지역 스코프를 같는 지역 변수이다</li>
</ul>
<h3 id="2-1-전역과-전역-스코프"><a href="#2-1-전역과-전역-스코프" class="headerlink" title="2-1 전역과 전역 스코프"></a>2-1 전역과 전역 스코프</h3><ul>
<li>전역이란 코드의 가장 바깥 영역을 말한다.</li>
<li>전역은 전역 스코프를 만든다.</li>
<li>전역에 변수를 선언하면 전역 스코프를 갖는 전역변수가 된다.</li>
<li><em>전역 변수는 어디서든지 참조할 수 있다</em></li>
<li>전역 변수는 어디서든지 참조할 수 있으므로 함수 내부에서도 참조 할 수 있다.</li>
</ul>
<h3 id="2-2-지역과-지역-스코프"><a href="#2-2-지역과-지역-스코프" class="headerlink" title="2-2 지역과 지역 스코프"></a>2-2 지역과 지역 스코프</h3><ul>
<li>지역이란 함수 몸체 내부를 말한다.</li>
<li>지역은 지역 스코프를 만든다.</li>
<li>지역 변수는 자신이 선언된 지역과 하위 지역에서만 참조할 수 있다.</li>
<li>지역변수는 자인의 지역 스코프와 하위 지역 스코프에서 유효하다.</li>
</ul>
<h2 id="3-스코프체인"><a href="#3-스코프체인" class="headerlink" title="3. 스코프체인"></a>3. 스코프체인</h2><ul>
<li><p>함수는 전역에서 정의할 수도 있고 함수 몸체 내부에서 정의할 수도 있다.</p>
</li>
<li><p>함수 몸체 내부에서 함수가 정의된 것을 함수의 중첩이라 한다</p>
</li>
<li><p>함수 몸체 내부에서 정의한 함수를 중첩함수, 중첩함수를 포함하는 함수를 외부함수 라고 한다.</p>
</li>
<li><p>함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다.</p>
</li>
<li><p>이는 스코프는 함수의 중첩에 의해 계층적 구조를 갖는다는것을 의미한다.</p>
</li>
<li><p>중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 계층적 구조를 갖는다.</p>
</li>
<li><p>이때 외부 함수의 지역 스코프를 중첩함수의 상위 스코프라고 한다.</p>
</li>
<li><p>모든 스코프는 하나의 계층적 구조로 연결되며 모든 지역 스코프의 최상위 스코프는 전역 스코프이다.</p>
</li>
<li><p>이렇게 스코프가 계층적으로 연결된 것을 스코프 쳬인이라 부른다.</p>
</li>
<li><p>변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시자가하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.</p>
</li>
</ul>
<h3 id="3-1-스코프-체인에-의한-변수-검색"><a href="#3-1-스코프-체인에-의한-변수-검색" class="headerlink" title="3-1 스코프 체인에 의한 변수 검색"></a>3-1 스코프 체인에 의한 변수 검색</h3><ul>
<li>스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.</li>
<li>상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다</li>
</ul>
<h3 id="3-2-스코프-체인에의한-함수-검색"><a href="#3-2-스코프-체인에의한-함수-검색" class="headerlink" title="3-2 스코프 체인에의한 함수 검색"></a>3-2 스코프 체인에의한 함수 검색</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'golobal function foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'local function foo'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  foo(); <span class="comment">// (1)</span></span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<ul>
<li>함수 선언문으로 함수를 정의하면 자바스크립트 엔진에 의해 다른 코드가 실행되기 전에 함수 객체가 먼저 생성된다.</li>
<li>그리고 자바스크립트 엔진은 함수 이름과 동일한 이름의 변수를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.</li>
<li>따라서 위 예제의 모든 함수는 자바 스크립트 엔진에 의해 암묵적으로 선언된 함수 이름과 동일한 이름의 변수에 할당된다.</li>
<li>(1) 에서 함수 foo를 호출하면 자바스크립트 엔진은 함수를 호출하기 위해 먼저 함수를 가리키는 변수 foo를 검색한다.</li>
<li>이처럼 함수도 변수에 할당되기 때문에 스코프를 갖는다.</li>
<li>함수는 변수에 함수 객체가 할당되는것 외에는 일반 변수와 다를바가 없다.</li>
<li>따라서 변수를 검색할 때 사용하는 규칙 이라기 보다 식별자를 검색하는 규칙이라고 표현하는것이 보다 더 적합하다.</li>
</ul>
<h2 id="4-함수-레벨-스코프"><a href="#4-함수-레벨-스코프" class="headerlink" title="4. 함수 레벨 스코프"></a>4. 함수 레벨 스코프</h2><ul>
<li>지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다</li>
<li>이는 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다는 의미다.</li>
<li>c, java등 대부분의 프로그래밍 언어는 함수 몸체 만이 아니라 모든 코드블록이 이력 스코프를 만든다</li>
<li>이러한 특성을 블록레벨 스코프라고 한다</li>
<li>하지만 var키워드로 선언된 변수는 오로지 함수의 코드블록만을 지력 스코프로 인정한다. 이러한 특성을 함수레벨 스코프라고 한다.</li>
<li>let, const키워드는 블록레벨 스코프를 지원한다.</li>
</ul>
<h2 id="5-렉시컬-스코프"><a href="#5-렉시컬-스코프" class="headerlink" title="5. 렉시컬 스코프"></a>5. 렉시컬 스코프</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line">bar(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>위 예제 싱행 결과는 함수 bar의 상위 스코프가 무엇인지에 따라 결정된다. 두가지 패턴을 예측할 수 있다</p>
<ol>
<li>함수를 어디러 호출했는지에 따라 함수의 상위 스코프를 결정한다</li>
<li>함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다.</li>
</ol>
</li>
<li><p>첫번쨔 방식으로 함수의 상위 스코프를 결정한다면 함수 bar의 상위 스코프는 삼수 foo와 전역일 것이다</p>
</li>
<li><p>두번째 방식으로 함수의 상위 스코프를 결정한다면 함수 bar의 상위 스코프는 전역일 것이다</p>
</li>
<li><p>프로그래밍 언어는 일반적으로 이 두가지 방식 중 하나의 방식으로 함수의 상위 스코프를 결정한다.</p>
</li>
<li><p>첫번째 방식을 동적 스코프라 한다.</p>
</li>
<li><p>함수가 어디서 호출 될 지 알수 없다</p>
</li>
<li><p>함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 동적 스코프라 부른다.</p>
</li>
<li><p>두번째 방식을 렉시컬 스코프라 한다.</p>
</li>
<li><p>함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프라 부른다.</p>
</li>
</ul>
<p><em>자바스크립트는 렉시클 스코프를 따른다</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="다음 페이지"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          흝어보기
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">angryboo</p>
  <div class="site-description" itemprop="description">I can do this all day</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">카테고리</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">태그</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">angryboo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
